---
phase: 09-historical-metrics-storage
plan: 05
type: execute
wave: 3
depends_on: ["09-03"]
files_modified:
  - src/dashboard/src/components/ServerSparkline.tsx
  - src/dashboard/src/components/ServerCard.tsx
  - src/dashboard/src/hooks/useMetricsStream.ts
  - src/dashboard/src/App.tsx
  - src/dashboard/src/App.css
autonomous: true

must_haves:
  truths:
    - "Server cards show mini sparklines of last hour latency"
    - "Clicking sparkline navigates to History tab filtered to that server"
    - "History tab is accessible as third tab in navigation"
    - "Real-time metrics stream updates sparklines"
  artifacts:
    - path: "src/dashboard/src/components/ServerSparkline.tsx"
      provides: "react-sparklines wrapper for server cards"
      contains: "Sparklines"
    - path: "src/dashboard/src/components/ServerCard.tsx"
      provides: "Enhanced server card with sparkline"
      contains: "ServerSparkline"
    - path: "src/dashboard/src/hooks/useMetricsStream.ts"
      provides: "SignalR hook for real-time metrics"
      contains: "MetricsSample"
    - path: "src/dashboard/src/App.css"
      provides: "Styling for History tab and sparklines"
      contains: "history-tab"
  key_links:
    - from: "ServerCard.tsx"
      to: "ServerSparkline.tsx"
      via: "Component composition"
      pattern: "ServerSparkline"
    - from: "App.tsx"
      to: "HistoryTab.tsx"
      via: "Tab navigation"
      pattern: "activeTab.*history"
---

<objective>
Add sparklines to server cards, integrate History tab into App navigation, create SignalR hook for real-time metrics streaming, and add CSS styling.

Purpose: Complete the History feature with inline sparklines and proper app integration.
Output: Full metrics visualization with sparklines on cards and History tab accessible.
</objective>

<execution_context>
@C:\Users\UserC\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\UserC\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/09-historical-metrics-storage/09-CONTEXT.md
@.planning/phases/09-historical-metrics-storage/09-RESEARCH.md
@src/dashboard/src/App.tsx
@src/dashboard/src/App.css
@src/dashboard/src/components/ServerCard.tsx
@src/dashboard/src/hooks/useSignalR.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create ServerSparkline and useMetricsStream hook</name>
  <files>
    src/dashboard/src/components/ServerSparkline.tsx
    src/dashboard/src/hooks/useMetricsStream.ts
  </files>
  <action>
1. Create src/dashboard/src/components/ServerSparkline.tsx:

   import { Sparklines, SparklinesLine, SparklinesReferenceLine } from 'react-sparklines';

   interface ServerSparklineProps {
     data: number[];  // Last N latency values (nulls converted to 0)
     isHealthy: boolean;
     onClick?: () => void;
     width?: number;
     height?: number;
   }

   /**
    * Mini sparkline showing latency trend for a server.
    * Colored green when healthy, red when unhealthy.
    * Click to navigate to History tab filtered to this server.
    */
   export function ServerSparkline({
     data,
     isHealthy,
     onClick,
     width = 80,
     height = 20
   }: ServerSparklineProps) {
     // Handle empty data
     if (data.length === 0) {
       return (
         <div
           className="server-sparkline server-sparkline--empty"
           onClick={onClick}
           title="No metrics data yet"
         >
           <span className="sparkline-placeholder">--</span>
         </div>
       );
     }

     const color = isHealthy ? '#22c55e' : '#ef4444';

     return (
       <div
         className="server-sparkline"
         onClick={onClick}
         title="Click to view history"
         role="button"
         tabIndex={0}
         onKeyDown={(e) => e.key === 'Enter' && onClick?.()}
       >
         <Sparklines data={data} width={width} height={height} margin={2}>
           <SparklinesLine color={color} style={{ strokeWidth: 1.5, fill: 'none' }} />
           <SparklinesReferenceLine type="mean" style={{ stroke: '#999', strokeDasharray: '2,2' }} />
         </Sparklines>
       </div>
     );
   }

   export default ServerSparkline;

2. Create src/dashboard/src/hooks/useMetricsStream.ts:

   import { useState, useEffect, useCallback, useRef } from 'react';
   import { HubConnectionBuilder, HubConnection, HubConnectionState, LogLevel } from '@microsoft/signalr';
   import { MetricsSampleEvent } from '../types/metrics';

   interface UseMetricsStreamResult {
     latestSamples: Map<string, number[]>;  // serverId -> last 60 latency values
     isConnected: boolean;
     error: string | null;
   }

   const MAX_SAMPLES = 60;  // Keep last 60 samples (5 minutes at 5s interval)

   export function useMetricsStream(hubUrl: string): UseMetricsStreamResult {
     const [isConnected, setIsConnected] = useState(false);
     const [error, setError] = useState<string | null>(null);
     const [latestSamples, setLatestSamples] = useState<Map<string, number[]>>(new Map());
     const connectionRef = useRef<HubConnection | null>(null);

     useEffect(() => {
       const connection = new HubConnectionBuilder()
         .withUrl(hubUrl)
         .withAutomaticReconnect([0, 2000, 5000, 10000, 30000])
         .configureLogging(LogLevel.Warning)
         .build();

       connectionRef.current = connection;

       connection.on('MetricsSample', (event: MetricsSampleEvent) => {
         setLatestSamples(prev => {
           const next = new Map(prev);
           for (const sample of event.samples) {
             const current = next.get(sample.serverId) || [];
             const latency = sample.latencyMs ?? 0;  // Convert null to 0 for sparkline
             const updated = [...current, latency].slice(-MAX_SAMPLES);
             next.set(sample.serverId, updated);
           }
           return next;
         });
       });

       connection.onreconnecting(() => {
         setIsConnected(false);
         setError('Reconnecting...');
       });

       connection.onreconnected(() => {
         setIsConnected(true);
         setError(null);
       });

       connection.onclose((err) => {
         setIsConnected(false);
         if (err) setError(err.message);
       });

       connection.start()
         .then(() => {
           setIsConnected(true);
           setError(null);
         })
         .catch((err) => {
           setError(err.message);
         });

       return () => {
         connection.stop();
       };
     }, [hubUrl]);

     return { latestSamples, isConnected, error };
   }

   export default useMetricsStream;
  </action>
  <verify>
    cd src/dashboard && npm run build
  </verify>
  <done>
    ServerSparkline renders mini chart with react-sparklines, useMetricsStream receives real-time samples via SignalR.
  </done>
</task>

<task type="auto">
  <name>Task 2: Enhance ServerCard with sparkline and update App.tsx</name>
  <files>
    src/dashboard/src/components/ServerCard.tsx
    src/dashboard/src/App.tsx
  </files>
  <action>
1. Update src/dashboard/src/components/ServerCard.tsx:

   Add sparkline to server card. The sparkline data comes from App.tsx via props.

   interface ServerCardProps {
     server: ServerStatus;
     onClick: () => void;
     sparklineData?: number[];  // NEW: Latency values for sparkline
     onSparklineClick?: () => void;  // NEW: Navigate to History tab
   }

   In the component body, add sparkline after server-metrics div:

   {sparklineData && sparklineData.length > 0 && (
     <div className="server-card-sparkline">
       <ServerSparkline
         data={sparklineData}
         isHealthy={server.isHealthy}
         onClick={(e) => {
           e?.stopPropagation();  // Don't trigger card click
           onSparklineClick?.();
         }}
       />
     </div>
   )}

   Add import at top:
   import ServerSparkline from './ServerSparkline';

2. Update src/dashboard/src/App.tsx:

   a. Add History tab to navigation and active tab state:

      const [activeTab, setActiveTab] = useState<'servers' | 'files' | 'history'>('servers');

   b. Add History tab button in header-tabs:

      <button
        className={`header-tab ${activeTab === 'history' ? 'header-tab--active' : ''}`}
        onClick={() => setActiveTab('history')}
        type="button"
      >
        History
      </button>

   c. Add metrics stream hook:

      const metricsHubUrl = `${apiBaseUrl}/hubs/metrics`;
      const { latestSamples } = useMetricsStream(metricsHubUrl);

   d. Track selected server for History tab filter:

      const [historyServerId, setHistoryServerId] = useState<string | undefined>();

   e. Update ServerGrid to pass sparkline data and click handler:

      <ServerGrid
        servers={data.servers}
        onCardClick={setSelectedServer}
        sparklineData={latestSamples}
        onSparklineClick={(serverId) => {
          setHistoryServerId(serverId);
          setActiveTab('history');
        }}
      />

   f. Add History tab rendering:

      {activeTab === 'history' && (
        <HistoryTab
          apiBaseUrl={apiBaseUrl}
          initialServerId={historyServerId}
        />
      )}

   g. Add imports:

      import HistoryTab from './components/HistoryTab';
      import { useMetricsStream } from './hooks/useMetricsStream';

3. Update ServerGrid.tsx to pass sparkline props to ServerCard:

   interface ServerGridProps {
     servers: ServerStatus[];
     onCardClick: (server: ServerStatus) => void;
     sparklineData?: Map<string, number[]>;  // NEW
     onSparklineClick?: (serverId: string) => void;  // NEW
   }

   In the map function:

   <ServerCard
     key={server.name}
     server={server}
     onClick={() => onCardClick(server)}
     sparklineData={sparklineData?.get(server.name)}
     onSparklineClick={() => onSparklineClick?.(server.name)}
   />
  </action>
  <verify>
    cd src/dashboard && npm run build
  </verify>
  <done>
    ServerCard shows sparkline, History tab accessible via navigation, sparkline click filters History by server.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add CSS styling for History tab, sparklines, and time range selector</name>
  <files>
    src/dashboard/src/App.css
  </files>
  <action>
Add CSS at the end of App.css (after existing styles):

/* ===== History Tab Styles ===== */

.history-tab {
  padding: var(--spacing-md);
}

.history-tab-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: var(--spacing-md);
  flex-wrap: wrap;
  gap: var(--spacing-sm);
}

.history-tab-header h2 {
  margin: 0;
  font-size: 1.25rem;
  color: var(--text-primary);
}

.history-tab-filters {
  display: flex;
  align-items: center;
  gap: var(--spacing-md);
  margin-bottom: var(--spacing-md);
  flex-wrap: wrap;
}

.history-tab-filters label {
  display: flex;
  align-items: center;
  gap: var(--spacing-xs);
  color: var(--text-secondary);
}

.history-tab-filters select {
  padding: var(--spacing-xs) var(--spacing-sm);
  border: 1px solid var(--border-color);
  border-radius: var(--border-radius);
  background: var(--card-background);
  color: var(--text-primary);
}

.resolution-badge {
  padding: var(--spacing-xs) var(--spacing-sm);
  background: var(--border-color);
  border-radius: var(--border-radius);
  font-size: 0.75rem;
  color: var(--text-secondary);
}

.history-tab-error {
  padding: var(--spacing-md);
  background: rgba(239, 68, 68, 0.1);
  border: 1px solid #ef4444;
  border-radius: var(--border-radius);
  color: #ef4444;
  margin-bottom: var(--spacing-md);
}

.history-tab-loading,
.history-tab-empty {
  padding: var(--spacing-xl);
  text-align: center;
  color: var(--text-secondary);
}

.history-tab-stats {
  margin-top: var(--spacing-md);
  font-size: 0.875rem;
  color: var(--text-secondary);
}

/* ===== Time Range Selector ===== */

.time-range-selector {
  display: flex;
  align-items: center;
  gap: var(--spacing-sm);
  flex-wrap: wrap;
}

.time-range-presets {
  display: flex;
  gap: 2px;
}

.time-range-preset {
  padding: var(--spacing-xs) var(--spacing-sm);
  border: 1px solid var(--border-color);
  background: var(--card-background);
  color: var(--text-secondary);
  cursor: pointer;
  transition: all 0.15s ease;
  font-size: 0.875rem;
}

.time-range-preset:first-child {
  border-radius: var(--border-radius) 0 0 var(--border-radius);
}

.time-range-preset:last-child {
  border-radius: 0 var(--border-radius) var(--border-radius) 0;
}

.time-range-preset:not(:last-child) {
  border-right: none;
}

.time-range-preset:hover {
  background: var(--border-color);
}

.time-range-preset--active {
  background: var(--status-healthy);
  color: white;
  border-color: var(--status-healthy);
}

.time-range-dropdown {
  padding: var(--spacing-xs) var(--spacing-sm);
  border: 1px solid var(--border-color);
  border-radius: var(--border-radius);
  background: var(--card-background);
  color: var(--text-primary);
  font-size: 0.875rem;
}

.time-range-auto-refresh {
  display: flex;
  align-items: center;
  gap: var(--spacing-xs);
  font-size: 0.875rem;
  color: var(--text-secondary);
  cursor: pointer;
}

.time-range-auto-refresh input {
  cursor: pointer;
}

/* ===== Latency Chart ===== */

.latency-chart {
  background: var(--card-background);
  border: 1px solid var(--border-color);
  border-radius: var(--border-radius);
  padding: var(--spacing-md);
}

.latency-chart-controls {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: var(--spacing-sm);
}

.zoom-reset-btn {
  padding: var(--spacing-xs) var(--spacing-sm);
  border: 1px solid var(--border-color);
  border-radius: var(--border-radius);
  background: var(--card-background);
  color: var(--text-primary);
  cursor: pointer;
  font-size: 0.875rem;
}

.zoom-reset-btn:disabled {
  opacity: 0.5;
  cursor: not-allowed;
}

.zoom-hint {
  font-size: 0.75rem;
  color: var(--text-secondary);
}

/* ===== Server Sparkline ===== */

.server-card-sparkline {
  margin-top: var(--spacing-sm);
  padding-top: var(--spacing-sm);
  border-top: 1px solid var(--border-color);
}

.server-sparkline {
  cursor: pointer;
  padding: 2px;
  border-radius: var(--border-radius);
  transition: background 0.15s ease;
}

.server-sparkline:hover {
  background: rgba(0, 0, 0, 0.05);
}

.server-sparkline--empty {
  display: flex;
  align-items: center;
  justify-content: center;
  height: 20px;
}

.sparkline-placeholder {
  font-size: 0.75rem;
  color: var(--text-secondary);
}

/* ===== Recharts Overrides ===== */

.recharts-cartesian-grid-horizontal line,
.recharts-cartesian-grid-vertical line {
  stroke: var(--border-color);
}

.recharts-text {
  fill: var(--text-secondary);
}

.recharts-legend-item-text {
  color: var(--text-primary) !important;
}
  </action>
  <verify>
    cd src/dashboard && npm run build
  </verify>
  <done>
    CSS styling complete for History tab, time range selector, latency chart, and sparklines.
  </done>
</task>

</tasks>

<verification>
1. npm run build in src/dashboard compiles without errors
2. ServerCard has sparkline section with click handler
3. App.tsx has three tabs: Servers, Files, History
4. useMetricsStream hook connects to /hubs/metrics
5. CSS provides consistent styling matching existing dashboard theme
</verification>

<success_criteria>
- Server cards display mini sparkline showing latency trend
- Sparkline colored green/red based on current health state
- Clicking sparkline navigates to History tab filtered to that server
- History tab accessible as third tab in navigation
- Real-time metrics update sparklines as new samples arrive
- Styling consistent with existing dashboard theme
</success_criteria>

<output>
After completion, create `.planning/phases/09-historical-metrics-storage/09-05-SUMMARY.md`
</output>
