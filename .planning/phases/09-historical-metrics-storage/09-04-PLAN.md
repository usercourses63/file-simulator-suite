---
phase: 09-historical-metrics-storage
plan: 04
type: execute
wave: 3
depends_on: ["09-03"]
files_modified:
  - src/dashboard/package.json
  - src/dashboard/src/types/metrics.ts
  - src/dashboard/src/hooks/useMetrics.ts
  - src/dashboard/src/hooks/useMetricsStream.ts
  - src/dashboard/src/components/TimeRangeSelector.tsx
  - src/dashboard/src/components/LatencyChart.tsx
  - src/dashboard/src/components/HistoryTab.tsx
autonomous: true

must_haves:
  truths:
    - "Recharts and date-fns packages are installed"
    - "Dashboard can fetch historical metrics from API"
    - "HistoryTab shows latency trends with time range selection"
    - "User can zoom into chart by click-and-drag"
  artifacts:
    - path: "src/dashboard/src/types/metrics.ts"
      provides: "TypeScript types matching backend DTOs"
      contains: "HealthSampleDto"
    - path: "src/dashboard/src/hooks/useMetrics.ts"
      provides: "Hook for fetching historical metrics"
      exports: ["useMetrics"]
    - path: "src/dashboard/src/components/LatencyChart.tsx"
      provides: "Recharts LineChart with zoom functionality"
      contains: "ReferenceArea"
    - path: "src/dashboard/src/components/HistoryTab.tsx"
      provides: "Full charting interface with time range controls"
      contains: "TimeRangeSelector"
  key_links:
    - from: "HistoryTab.tsx"
      to: "/api/metrics/samples"
      via: "useMetrics hook"
      pattern: "useMetrics|/api/metrics"
    - from: "LatencyChart.tsx"
      to: "ReferenceArea"
      via: "Zoom state management"
      pattern: "refAreaLeft|refAreaRight"
---

<objective>
Install frontend packages (Recharts, date-fns, react-sparklines), create metrics types and hooks, and build HistoryTab with zoomable latency chart.

Purpose: Enable historical trend visualization with interactive charting.
Output: Working History tab with time range selector and zoomable latency chart.
</objective>

<execution_context>
@C:\Users\UserC\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\UserC\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/09-historical-metrics-storage/09-CONTEXT.md
@.planning/phases/09-historical-metrics-storage/09-RESEARCH.md
@src/dashboard/package.json
@src/dashboard/src/App.tsx
@src/dashboard/src/hooks/useSignalR.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install npm packages and create metrics types</name>
  <files>
    src/dashboard/package.json
    src/dashboard/src/types/metrics.ts
  </files>
  <action>
1. Install npm packages in src/dashboard:
   npm install recharts date-fns react-sparklines
   npm install --save-dev @types/react-sparklines

2. Create src/dashboard/src/types/metrics.ts with TypeScript interfaces matching backend DTOs:

   // Query parameters for metrics API
   export interface MetricsQueryParams {
     serverId?: string;
     serverType?: string;
     startTime: string;  // ISO 8601
     endTime: string;    // ISO 8601
   }

   // Raw sample from /api/metrics/samples
   export interface HealthSampleDto {
     id: number;
     timestamp: string;  // ISO 8601
     serverId: string;
     serverType: string;
     isHealthy: boolean;
     latencyMs: number | null;
   }

   // Hourly aggregation from /api/metrics/hourly
   export interface HealthHourlyDto {
     id: number;
     hourStart: string;  // ISO 8601
     serverId: string;
     serverType: string;
     sampleCount: number;
     healthyCount: number;
     avgLatencyMs: number | null;
     minLatencyMs: number | null;
     maxLatencyMs: number | null;
     p95LatencyMs: number | null;
     uptimePercent: number;
   }

   // Response from /api/metrics/samples
   export interface MetricsSamplesResponse {
     samples: HealthSampleDto[];
     totalCount: number;
     queryStart: string;
     queryEnd: string;
   }

   // Response from /api/metrics/hourly
   export interface MetricsHourlyResponse {
     hourly: HealthHourlyDto[];
     totalCount: number;
     queryStart: string;
     queryEnd: string;
   }

   // Server with metrics info from /api/metrics/servers
   export interface ServerWithMetrics {
     serverId: string;
     serverType: string;
     firstSample: string;
     lastSample: string;
     totalSamples: number;
   }

   // Real-time sample from SignalR MetricsHub
   export interface MetricsSampleEvent {
     timestamp: string;
     samples: Array<{
       serverId: string;
       serverType: string;
       isHealthy: boolean;
       latencyMs: number | null;
     }>;
   }

   // Time range preset
   export interface TimeRangePreset {
     label: string;
     value: string;  // e.g., "1h", "6h", "24h", "7d"
   }

   // Chart data point (flattened for Recharts)
   export interface ChartDataPoint {
     timestamp: number;  // Unix timestamp for XAxis
     [serverId: string]: number | null | undefined;  // Latency per server
   }
  </action>
  <verify>
    cd src/dashboard && npm install && npm run build
  </verify>
  <done>
    Recharts, date-fns, react-sparklines installed; metrics.ts types created.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create useMetrics hook and TimeRangeSelector component</name>
  <files>
    src/dashboard/src/hooks/useMetrics.ts
    src/dashboard/src/components/TimeRangeSelector.tsx
  </files>
  <action>
1. Create src/dashboard/src/hooks/useMetrics.ts:

   import { useState, useEffect, useCallback } from 'react';
   import { MetricsSamplesResponse, MetricsHourlyResponse, MetricsQueryParams } from '../types/metrics';

   interface UseMetricsOptions {
     apiBaseUrl: string;
     serverId?: string;
     serverType?: string;
     startTime: Date;
     endTime: Date;
     resolution: 'raw' | 'hourly';
     autoRefresh?: boolean;
     refreshInterval?: number;  // ms, default 30000
   }

   interface UseMetricsResult {
     data: MetricsSamplesResponse | MetricsHourlyResponse | null;
     isLoading: boolean;
     error: string | null;
     refresh: () => void;
   }

   export function useMetrics(options: UseMetricsOptions): UseMetricsResult {
     const [data, setData] = useState<MetricsSamplesResponse | MetricsHourlyResponse | null>(null);
     const [isLoading, setIsLoading] = useState(true);
     const [error, setError] = useState<string | null>(null);

     const fetchMetrics = useCallback(async () => {
       setIsLoading(true);
       setError(null);

       const params = new URLSearchParams({
         startTime: options.startTime.toISOString(),
         endTime: options.endTime.toISOString()
       });

       if (options.serverId) params.set('serverId', options.serverId);
       if (options.serverType) params.set('serverType', options.serverType);

       const endpoint = options.resolution === 'raw'
         ? `${options.apiBaseUrl}/api/metrics/samples`
         : `${options.apiBaseUrl}/api/metrics/hourly`;

       try {
         const response = await fetch(`${endpoint}?${params}`);
         if (!response.ok) {
           throw new Error(`HTTP ${response.status}: ${await response.text()}`);
         }
         const json = await response.json();
         setData(json);
       } catch (err) {
         setError(err instanceof Error ? err.message : 'Unknown error');
       } finally {
         setIsLoading(false);
       }
     }, [options.apiBaseUrl, options.serverId, options.serverType, options.startTime, options.endTime, options.resolution]);

     useEffect(() => {
       fetchMetrics();
     }, [fetchMetrics]);

     useEffect(() => {
       if (!options.autoRefresh) return;

       const interval = setInterval(fetchMetrics, options.refreshInterval || 30000);
       return () => clearInterval(interval);
     }, [fetchMetrics, options.autoRefresh, options.refreshInterval]);

     return { data, isLoading, error, refresh: fetchMetrics };
   }

2. Create src/dashboard/src/components/TimeRangeSelector.tsx (from RESEARCH.md example):

   import { useState } from 'react';

   interface TimeRangeSelectorProps {
     onRangeChange: (startTime: Date, endTime: Date) => void;
     defaultRange?: string;
   }

   const PRESETS = [
     { label: '1h', value: '1h' },
     { label: '6h', value: '6h' },
     { label: '24h', value: '24h' },
     { label: '7d', value: '7d' }
   ];

   const DROPDOWN_OPTIONS = [
     { label: '15 minutes', value: '15m' },
     { label: '30 minutes', value: '30m' },
     { label: '1 hour', value: '1h' },
     { label: '2 hours', value: '2h' },
     { label: '6 hours', value: '6h' },
     { label: '12 hours', value: '12h' },
     { label: '24 hours', value: '24h' },
     { label: '3 days', value: '3d' },
     { label: '7 days', value: '7d' }
   ];

   function parseRange(value: string): { startTime: Date; endTime: Date } {
     const endTime = new Date();
     const startTime = new Date();

     const match = value.match(/^(\d+)([mhd])$/);
     if (!match) throw new Error(`Invalid range: ${value}`);

     const [, num, unit] = match;
     const amount = parseInt(num, 10);

     switch (unit) {
       case 'm': startTime.setMinutes(startTime.getMinutes() - amount); break;
       case 'h': startTime.setHours(startTime.getHours() - amount); break;
       case 'd': startTime.setDate(startTime.getDate() - amount); break;
     }

     return { startTime, endTime };
   }

   export function TimeRangeSelector({ onRangeChange, defaultRange = '24h' }: TimeRangeSelectorProps) {
     const [selectedRange, setSelectedRange] = useState(defaultRange);
     const [autoRefresh, setAutoRefresh] = useState(false);

     const handleRangeSelect = (value: string) => {
       setSelectedRange(value);
       const { startTime, endTime } = parseRange(value);
       onRangeChange(startTime, endTime);
     };

     return (
       <div className="time-range-selector">
         <div className="time-range-presets">
           {PRESETS.map(preset => (
             <button
               key={preset.value}
               className={`time-range-preset ${selectedRange === preset.value ? 'time-range-preset--active' : ''}`}
               onClick={() => handleRangeSelect(preset.value)}
               type="button"
             >
               {preset.label}
             </button>
           ))}
         </div>
         <select
           className="time-range-dropdown"
           value={selectedRange}
           onChange={(e) => handleRangeSelect(e.target.value)}
         >
           {DROPDOWN_OPTIONS.map(opt => (
             <option key={opt.value} value={opt.value}>{opt.label}</option>
           ))}
         </select>
         <label className="time-range-auto-refresh">
           <input
             type="checkbox"
             checked={autoRefresh}
             onChange={(e) => setAutoRefresh(e.target.checked)}
           />
           Auto-refresh (30s)
         </label>
       </div>
     );
   }

   export default TimeRangeSelector;
  </action>
  <verify>
    cd src/dashboard && npm run build
  </verify>
  <done>
    useMetrics hook fetches metrics with auto-refresh, TimeRangeSelector provides preset buttons and dropdown.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create LatencyChart and HistoryTab components</name>
  <files>
    src/dashboard/src/components/LatencyChart.tsx
    src/dashboard/src/components/HistoryTab.tsx
  </files>
  <action>
1. Create src/dashboard/src/components/LatencyChart.tsx with zoom functionality (from RESEARCH.md Pattern 2):

   import { useState, useCallback } from 'react';
   import {
     LineChart, Line, XAxis, YAxis, CartesianGrid,
     Tooltip, Legend, ReferenceArea, ResponsiveContainer
   } from 'recharts';
   import { ChartDataPoint } from '../types/metrics';

   interface LatencyChartProps {
     data: ChartDataPoint[];
     serverIds: string[];
   }

   interface ZoomState {
     left: number | 'dataMin';
     right: number | 'dataMax';
     refAreaLeft: number | null;
     refAreaRight: number | null;
   }

   const COLORS = ['#8884d8', '#82ca9d', '#ffc658', '#ff7300', '#0088fe', '#00C49F', '#FFBB28', '#FF8042'];

   export function LatencyChart({ data, serverIds }: LatencyChartProps) {
     const [zoomState, setZoomState] = useState<ZoomState>({
       left: 'dataMin',
       right: 'dataMax',
       refAreaLeft: null,
       refAreaRight: null
     });

     const handleMouseDown = useCallback((e: any) => {
       if (e?.activeLabel) {
         setZoomState(prev => ({ ...prev, refAreaLeft: e.activeLabel }));
       }
     }, []);

     const handleMouseMove = useCallback((e: any) => {
       if (zoomState.refAreaLeft && e?.activeLabel) {
         setZoomState(prev => ({ ...prev, refAreaRight: e.activeLabel }));
       }
     }, [zoomState.refAreaLeft]);

     const handleMouseUp = useCallback(() => {
       const { refAreaLeft, refAreaRight } = zoomState;

       if (refAreaLeft === refAreaRight || refAreaRight === null) {
         setZoomState(prev => ({ ...prev, refAreaLeft: null, refAreaRight: null }));
         return;
       }

       const [left, right] = refAreaLeft! < refAreaRight
         ? [refAreaLeft, refAreaRight]
         : [refAreaRight, refAreaLeft];

       setZoomState({
         left: left!,
         right: right!,
         refAreaLeft: null,
         refAreaRight: null
       });
     }, [zoomState.refAreaLeft, zoomState.refAreaRight]);

     const handleZoomOut = useCallback(() => {
       setZoomState({
         left: 'dataMin',
         right: 'dataMax',
         refAreaLeft: null,
         refAreaRight: null
       });
     }, []);

     const formatTime = (ts: number) => new Date(ts).toLocaleTimeString();
     const formatDate = (ts: number) => new Date(ts).toLocaleString();

     return (
       <div className="latency-chart">
         <div className="latency-chart-controls">
           <button
             onClick={handleZoomOut}
             disabled={zoomState.left === 'dataMin'}
             className="zoom-reset-btn"
             type="button"
           >
             Reset Zoom
           </button>
           <span className="zoom-hint">Drag to zoom</span>
         </div>
         <ResponsiveContainer width="100%" height={400}>
           <LineChart
             data={data}
             onMouseDown={handleMouseDown}
             onMouseMove={handleMouseMove}
             onMouseUp={handleMouseUp}
           >
             <CartesianGrid strokeDasharray="3 3" />
             <XAxis
               dataKey="timestamp"
               domain={[zoomState.left, zoomState.right]}
               type="number"
               tickFormatter={formatTime}
               scale="time"
             />
             <YAxis domain={['auto', 'auto']} unit="ms" />
             <Tooltip
               labelFormatter={formatDate}
               formatter={(value: number) => [`${value}ms`, 'Latency']}
             />
             <Legend />
             {serverIds.map((serverId, index) => (
               <Line
                 key={serverId}
                 type="monotone"
                 dataKey={serverId}
                 stroke={COLORS[index % COLORS.length]}
                 dot={false}
                 name={serverId}
                 connectNulls
               />
             ))}
             {zoomState.refAreaLeft !== null && zoomState.refAreaRight !== null && (
               <ReferenceArea
                 x1={zoomState.refAreaLeft}
                 x2={zoomState.refAreaRight}
                 strokeOpacity={0.3}
                 fill="#8884d8"
                 fillOpacity={0.3}
               />
             )}
           </LineChart>
         </ResponsiveContainer>
       </div>
     );
   }

   export default LatencyChart;

2. Create src/dashboard/src/components/HistoryTab.tsx:

   import { useState, useMemo } from 'react';
   import TimeRangeSelector from './TimeRangeSelector';
   import LatencyChart from './LatencyChart';
   import { useMetrics } from '../hooks/useMetrics';
   import { HealthSampleDto, ChartDataPoint } from '../types/metrics';

   interface HistoryTabProps {
     apiBaseUrl: string;
     initialServerId?: string;
   }

   export function HistoryTab({ apiBaseUrl, initialServerId }: HistoryTabProps) {
     // Default to last 24 hours
     const [timeRange, setTimeRange] = useState(() => {
       const end = new Date();
       const start = new Date();
       start.setHours(start.getHours() - 24);
       return { startTime: start, endTime: end };
     });

     const [selectedServer, setSelectedServer] = useState<string | undefined>(initialServerId);
     const [autoRefresh, setAutoRefresh] = useState(false);

     // Determine resolution based on time range
     const rangeHours = (timeRange.endTime.getTime() - timeRange.startTime.getTime()) / (1000 * 60 * 60);
     const resolution = rangeHours > 24 ? 'hourly' : 'raw';

     const { data, isLoading, error, refresh } = useMetrics({
       apiBaseUrl,
       serverId: selectedServer,
       startTime: timeRange.startTime,
       endTime: timeRange.endTime,
       resolution,
       autoRefresh,
       refreshInterval: 30000
     });

     // Transform data for Recharts
     const chartData = useMemo<ChartDataPoint[]>(() => {
       if (!data) return [];

       if ('samples' in data) {
         // Raw samples
         const byTimestamp = new Map<number, ChartDataPoint>();

         for (const sample of data.samples as HealthSampleDto[]) {
           const ts = new Date(sample.timestamp).getTime();
           if (!byTimestamp.has(ts)) {
             byTimestamp.set(ts, { timestamp: ts });
           }
           byTimestamp.get(ts)![sample.serverId] = sample.latencyMs ?? undefined;
         }

         return Array.from(byTimestamp.values()).sort((a, b) => a.timestamp - b.timestamp);
       } else {
         // Hourly data
         const byTimestamp = new Map<number, ChartDataPoint>();

         for (const hourly of data.hourly) {
           const ts = new Date(hourly.hourStart).getTime();
           if (!byTimestamp.has(ts)) {
             byTimestamp.set(ts, { timestamp: ts });
           }
           byTimestamp.get(ts)![hourly.serverId] = hourly.avgLatencyMs ?? undefined;
         }

         return Array.from(byTimestamp.values()).sort((a, b) => a.timestamp - b.timestamp);
       }
     }, [data]);

     // Get unique server IDs from data
     const serverIds = useMemo(() => {
       if (!data) return [];

       const ids = new Set<string>();
       if ('samples' in data) {
         for (const sample of data.samples) {
           ids.add(sample.serverId);
         }
       } else {
         for (const hourly of data.hourly) {
           ids.add(hourly.serverId);
         }
       }
       return Array.from(ids).sort();
     }, [data]);

     const handleRangeChange = (startTime: Date, endTime: Date) => {
       setTimeRange({ startTime, endTime });
     };

     return (
       <div className="history-tab">
         <div className="history-tab-header">
           <h2>Historical Metrics</h2>
           <TimeRangeSelector onRangeChange={handleRangeChange} defaultRange="24h" />
         </div>

         <div className="history-tab-filters">
           <label>
             Server:
             <select
               value={selectedServer || ''}
               onChange={(e) => setSelectedServer(e.target.value || undefined)}
             >
               <option value="">All Servers</option>
               {serverIds.map(id => (
                 <option key={id} value={id}>{id}</option>
               ))}
             </select>
           </label>
           <span className="resolution-badge">
             Resolution: {resolution === 'raw' ? 'Raw (5s)' : 'Hourly'}
           </span>
           <button onClick={refresh} disabled={isLoading} type="button">
             Refresh
           </button>
         </div>

         {error && (
           <div className="history-tab-error">
             Error loading metrics: {error}
           </div>
         )}

         {isLoading && !data && (
           <div className="history-tab-loading">Loading metrics...</div>
         )}

         {data && chartData.length > 0 && (
           <LatencyChart data={chartData} serverIds={serverIds} />
         )}

         {data && chartData.length === 0 && (
           <div className="history-tab-empty">
             No metrics data for the selected time range.
           </div>
         )}

         <div className="history-tab-stats">
           {data && 'samples' in data && (
             <span>{data.totalCount} samples loaded</span>
           )}
           {data && 'hourly' in data && (
             <span>{data.totalCount} hourly records loaded</span>
           )}
         </div>
       </div>
     );
   }

   export default HistoryTab;
  </action>
  <verify>
    cd src/dashboard && npm run build
  </verify>
  <done>
    LatencyChart with click-drag zoom, HistoryTab with time range selection and server filtering.
  </done>
</task>

</tasks>

<verification>
1. npm run build in src/dashboard compiles without TypeScript errors
2. LatencyChart uses ReferenceArea for zoom selection
3. HistoryTab automatically switches between raw and hourly resolution
4. TimeRangeSelector has preset buttons and dropdown
5. Types in metrics.ts match backend DTOs
</verification>

<success_criteria>
- Recharts, date-fns, react-sparklines installed
- TypeScript types created for all metrics API responses
- useMetrics hook fetches data with auto-refresh support
- TimeRangeSelector provides quick presets and granular dropdown
- LatencyChart supports click-and-drag zoom with reset button
- HistoryTab displays latency trends with server filtering
</success_criteria>

<output>
After completion, create `.planning/phases/09-historical-metrics-storage/09-04-SUMMARY.md`
</output>
