---
phase: 09-historical-metrics-storage
plan: 03
type: execute
wave: 2
depends_on: ["09-01"]
files_modified:
  - src/FileSimulator.ControlApi/Controllers/MetricsController.cs
  - src/FileSimulator.ControlApi/Models/MetricsQueryParams.cs
  - src/FileSimulator.ControlApi/Models/MetricsResponse.cs
  - src/FileSimulator.ControlApi/Hubs/MetricsHub.cs
  - src/FileSimulator.ControlApi/Program.cs
autonomous: true

must_haves:
  truths:
    - "User can query metrics for specific time ranges via REST API"
    - "API returns raw samples or hourly rollups based on time range"
    - "SignalR streams new samples to connected dashboards in real-time"
  artifacts:
    - path: "src/FileSimulator.ControlApi/Controllers/MetricsController.cs"
      provides: "REST endpoints for metrics queries"
      exports: ["GET /api/metrics/samples", "GET /api/metrics/hourly"]
    - path: "src/FileSimulator.ControlApi/Hubs/MetricsHub.cs"
      provides: "SignalR hub for real-time metrics streaming"
      contains: "MetricsSample"
    - path: "src/FileSimulator.ControlApi/Models/MetricsResponse.cs"
      provides: "DTO for metrics API responses"
      contains: "HealthSampleDto"
  key_links:
    - from: "MetricsController"
      to: "IMetricsService"
      via: "QuerySamplesAsync/QueryHourlyAsync"
      pattern: "QuerySamplesAsync|QueryHourlyAsync"
    - from: "ServerStatusBroadcaster"
      to: "MetricsHub"
      via: "SignalR broadcast after sample recording"
      pattern: "SendAsync.*MetricsSample"
---

<objective>
Create REST API endpoints for querying historical metrics and SignalR hub for streaming real-time samples to dashboard.

Purpose: Enable dashboard to fetch historical data and receive live updates.
Output: Working /api/metrics/* endpoints and /hubs/metrics SignalR hub.
</objective>

<execution_context>
@C:\Users\UserC\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\UserC\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/09-historical-metrics-storage/09-CONTEXT.md
@.planning/phases/09-historical-metrics-storage/09-RESEARCH.md
@src/FileSimulator.ControlApi/Program.cs
@src/FileSimulator.ControlApi/Services/IMetricsService.cs
@src/FileSimulator.ControlApi/Hubs/ServerStatusHub.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create metrics DTOs and query parameters</name>
  <files>
    src/FileSimulator.ControlApi/Models/MetricsQueryParams.cs
    src/FileSimulator.ControlApi/Models/MetricsResponse.cs
  </files>
  <action>
1. Create MetricsQueryParams.cs - query parameter model:

   public class MetricsQueryParams
   {
       /// <summary>Filter by specific server (optional)</summary>
       public string? ServerId { get; set; }

       /// <summary>Filter by protocol type (optional)</summary>
       public string? ServerType { get; set; }

       /// <summary>Start of time range (ISO 8601, required)</summary>
       public DateTime StartTime { get; set; }

       /// <summary>End of time range (ISO 8601, required)</summary>
       public DateTime EndTime { get; set; }
   }

2. Create MetricsResponse.cs with DTOs:

   public class HealthSampleDto
   {
       public int Id { get; set; }
       public DateTime Timestamp { get; set; }
       public string ServerId { get; set; } = default!;
       public string ServerType { get; set; } = default!;
       public bool IsHealthy { get; set; }
       public double? LatencyMs { get; set; }
   }

   public class HealthHourlyDto
   {
       public int Id { get; set; }
       public DateTime HourStart { get; set; }
       public string ServerId { get; set; } = default!;
       public string ServerType { get; set; } = default!;
       public int SampleCount { get; set; }
       public int HealthyCount { get; set; }
       public double? AvgLatencyMs { get; set; }
       public double? MinLatencyMs { get; set; }
       public double? MaxLatencyMs { get; set; }
       public double? P95LatencyMs { get; set; }

       /// <summary>Uptime percentage (0-100)</summary>
       public double UptimePercent => SampleCount > 0
           ? Math.Round((double)HealthyCount / SampleCount * 100, 1)
           : 0;
   }

   public class MetricsSamplesResponse
   {
       public IReadOnlyList<HealthSampleDto> Samples { get; set; } = Array.Empty<HealthSampleDto>();
       public int TotalCount { get; set; }
       public DateTime QueryStart { get; set; }
       public DateTime QueryEnd { get; set; }
   }

   public class MetricsHourlyResponse
   {
       public IReadOnlyList<HealthHourlyDto> Hourly { get; set; } = Array.Empty<HealthHourlyDto>();
       public int TotalCount { get; set; }
       public DateTime QueryStart { get; set; }
       public DateTime QueryEnd { get; set; }
   }
  </action>
  <verify>
    dotnet build src/FileSimulator.ControlApi
  </verify>
  <done>
    DTOs created for API request/response with proper typing.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create MetricsController with query endpoints</name>
  <files>
    src/FileSimulator.ControlApi/Controllers/MetricsController.cs
  </files>
  <action>
Create MetricsController.cs with REST endpoints:

[ApiController]
[Route("api/metrics")]
public class MetricsController : ControllerBase
{
    private readonly IMetricsService _metricsService;
    private readonly ILogger<MetricsController> _logger;

    public MetricsController(IMetricsService metricsService, ILogger<MetricsController> logger)
    {
        _metricsService = metricsService;
        _logger = logger;
    }

    /// <summary>
    /// Get raw samples for a time range.
    /// Best for ranges under 24 hours.
    /// </summary>
    [HttpGet("samples")]
    public async Task<ActionResult<MetricsSamplesResponse>> GetSamples(
        [FromQuery] MetricsQueryParams query,
        CancellationToken ct)
    {
        // Validate time range
        if (query.EndTime <= query.StartTime)
        {
            return BadRequest("EndTime must be after StartTime");
        }

        // Limit raw sample queries to reasonable ranges
        var range = query.EndTime - query.StartTime;
        if (range > TimeSpan.FromDays(7))
        {
            return BadRequest("Raw sample queries limited to 7 days. Use hourly endpoint for longer ranges.");
        }

        var samples = await _metricsService.QuerySamplesAsync(
            query.ServerId,
            query.StartTime.ToUniversalTime(),
            query.EndTime.ToUniversalTime(),
            ct);

        // Apply ServerType filter if provided
        if (!string.IsNullOrEmpty(query.ServerType))
        {
            samples = samples.Where(s => s.ServerType.Equals(query.ServerType, StringComparison.OrdinalIgnoreCase)).ToList();
        }

        var dtos = samples.Select(s => new HealthSampleDto
        {
            Id = s.Id,
            Timestamp = s.Timestamp,
            ServerId = s.ServerId,
            ServerType = s.ServerType,
            IsHealthy = s.IsHealthy,
            LatencyMs = s.LatencyMs
        }).ToList();

        return Ok(new MetricsSamplesResponse
        {
            Samples = dtos,
            TotalCount = dtos.Count,
            QueryStart = query.StartTime,
            QueryEnd = query.EndTime
        });
    }

    /// <summary>
    /// Get hourly aggregations for a time range.
    /// Best for ranges over 24 hours.
    /// </summary>
    [HttpGet("hourly")]
    public async Task<ActionResult<MetricsHourlyResponse>> GetHourly(
        [FromQuery] MetricsQueryParams query,
        CancellationToken ct)
    {
        if (query.EndTime <= query.StartTime)
        {
            return BadRequest("EndTime must be after StartTime");
        }

        var hourly = await _metricsService.QueryHourlyAsync(
            query.ServerId,
            query.StartTime.ToUniversalTime(),
            query.EndTime.ToUniversalTime(),
            ct);

        if (!string.IsNullOrEmpty(query.ServerType))
        {
            hourly = hourly.Where(h => h.ServerType.Equals(query.ServerType, StringComparison.OrdinalIgnoreCase)).ToList();
        }

        var dtos = hourly.Select(h => new HealthHourlyDto
        {
            Id = h.Id,
            HourStart = h.HourStart,
            ServerId = h.ServerId,
            ServerType = h.ServerType,
            SampleCount = h.SampleCount,
            HealthyCount = h.HealthyCount,
            AvgLatencyMs = h.AvgLatencyMs,
            MinLatencyMs = h.MinLatencyMs,
            MaxLatencyMs = h.MaxLatencyMs,
            P95LatencyMs = h.P95LatencyMs
        }).ToList();

        return Ok(new MetricsHourlyResponse
        {
            Hourly = dtos,
            TotalCount = dtos.Count,
            QueryStart = query.StartTime,
            QueryEnd = query.EndTime
        });
    }

    /// <summary>
    /// Get server list with available metrics date range.
    /// </summary>
    [HttpGet("servers")]
    public async Task<ActionResult> GetServersWithMetrics(CancellationToken ct)
    {
        // Query distinct servers from samples
        var factory = HttpContext.RequestServices.GetRequiredService<IDbContextFactory<MetricsDbContext>>();
        await using var context = await factory.CreateDbContextAsync(ct);

        var servers = await context.HealthSamples
            .GroupBy(s => new { s.ServerId, s.ServerType })
            .Select(g => new
            {
                g.Key.ServerId,
                g.Key.ServerType,
                FirstSample = g.Min(s => s.Timestamp),
                LastSample = g.Max(s => s.Timestamp),
                TotalSamples = g.Count()
            })
            .ToListAsync(ct);

        return Ok(servers);
    }
}

Note: Add required using statements at top:
using Microsoft.AspNetCore.Mvc;
using Microsoft.EntityFrameworkCore;
using FileSimulator.ControlApi.Models;
using FileSimulator.ControlApi.Services;
using FileSimulator.ControlApi.Data;
  </action>
  <verify>
    dotnet build src/FileSimulator.ControlApi
  </verify>
  <done>
    MetricsController with /api/metrics/samples, /api/metrics/hourly, and /api/metrics/servers endpoints.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create MetricsHub for real-time streaming and update Program.cs</name>
  <files>
    src/FileSimulator.ControlApi/Hubs/MetricsHub.cs
    src/FileSimulator.ControlApi/Services/ServerStatusBroadcaster.cs
    src/FileSimulator.ControlApi/Program.cs
  </files>
  <action>
1. Create MetricsHub.cs:

   using Microsoft.AspNetCore.SignalR;

   namespace FileSimulator.ControlApi.Hubs;

   /// <summary>
   /// SignalR hub for streaming real-time metrics samples to dashboard.
   /// Broadcasts new samples as they are recorded.
   /// </summary>
   public class MetricsHub : Hub
   {
       private readonly ILogger<MetricsHub> _logger;

       public MetricsHub(ILogger<MetricsHub> logger)
       {
           _logger = logger;
       }

       public override async Task OnConnectedAsync()
       {
           _logger.LogInformation("Metrics client connected: {ConnectionId}", Context.ConnectionId);
           await base.OnConnectedAsync();
       }

       public override async Task OnDisconnectedAsync(Exception? exception)
       {
           _logger.LogInformation("Metrics client disconnected: {ConnectionId}", Context.ConnectionId);
           await base.OnDisconnectedAsync(exception);
       }
   }

2. Update ServerStatusBroadcaster to broadcast samples to MetricsHub:

   - Inject IHubContext<MetricsHub> _metricsHubContext
   - After recording samples, broadcast to metrics hub:

   // In BroadcastStatusAsync, after recording samples:
   await _metricsHubContext.Clients.All.SendAsync(
       "MetricsSample",
       new
       {
           timestamp = DateTime.UtcNow,
           samples = statuses.Select(s => new
           {
               serverId = s.Name,
               serverType = s.Protocol,
               isHealthy = s.IsHealthy,
               latencyMs = s.IsHealthy ? s.LatencyMs : (int?)null
           })
       },
       ct);

3. Update Program.cs:
   - Add hub mapping: app.MapHub<MetricsHub>("/hubs/metrics");
   - Update the API root endpoint to include /hubs/metrics and /api/metrics/* endpoints

4. Verify ServerStatusBroadcaster constructor now injects:
   - IHubContext<ServerStatusHub> (existing)
   - IHubContext<MetricsHub> (new)
   - IKubernetesDiscoveryService
   - IHealthCheckService
   - IDbContextFactory<MetricsDbContext> (from 09-02)
   - ILogger<ServerStatusBroadcaster>
  </action>
  <verify>
    dotnet build src/FileSimulator.ControlApi
  </verify>
  <done>
    MetricsHub created and mapped, ServerStatusBroadcaster streams samples to connected dashboards.
  </done>
</task>

</tasks>

<verification>
1. dotnet build src/FileSimulator.ControlApi compiles without errors
2. MetricsController has three endpoints: samples, hourly, servers
3. MetricsHub mapped at /hubs/metrics
4. ServerStatusBroadcaster broadcasts to MetricsHub after each health check cycle
5. Program.cs updated with hub mapping and endpoint list
</verification>

<success_criteria>
- GET /api/metrics/samples returns raw samples for time range
- GET /api/metrics/hourly returns hourly aggregations
- GET /api/metrics/servers returns list of servers with metrics date range
- /hubs/metrics SignalR hub streams new samples in real-time
- Time range validation rejects invalid queries
</success_criteria>

<output>
After completion, create `.planning/phases/09-historical-metrics-storage/09-03-SUMMARY.md`
</output>
