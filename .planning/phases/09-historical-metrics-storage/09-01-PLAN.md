---
phase: 09-historical-metrics-storage
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/FileSimulator.ControlApi/FileSimulator.ControlApi.csproj
  - src/FileSimulator.ControlApi/Data/MetricsDbContext.cs
  - src/FileSimulator.ControlApi/Data/Entities/HealthSample.cs
  - src/FileSimulator.ControlApi/Data/Entities/HealthHourly.cs
  - src/FileSimulator.ControlApi/Services/IMetricsService.cs
  - src/FileSimulator.ControlApi/Services/MetricsService.cs
autonomous: true

must_haves:
  truths:
    - "EF Core 9 with SQLite provider is installed and configured"
    - "MetricsDbContext can create the SQLite database at startup"
    - "HealthSample and HealthHourly entities have proper indexes for time-range queries"
  artifacts:
    - path: "src/FileSimulator.ControlApi/Data/MetricsDbContext.cs"
      provides: "DbContext with entity configuration and indexes"
      contains: "HasIndex"
    - path: "src/FileSimulator.ControlApi/Data/Entities/HealthSample.cs"
      provides: "Raw sample entity with DateTime timestamp"
      contains: "Timestamp"
    - path: "src/FileSimulator.ControlApi/Data/Entities/HealthHourly.cs"
      provides: "Hourly rollup entity with aggregated stats"
      contains: "P95LatencyMs"
    - path: "src/FileSimulator.ControlApi/Services/MetricsService.cs"
      provides: "Metrics query and persistence operations"
      exports: ["RecordSampleAsync", "QuerySamplesAsync", "QueryHourlyAsync"]
  key_links:
    - from: "src/FileSimulator.ControlApi/Program.cs"
      to: "MetricsDbContext"
      via: "AddDbContextFactory"
      pattern: "AddDbContextFactory.*MetricsDbContext"
---

<objective>
Create the EF Core 9 SQLite data layer for metrics persistence with HealthSample and HealthHourly entities, proper indexes, and MetricsService for queries.

Purpose: Foundation for all metrics storage - background services and API endpoints depend on these entities and service.
Output: Working DbContext, entities, and MetricsService registered in DI container.
</objective>

<execution_context>
@C:\Users\UserC\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\UserC\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/09-historical-metrics-storage/09-CONTEXT.md
@.planning/phases/09-historical-metrics-storage/09-RESEARCH.md
@src/FileSimulator.ControlApi/Program.cs
@src/FileSimulator.ControlApi/FileSimulator.ControlApi.csproj
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add EF Core SQLite packages and create entities</name>
  <files>
    src/FileSimulator.ControlApi/FileSimulator.ControlApi.csproj
    src/FileSimulator.ControlApi/Data/Entities/HealthSample.cs
    src/FileSimulator.ControlApi/Data/Entities/HealthHourly.cs
  </files>
  <action>
1. Add NuGet packages to FileSimulator.ControlApi.csproj:
   - Microsoft.EntityFrameworkCore.Sqlite Version="9.0.0"
   - Microsoft.EntityFrameworkCore.Design Version="9.0.0" (for migrations tooling)

2. Create HealthSample entity in Data/Entities/HealthSample.cs:
   - int Id (primary key)
   - DateTime Timestamp (UTC, not DateTimeOffset - SQLite limitation)
   - string ServerId (e.g., "nas-input-1", "ftp")
   - string ServerType (e.g., "NAS", "FTP", "SFTP")
   - bool IsHealthy
   - double? LatencyMs (nullable for unhealthy samples)

3. Create HealthHourly entity in Data/Entities/HealthHourly.cs:
   - int Id (primary key)
   - DateTime HourStart (UTC, truncated to hour)
   - string ServerId
   - string ServerType
   - int SampleCount
   - int HealthyCount
   - double? AvgLatencyMs
   - double? MinLatencyMs
   - double? MaxLatencyMs
   - double? P95LatencyMs

IMPORTANT: Use DateTime not DateTimeOffset - SQLite cannot order/compare DateTimeOffset columns.
  </action>
  <verify>
    dotnet build src/FileSimulator.ControlApi
  </verify>
  <done>
    Both entity classes exist with all required properties, project compiles with EF Core packages installed.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create MetricsDbContext with entity configuration</name>
  <files>
    src/FileSimulator.ControlApi/Data/MetricsDbContext.cs
  </files>
  <action>
Create MetricsDbContext.cs in Data folder:

1. Inherit from DbContext, constructor accepts DbContextOptions<MetricsDbContext>

2. Define DbSets:
   - DbSet<HealthSample> HealthSamples
   - DbSet<HealthHourly> HealthHourly

3. Override OnModelCreating with Fluent API configuration:

   For HealthSample:
   - Table name: "health_samples"
   - Property Timestamp: column "timestamp", required
   - Property ServerId: column "server_id", required, max length 50
   - Property ServerType: column "server_type", required, max length 10
   - Property IsHealthy: column "is_healthy", required
   - Property LatencyMs: column "latency_ms"
   - Composite index on (ServerId, Timestamp) named "ix_health_samples_server_timestamp"
   - Simple index on Timestamp named "ix_health_samples_timestamp" (for retention cleanup)

   For HealthHourly:
   - Table name: "health_hourly"
   - Property HourStart: column "hour_start", required
   - Property ServerId: column "server_id", required, max length 50
   - Property ServerType: column "server_type", required, max length 10
   - Composite index on (ServerId, HourStart) named "ix_health_hourly_server_hour"

Follow pattern from RESEARCH.md Pattern 4.
  </action>
  <verify>
    dotnet build src/FileSimulator.ControlApi
  </verify>
  <done>
    MetricsDbContext exists with proper table names, column names, and indexes configured via Fluent API.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create MetricsService and register in DI</name>
  <files>
    src/FileSimulator.ControlApi/Services/IMetricsService.cs
    src/FileSimulator.ControlApi/Services/MetricsService.cs
    src/FileSimulator.ControlApi/Program.cs
  </files>
  <action>
1. Create IMetricsService interface with methods:
   - Task RecordSampleAsync(string serverId, string serverType, bool isHealthy, double? latencyMs, CancellationToken ct)
   - Task<IReadOnlyList<HealthSample>> QuerySamplesAsync(string? serverId, DateTime startTime, DateTime endTime, CancellationToken ct)
   - Task<IReadOnlyList<HealthHourly>> QueryHourlyAsync(string? serverId, DateTime startTime, DateTime endTime, CancellationToken ct)

2. Create MetricsService implementation:
   - Inject IDbContextFactory<MetricsDbContext> (NOT direct DbContext - for background service compatibility)
   - RecordSampleAsync: Creates sample with DateTime.UtcNow, saves to database
   - QuerySamplesAsync: Filters by server (optional) and time range, orders by Timestamp descending
   - QueryHourlyAsync: Filters by server (optional) and time range, orders by HourStart descending

3. Update Program.cs:
   - Add DbContextFactory registration:
     builder.Services.AddDbContextFactory<MetricsDbContext>(options =>
         options.UseSqlite("Data Source=/mnt/control-data/metrics.db"));
   - Register MetricsService as scoped:
     builder.Services.AddScoped<IMetricsService, MetricsService>();
   - Add EnsureCreated call on startup (after app.Build(), before app.Run()):
     using (var scope = app.Services.CreateScope())
     {
         var factory = scope.ServiceProvider.GetRequiredService<IDbContextFactory<MetricsDbContext>>();
         using var context = factory.CreateDbContext();
         context.Database.EnsureCreated();
     }

IMPORTANT: Use IDbContextFactory pattern - MetricsService will be used by background services where scoped DbContext causes lifetime issues.
  </action>
  <verify>
    dotnet build src/FileSimulator.ControlApi
  </verify>
  <done>
    MetricsService registered with IDbContextFactory, Program.cs ensures database creation on startup.
  </done>
</task>

</tasks>

<verification>
1. dotnet build src/FileSimulator.ControlApi compiles without errors
2. Entity classes have DateTime (not DateTimeOffset) for timestamp properties
3. MetricsDbContext has proper indexes defined in OnModelCreating
4. Program.cs registers DbContextFactory and calls EnsureCreated on startup
</verification>

<success_criteria>
- EF Core 9 SQLite packages installed
- HealthSample and HealthHourly entities created with proper column mappings
- MetricsDbContext configured with composite indexes for time-range queries
- MetricsService interface and implementation registered in DI
- Database auto-creates on startup with EnsureCreated
</success_criteria>

<output>
After completion, create `.planning/phases/09-historical-metrics-storage/09-01-SUMMARY.md`
</output>
