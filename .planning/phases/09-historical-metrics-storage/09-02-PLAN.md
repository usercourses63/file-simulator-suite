---
phase: 09-historical-metrics-storage
plan: 02
type: execute
wave: 2
depends_on: ["09-01"]
files_modified:
  - src/FileSimulator.ControlApi/Services/MetricsRecordingService.cs
  - src/FileSimulator.ControlApi/Services/RollupGenerationService.cs
  - src/FileSimulator.ControlApi/Services/RetentionCleanupService.cs
  - src/FileSimulator.ControlApi/Program.cs
  - helm-chart/file-simulator/templates/control-api.yaml
  - helm-chart/file-simulator/values.yaml
autonomous: true

must_haves:
  truths:
    - "Health samples are recorded to SQLite every 5 seconds when health checks run"
    - "Hourly rollups are generated from raw samples with P95 calculation"
    - "Data older than 7 days is automatically purged"
    - "Database survives pod restarts via PVC"
  artifacts:
    - path: "src/FileSimulator.ControlApi/Services/MetricsRecordingService.cs"
      provides: "Captures health check results into MetricsService"
      contains: "RecordSampleAsync"
    - path: "src/FileSimulator.ControlApi/Services/RollupGenerationService.cs"
      provides: "Generates hourly aggregations with P95"
      contains: "CalculatePercentile"
    - path: "src/FileSimulator.ControlApi/Services/RetentionCleanupService.cs"
      provides: "Deletes data older than 7 days"
      contains: "ExecuteDeleteAsync"
    - path: "helm-chart/file-simulator/templates/control-api.yaml"
      provides: "PVC mount for metrics database"
      contains: "control-data"
  key_links:
    - from: "src/FileSimulator.ControlApi/Services/ServerStatusBroadcaster.cs"
      to: "MetricsRecordingService"
      via: "Broadcast captures samples"
      pattern: "RecordSample"
---

<objective>
Create background services for metrics recording, hourly rollup generation, and 7-day retention cleanup. Update Helm chart to persist database via PVC.

Purpose: Enable continuous metrics collection with automatic aggregation and cleanup.
Output: Three background services running in ControlApi, database persisted across pod restarts.
</objective>

<execution_context>
@C:\Users\UserC\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\UserC\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/09-historical-metrics-storage/09-CONTEXT.md
@.planning/phases/09-historical-metrics-storage/09-RESEARCH.md
@src/FileSimulator.ControlApi/Services/ServerStatusBroadcaster.cs
@src/FileSimulator.ControlApi/Services/HealthCheckService.cs
@helm-chart/file-simulator/templates/control-api.yaml
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create MetricsRecordingService that captures health check results</name>
  <files>
    src/FileSimulator.ControlApi/Services/MetricsRecordingService.cs
    src/FileSimulator.ControlApi/Services/ServerStatusBroadcaster.cs
    src/FileSimulator.ControlApi/Program.cs
  </files>
  <action>
1. Create MetricsRecordingService as a thin wrapper that integrates with ServerStatusBroadcaster:

Option A (recommended): Modify ServerStatusBroadcaster to record metrics after each health check cycle.

In ServerStatusBroadcaster:
- Inject IDbContextFactory<MetricsDbContext> (add to constructor)
- After BroadcastStatusAsync completes successfully, record each server's status:

  foreach (var status in statuses)
  {
      await RecordMetricAsync(status, ct);
  }

  private async Task RecordMetricAsync(ServerStatus status, CancellationToken ct)
  {
      try
      {
          await using var context = await _contextFactory.CreateDbContextAsync(ct);

          var sample = new HealthSample
          {
              Timestamp = DateTime.UtcNow,
              ServerId = status.Name,
              ServerType = status.Protocol,
              IsHealthy = status.IsHealthy,
              LatencyMs = status.IsHealthy ? status.LatencyMs : null
          };

          context.HealthSamples.Add(sample);
          await context.SaveChangesAsync(ct);
      }
      catch (Exception ex)
      {
          _logger.LogWarning(ex, "Failed to record metric for {Server}", status.Name);
      }
  }

2. Update ServerStatusBroadcaster constructor to accept IDbContextFactory<MetricsDbContext>

3. Ensure Program.cs has the DbContextFactory registered (done in 09-01)

CRITICAL: Use IDbContextFactory, NOT direct DbContext injection - BackgroundService is singleton, DbContext is scoped.
  </action>
  <verify>
    dotnet build src/FileSimulator.ControlApi
  </verify>
  <done>
    ServerStatusBroadcaster records health samples to SQLite database after each 5-second health check cycle.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create RollupGenerationService and RetentionCleanupService</name>
  <files>
    src/FileSimulator.ControlApi/Services/RollupGenerationService.cs
    src/FileSimulator.ControlApi/Services/RetentionCleanupService.cs
    src/FileSimulator.ControlApi/Program.cs
  </files>
  <action>
1. Create RollupGenerationService (BackgroundService):
   - Inject IDbContextFactory<MetricsDbContext> and ILogger
   - Run every hour (TimeSpan.FromHours(1) interval)
   - On each tick, generate rollup for the PREVIOUS completed hour
   - P95 calculation method (from RESEARCH.md Pattern 5):

     private static double? CalculatePercentile(List<double> sortedValues, double percentile)
     {
         if (sortedValues.Count == 0) return null;
         if (sortedValues.Count == 1) return sortedValues[0];

         double index = (percentile / 100.0) * (sortedValues.Count - 1);
         int lower = (int)Math.Floor(index);
         int upper = (int)Math.Ceiling(index);

         if (lower == upper) return sortedValues[lower];

         double fraction = index - lower;
         return sortedValues[lower] + (sortedValues[upper] - sortedValues[lower]) * fraction;
     }

   - GenerateRollupForHour method:
     a. Calculate hourStart (previous completed hour)
     b. Query raw samples for that hour grouped by ServerId/ServerType
     c. For each group, create HealthHourly with:
        - SampleCount, HealthyCount
        - Avg/Min/Max/P95 latency (from valid latency values only)
     d. Check if rollup already exists (prevent duplicates) - skip if exists
     e. Save rollups

   - Initial delay: 5 minutes (let system stabilize)

2. Create RetentionCleanupService (BackgroundService):
   - Inject IDbContextFactory<MetricsDbContext> and ILogger
   - Run every hour (TimeSpan.FromHours(1) interval)
   - On each tick, delete data older than 7 days:

     var cutoff = DateTime.UtcNow.AddDays(-7);

     var deletedSamples = await context.HealthSamples
         .Where(s => s.Timestamp < cutoff)
         .ExecuteDeleteAsync(ct);

     var deletedRollups = await context.HealthHourly
         .Where(r => r.HourStart < cutoff)
         .ExecuteDeleteAsync(ct);

     _logger.LogInformation("Retention cleanup: {Samples} samples, {Rollups} rollups deleted",
         deletedSamples, deletedRollups);

   - Initial delay: 10 minutes
   - Use ExecuteDeleteAsync for efficient bulk delete (single SQL statement)

3. Register both services in Program.cs:
   builder.Services.AddHostedService<RollupGenerationService>();
   builder.Services.AddHostedService<RetentionCleanupService>();
  </action>
  <verify>
    dotnet build src/FileSimulator.ControlApi
  </verify>
  <done>
    RollupGenerationService creates hourly aggregations with P95, RetentionCleanupService purges 7-day-old data.
  </done>
</task>

<task type="auto">
  <name>Task 3: Update Helm chart to persist metrics database via PVC</name>
  <files>
    helm-chart/file-simulator/templates/control-api.yaml
    helm-chart/file-simulator/values.yaml
  </files>
  <action>
1. Update values.yaml - add controlApi.persistence section:

   controlApi:
     # ... existing config ...
     persistence:
       enabled: true
       # Use hostPath for Minikube (same as simulator-data pattern)
       hostPath: /mnt/control-data
       mountPath: /mnt/control-data

2. Update control-api.yaml template:

   Add volume mount to container:
   volumeMounts:
     - name: simulator-data
       mountPath: /mnt/simulator-data
     - name: control-data
       mountPath: /mnt/control-data

   Add volume definition:
   volumes:
     - name: simulator-data
       hostPath:
         path: {{ .Values.global.storage.hostPath }}
         type: DirectoryOrCreate
     - name: control-data
       hostPath:
         path: {{ .Values.controlApi.persistence.hostPath | default "/mnt/control-data" }}
         type: DirectoryOrCreate

3. The SQLite database path in Program.cs should be:
   "Data Source=/mnt/control-data/metrics.db"

   This path is already set in 09-01 Plan, just ensure consistency.

NOTE: Using hostPath for simplicity in Minikube. In production, this would be a PVC with a proper storage class. The hostPath approach mirrors how simulator-data is mounted.
  </action>
  <verify>
    helm template file-sim ./helm-chart/file-simulator --debug | Select-String "control-data" -Context 2,2
  </verify>
  <done>
    Helm chart mounts /mnt/control-data directory, SQLite database persists across pod restarts.
  </done>
</task>

</tasks>

<verification>
1. dotnet build src/FileSimulator.ControlApi compiles without errors
2. ServerStatusBroadcaster records samples using IDbContextFactory pattern
3. RollupGenerationService has P95 calculation logic
4. RetentionCleanupService uses ExecuteDeleteAsync for bulk deletes
5. Helm template shows control-data volume mount
</verification>

<success_criteria>
- Health samples recorded to database every 5 seconds
- Hourly rollups generated with SampleCount, HealthyCount, Avg/Min/Max/P95 latency
- Retention cleanup removes data older than 7 days
- Helm chart mounts persistent storage for metrics.db
- All services use IDbContextFactory pattern (not direct DbContext)
</success_criteria>

<output>
After completion, create `.planning/phases/09-historical-metrics-storage/09-02-SUMMARY.md`
</output>
