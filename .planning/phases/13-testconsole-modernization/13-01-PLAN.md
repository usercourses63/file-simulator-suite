# Plan 13-01: TestConsole API-driven configuration using /api/connection-info

---
wave: 1
depends_on: []
files_modified:
  - src/FileSimulator.TestConsole/ApiConfigurationProvider.cs (new)
  - src/FileSimulator.TestConsole/Models/ConnectionInfo.cs (new)
  - src/FileSimulator.TestConsole/Models/TestConfiguration.cs (new)
  - src/FileSimulator.TestConsole/Program.cs
  - src/FileSimulator.TestConsole/FileSimulator.TestConsole.csproj
  - src/FileSimulator.TestConsole/appsettings.json
autonomous: true
---

## Objective

Implement API-driven configuration in TestConsole so it fetches server configuration from the Control API's /api/connection-info endpoint instead of relying solely on hardcoded appsettings.json values.

## Context

The TestConsole currently reads all configuration from appsettings.json with hardcoded IPs and ports. This plan modernizes it to dynamically fetch configuration from the Control API, with intelligent fallback to local config when the API is unavailable.

The Control API endpoint /api/connection-info returns:
- Server list with names, protocols, hosts, ports, and status
- Default credentials for each protocol
- Endpoint summary URLs
- Support for multiple output formats (json, env, yaml, dotnet)

## Tasks

<task id="1">
Create the ConnectionInfo model classes to match the API response structure.

Create file: src/FileSimulator.TestConsole/Models/ConnectionInfo.cs

Include records for:
- ConnectionInfoResponse (matches API response exactly)
- ServerConnectionInfo (individual server details)
- DefaultCredentials (per-protocol credentials)
- CredentialInfo (username, password, note)
- EndpointSummary (all endpoint URLs)

Reference: The exact structure is defined in src/FileSimulator.ControlApi/Controllers/ConnectionInfoController.cs lines 337-389.
</task>

<task id="2">
Create the TestConfiguration model class for internal use.

Create file: src/FileSimulator.TestConsole/Models/TestConfiguration.cs

Include:
- ConfigurationSource enum: Api, AppSettings
- TestConfiguration class with Source property and Dictionary<string, ServerConfig> Servers
- ServerConfig class with Name, Host, Port, Username, Password, Type, Status, Protocol, Directory properties
</task>

<task id="3">
Create the ApiConfigurationProvider class.

Create file: src/FileSimulator.TestConsole/ApiConfigurationProvider.cs

Implement:
- Constructor accepting apiBaseUrl and ILogger
- GetConfigurationAsync() method that:
  1. Checks API health at /api/health
  2. Fetches /api/connection-info if healthy
  3. Deserializes to ConnectionInfoResponse
  4. Maps to TestConfiguration
  5. Returns null on failure (with warning logged)
- Private helper methods:
  - FetchFromApiAsync() - HTTP GET with timeout
  - MapToTestConfiguration() - Convert API response to internal model
- Use HttpClient with 10-second timeout
- Use System.Text.Json for deserialization with PropertyNameCaseInsensitive = true
</task>

<task id="4">
Update TestConsole Program.cs to use API-driven configuration.

Modify: src/FileSimulator.TestConsole/Program.cs

Changes:
1. Add command-line flag parsing for --api-url (default: http://localhost:5000)
2. Add command-line flag --require-api to fail if API unavailable
3. Create ApiConfigurationProvider instance
4. Try to fetch configuration from API first
5. Fall back to appsettings.json if API unavailable
6. Display configuration source prominently: "[cyan]Using API-driven configuration[/]" or "[yellow]Using fallback configuration (API unavailable)[/]"
7. Pass the resolved configuration to all test methods

Keep backward compatibility - existing appsettings.json configuration still works when API is down.
</task>

<task id="5">
Update project file to add required packages.

Modify: src/FileSimulator.TestConsole/FileSimulator.TestConsole.csproj

Add package reference:
- Microsoft.Extensions.Http version 9.0.0 (for HttpClient factory patterns if needed)

Note: System.Net.Http.Json is included in .NET 9 runtime, no package needed.
</task>

<task id="6">
Update appsettings.json with Control API configuration.

Modify: src/FileSimulator.TestConsole/appsettings.json

Add section:
```json
"ControlApi": {
  "BaseUrl": "http://file-simulator.local:30500",
  "TimeoutSeconds": 10,
  "RequireApi": false
}
```

This allows configuration of the API URL via config file as well as command line.
</task>

<task id="7">
Add helper method to extract configuration for individual protocols.

Enhance ApiConfigurationProvider or create extension methods to:
- GetFtpConfig() - returns FTP server config or null
- GetSftpConfig() - returns SFTP server config or null
- GetNasServers() - returns list of NAS server configs
- GetDynamicServers() - returns list of dynamic server configs
- Filter by protocol, type, or status
</task>

## Verification

```powershell
# Build TestConsole
cd C:\Users\UserC\source\repos\file-simulator-suite\src\FileSimulator.TestConsole
dotnet build

# Test with API available (requires Control API running)
dotnet run -- --api-url http://localhost:5000

# Test with API unavailable (falls back to appsettings)
dotnet run -- --api-url http://nonexistent:9999

# Test require-api flag (should fail if API unavailable)
dotnet run -- --api-url http://nonexistent:9999 --require-api
# Expected: Error message and exit

# Verify output shows configuration source
# Expected: Either "[cyan]Using API-driven configuration[/]" or "[yellow]Using fallback configuration[/]"
```

## must_haves

These criteria must be TRUE for the plan to be considered complete:

1. ApiConfigurationProvider class exists and can fetch configuration from /api/connection-info
2. TestConfiguration model correctly maps the API response
3. TestConsole displays which configuration source is being used (API vs fallback)
4. TestConsole works when API is unavailable (falls back to appsettings.json)
5. --require-api flag causes failure when API is unavailable
6. All existing tests still pass with appsettings.json fallback
