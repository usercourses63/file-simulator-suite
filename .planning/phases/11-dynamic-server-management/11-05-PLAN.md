---
phase: 11-dynamic-server-management
plan: 05
type: execute
wave: 2
depends_on: ["11-02"]
files_modified:
  - src/FileSimulator.ControlApi/Models/ConfigurationModels.cs
  - src/FileSimulator.ControlApi/Services/ConfigurationExportService.cs
  - src/FileSimulator.ControlApi/Controllers/ConfigurationController.cs
  - src/FileSimulator.ControlApi/Program.cs
autonomous: true

must_haves:
  truths:
    - "Export endpoint returns JSON file with all servers (static and dynamic)"
    - "Import endpoint accepts JSON and creates missing dynamic servers"
    - "Import validates JSON schema before attempting creation"
    - "Credentials included in export (user responsible for security)"
  artifacts:
    - path: "src/FileSimulator.ControlApi/Models/ConfigurationModels.cs"
      provides: "Export/import DTOs for configuration"
      exports: ["ServerConfigurationExport", "ServerConfiguration"]
    - path: "src/FileSimulator.ControlApi/Services/ConfigurationExportService.cs"
      provides: "Export and import logic"
      min_lines: 100
    - path: "src/FileSimulator.ControlApi/Controllers/ConfigurationController.cs"
      provides: "REST endpoints for export/import"
      exports: ["GET /api/configuration/export", "POST /api/configuration/import"]
  key_links:
    - from: "ConfigurationController"
      to: "ConfigurationExportService"
      via: "dependency injection"
      pattern: "IConfigurationExportService"
---

<objective>
Implement configuration export and import functionality for environment replication.

Purpose: Users need to export simulator configuration for backup and replicate test environments across machines. Export includes all servers (static inventory + dynamic state).
Output: Export/import models, service, and controller endpoints.
</objective>

<execution_context>
@C:\Users\UserC\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\UserC\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/11-dynamic-server-management/11-CONTEXT.md
@.planning/phases/11-dynamic-server-management/11-RESEARCH.md

# Prior plans for context
@.planning/phases/11-dynamic-server-management/11-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create configuration models and export service</name>
  <files>
src/FileSimulator.ControlApi/Models/ConfigurationModels.cs
src/FileSimulator.ControlApi/Services/ConfigurationExportService.cs
src/FileSimulator.ControlApi/Program.cs
  </files>
  <action>
1. Create Models/ConfigurationModels.cs:

```csharp
namespace FileSimulator.ControlApi.Models;

using System.Text.Json.Serialization;

/// <summary>
/// Full configuration export including all servers and metadata.
/// </summary>
public record ServerConfigurationExport
{
    /// <summary>Export format version for compatibility.</summary>
    public string Version { get; init; } = "2.0";

    /// <summary>When this export was created.</summary>
    public DateTime ExportedAt { get; init; } = DateTime.UtcNow;

    /// <summary>Source namespace.</summary>
    public required string Namespace { get; init; }

    /// <summary>Helm release prefix used.</summary>
    public required string ReleasePrefix { get; init; }

    /// <summary>All server configurations.</summary>
    public required List<ServerConfiguration> Servers { get; init; }

    /// <summary>Export metadata for auditing.</summary>
    public ExportMetadata? Metadata { get; init; }
}

/// <summary>
/// Individual server configuration for export/import.
/// </summary>
public record ServerConfiguration
{
    public required string Name { get; init; }
    public required string Protocol { get; init; }
    public int? NodePort { get; init; }

    /// <summary>True if dynamically created, false if Helm-deployed.</summary>
    public bool IsDynamic { get; init; }

    /// <summary>FTP-specific settings.</summary>
    public FtpConfiguration? Ftp { get; init; }

    /// <summary>SFTP-specific settings.</summary>
    public SftpConfiguration? Sftp { get; init; }

    /// <summary>NAS-specific settings.</summary>
    public NasConfiguration? Nas { get; init; }
}

public record FtpConfiguration
{
    public required string Username { get; init; }
    public required string Password { get; init; }
    public int? PassivePortStart { get; init; }
    public int? PassivePortEnd { get; init; }
}

public record SftpConfiguration
{
    public required string Username { get; init; }
    public required string Password { get; init; }
    public int Uid { get; init; } = 1000;
    public int Gid { get; init; } = 1000;
}

public record NasConfiguration
{
    public required string Directory { get; init; }
    public string ExportOptions { get; init; } = "rw,sync,no_subtree_check,no_root_squash";
}

public record ExportMetadata
{
    public string? Description { get; init; }
    public string? ExportedBy { get; init; }
    public string? Environment { get; init; }
}

/// <summary>
/// Result of an import operation.
/// </summary>
public record ImportResult
{
    public List<string> Created { get; init; } = new();
    public List<string> Skipped { get; init; } = new();
    public Dictionary<string, string> Failed { get; init; } = new();
    public int TotalProcessed => Created.Count + Skipped.Count + Failed.Count;
}

/// <summary>
/// Strategy for handling import conflicts.
/// </summary>
[JsonConverter(typeof(JsonStringEnumConverter))]
public enum ConflictResolutionStrategy
{
    /// <summary>Skip servers that conflict.</summary>
    Skip,

    /// <summary>Replace existing servers with imported ones.</summary>
    Replace,

    /// <summary>Rename imported servers to avoid conflicts.</summary>
    Rename
}

/// <summary>
/// Request body for import operation.
/// </summary>
public record ImportConfigurationRequest
{
    public required ServerConfigurationExport Configuration { get; init; }
    public ConflictResolutionStrategy Strategy { get; init; } = ConflictResolutionStrategy.Skip;
}
```

2. Create Services/ConfigurationExportService.cs:

```csharp
namespace FileSimulator.ControlApi.Services;

using k8s;
using k8s.Models;
using Microsoft.Extensions.Logging;
using FileSimulator.ControlApi.Models;

public interface IConfigurationExportService
{
    /// <summary>Export all server configurations.</summary>
    Task<ServerConfigurationExport> ExportConfigurationAsync(CancellationToken ct = default);

    /// <summary>Import configurations with conflict resolution.</summary>
    Task<ImportResult> ImportConfigurationAsync(
        ServerConfigurationExport config,
        ConflictResolutionStrategy strategy,
        CancellationToken ct = default);

    /// <summary>Validate import configuration without applying.</summary>
    Task<ImportResult> ValidateImportAsync(
        ServerConfigurationExport config,
        CancellationToken ct = default);
}

public class ConfigurationExportService : IConfigurationExportService
{
    private readonly IKubernetes _client;
    private readonly IKubernetesDiscoveryService _discoveryService;
    private readonly IKubernetesManagementService _managementService;
    private readonly ILogger<ConfigurationExportService> _logger;
    private readonly string _namespace;
    private readonly string _releasePrefix;

    public ConfigurationExportService(
        IKubernetes client,
        IKubernetesDiscoveryService discoveryService,
        IKubernetesManagementService managementService,
        ILogger<ConfigurationExportService> logger,
        IConfiguration configuration)
    {
        _client = client;
        _discoveryService = discoveryService;
        _managementService = managementService;
        _logger = logger;
        _namespace = configuration["Kubernetes:Namespace"] ?? "file-simulator";
        _releasePrefix = configuration["Kubernetes:ReleasePrefix"] ?? "file-sim-file-simulator";
    }

    public async Task<ServerConfigurationExport> ExportConfigurationAsync(CancellationToken ct = default)
    {
        _logger.LogInformation("Exporting configuration");

        var servers = await _discoveryService.DiscoverServersAsync(ct);
        var configurations = new List<ServerConfiguration>();

        foreach (var server in servers)
        {
            var config = new ServerConfiguration
            {
                Name = server.Name,
                Protocol = server.Protocol,
                NodePort = server.NodePort,
                IsDynamic = server.IsDynamic
            };

            // Try to extract credentials from deployment env vars (for dynamic servers)
            if (server.IsDynamic)
            {
                config = await EnrichWithCredentialsAsync(server, config, ct);
            }
            else
            {
                // Static servers: include placeholder credentials
                config = server.Protocol.ToUpper() switch
                {
                    "FTP" => config with { Ftp = new FtpConfiguration { Username = "simuser", Password = "[helm-managed]" } },
                    "SFTP" => config with { Sftp = new SftpConfiguration { Username = "simuser", Password = "[helm-managed]" } },
                    "NAS" => config with { Nas = new NasConfiguration { Directory = "[helm-managed]" } },
                    _ => config
                };
            }

            configurations.Add(config);
        }

        var export = new ServerConfigurationExport
        {
            Namespace = _namespace,
            ReleasePrefix = _releasePrefix,
            Servers = configurations,
            Metadata = new ExportMetadata
            {
                Environment = "development",
                ExportedBy = "control-api"
            }
        };

        _logger.LogInformation("Exported {Count} server configurations", configurations.Count);
        return export;
    }

    private async Task<ServerConfiguration> EnrichWithCredentialsAsync(
        DiscoveredServer server,
        ServerConfiguration config,
        CancellationToken ct)
    {
        try
        {
            var deploymentName = $"{_releasePrefix}-{server.Protocol.ToLower()}-{server.Name}";
            var deployment = await _client.AppsV1.ReadNamespacedDeploymentAsync(
                deploymentName, _namespace, cancellationToken: ct);

            var container = deployment.Spec.Template.Spec.Containers.FirstOrDefault();
            if (container?.Env == null) return config;

            var envVars = container.Env.ToDictionary(e => e.Name, e => e.Value ?? "");

            return server.Protocol.ToUpper() switch
            {
                "FTP" => config with
                {
                    Ftp = new FtpConfiguration
                    {
                        Username = envVars.GetValueOrDefault("FTP_USER", ""),
                        Password = envVars.GetValueOrDefault("FTP_PASS", ""),
                        PassivePortStart = int.TryParse(envVars.GetValueOrDefault("PASV_MIN_PORT", ""), out var ps) ? ps : null,
                        PassivePortEnd = int.TryParse(envVars.GetValueOrDefault("PASV_MAX_PORT", ""), out var pe) ? pe : null
                    }
                },
                "SFTP" => config with
                {
                    Sftp = new SftpConfiguration
                    {
                        Username = container.Args?.FirstOrDefault()?.Split(':').FirstOrDefault() ?? "",
                        Password = container.Args?.FirstOrDefault()?.Split(':').Skip(1).FirstOrDefault() ?? "",
                        Uid = int.TryParse(container.Args?.FirstOrDefault()?.Split(':').Skip(2).FirstOrDefault(), out var uid) ? uid : 1000,
                        Gid = int.TryParse(container.Args?.FirstOrDefault()?.Split(':').Skip(3).FirstOrDefault(), out var gid) ? gid : 1000
                    }
                },
                "NAS" => config with
                {
                    Nas = new NasConfiguration
                    {
                        Directory = container.VolumeMounts?.FirstOrDefault()?.SubPath ?? "",
                        ExportOptions = ParseExportOptions(envVars.GetValueOrDefault("NFS_EXPORT_0", ""))
                    }
                },
                _ => config
            };
        }
        catch (Exception ex)
        {
            _logger.LogWarning(ex, "Could not enrich credentials for {Server}", server.Name);
            return config;
        }
    }

    private static string ParseExportOptions(string exportLine)
    {
        // NFS_EXPORT_0="/data *(rw,sync,...)" -> extract options
        var match = System.Text.RegularExpressions.Regex.Match(exportLine, @"\*\(([^)]+)\)");
        return match.Success ? match.Groups[1].Value.Replace(",fsid=0", "") : "rw,sync,no_subtree_check,no_root_squash";
    }

    public async Task<ImportResult> ValidateImportAsync(
        ServerConfigurationExport config,
        CancellationToken ct = default)
    {
        var result = new ImportResult();
        var existingServers = await _discoveryService.DiscoverServersAsync(ct);
        var existingNames = existingServers.Select(s => s.Name).ToHashSet();

        foreach (var serverConfig in config.Servers)
        {
            if (!serverConfig.IsDynamic)
            {
                result.Skipped.Add($"{serverConfig.Name} (static/helm-managed)");
                continue;
            }

            if (existingNames.Contains(serverConfig.Name))
            {
                result.Skipped.Add($"{serverConfig.Name} (conflict)");
            }
            else
            {
                result.Created.Add(serverConfig.Name);
            }
        }

        return result;
    }

    public async Task<ImportResult> ImportConfigurationAsync(
        ServerConfigurationExport config,
        ConflictResolutionStrategy strategy,
        CancellationToken ct = default)
    {
        _logger.LogInformation("Importing configuration with strategy {Strategy}", strategy);

        var result = new ImportResult();
        var existingServers = await _discoveryService.DiscoverServersAsync(ct);
        var existingNames = existingServers.Select(s => s.Name).ToHashSet();

        foreach (var serverConfig in config.Servers)
        {
            // Skip static servers - they're managed by Helm
            if (!serverConfig.IsDynamic)
            {
                result.Skipped.Add($"{serverConfig.Name} (static/helm-managed)");
                continue;
            }

            var targetName = serverConfig.Name;
            var hasConflict = existingNames.Contains(targetName);

            if (hasConflict)
            {
                switch (strategy)
                {
                    case ConflictResolutionStrategy.Skip:
                        result.Skipped.Add($"{targetName} (conflict)");
                        continue;

                    case ConflictResolutionStrategy.Replace:
                        try
                        {
                            await _managementService.DeleteServerAsync(targetName, false, ct);
                            _logger.LogInformation("Deleted existing server {Name} for replacement", targetName);
                        }
                        catch (Exception ex)
                        {
                            result.Failed[$"{targetName}"] = $"Failed to delete for replacement: {ex.Message}";
                            continue;
                        }
                        break;

                    case ConflictResolutionStrategy.Rename:
                        var suffix = 1;
                        while (existingNames.Contains($"{serverConfig.Name}-{suffix}"))
                            suffix++;
                        targetName = $"{serverConfig.Name}-{suffix}";
                        _logger.LogInformation("Renamed {Original} to {New} to avoid conflict",
                            serverConfig.Name, targetName);
                        break;
                }
            }

            try
            {
                await CreateServerFromConfigAsync(serverConfig, targetName, ct);
                result.Created.Add(targetName);
                existingNames.Add(targetName);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Failed to import server {Name}", targetName);
                result.Failed[targetName] = ex.Message;
            }
        }

        _logger.LogInformation("Import complete: {Created} created, {Skipped} skipped, {Failed} failed",
            result.Created.Count, result.Skipped.Count, result.Failed.Count);

        return result;
    }

    private async Task CreateServerFromConfigAsync(
        ServerConfiguration config,
        string targetName,
        CancellationToken ct)
    {
        switch (config.Protocol.ToUpper())
        {
            case "FTP" when config.Ftp != null:
                await _managementService.CreateFtpServerAsync(new CreateFtpServerRequest
                {
                    Name = targetName,
                    NodePort = config.NodePort,
                    Username = config.Ftp.Username,
                    Password = config.Ftp.Password,
                    PassivePortStart = config.Ftp.PassivePortStart,
                    PassivePortEnd = config.Ftp.PassivePortEnd
                }, ct);
                break;

            case "SFTP" when config.Sftp != null:
                await _managementService.CreateSftpServerAsync(new CreateSftpServerRequest
                {
                    Name = targetName,
                    NodePort = config.NodePort,
                    Username = config.Sftp.Username,
                    Password = config.Sftp.Password,
                    Uid = config.Sftp.Uid,
                    Gid = config.Sftp.Gid
                }, ct);
                break;

            case "NAS" when config.Nas != null:
                await _managementService.CreateNasServerAsync(new CreateNasServerRequest
                {
                    Name = targetName,
                    NodePort = config.NodePort,
                    Directory = config.Nas.Directory,
                    ExportOptions = config.Nas.ExportOptions
                }, ct);
                break;

            default:
                throw new InvalidOperationException(
                    $"Cannot import {config.Protocol} server: missing configuration or unsupported protocol");
        }
    }
}
```

3. Register in Program.cs:
```csharp
builder.Services.AddSingleton<IConfigurationExportService, ConfigurationExportService>();
```
  </action>
  <verify>
- `dotnet build src/FileSimulator.ControlApi` compiles
- ConfigurationModels has all DTOs
- ExportConfigurationAsync returns all servers with credentials for dynamic servers
- ImportConfigurationAsync handles all three conflict strategies
- Static servers are skipped during import
  </verify>
  <done>Export/import service with credential extraction, conflict resolution strategies (skip/replace/rename), and validation.</done>
</task>

<task type="auto">
  <name>Task 2: Create ConfigurationController REST endpoints</name>
  <files>src/FileSimulator.ControlApi/Controllers/ConfigurationController.cs</files>
  <action>
Create Controllers/ConfigurationController.cs:

```csharp
namespace FileSimulator.ControlApi.Controllers;

using Microsoft.AspNetCore.Mvc;
using System.Text.Json;
using System.Text;
using FileSimulator.ControlApi.Models;
using FileSimulator.ControlApi.Services;

[ApiController]
[Route("api/[controller]")]
public class ConfigurationController : ControllerBase
{
    private readonly IConfigurationExportService _exportService;
    private readonly ILogger<ConfigurationController> _logger;

    public ConfigurationController(
        IConfigurationExportService exportService,
        ILogger<ConfigurationController> logger)
    {
        _exportService = exportService;
        _logger = logger;
    }

    /// <summary>
    /// Export current configuration as JSON file download.
    /// </summary>
    [HttpGet("export")]
    [Produces("application/json")]
    public async Task<IActionResult> ExportConfiguration(CancellationToken ct)
    {
        try
        {
            var config = await _exportService.ExportConfigurationAsync(ct);

            var json = JsonSerializer.Serialize(config, new JsonSerializerOptions
            {
                WriteIndented = true,
                PropertyNamingPolicy = JsonNamingPolicy.CamelCase
            });

            var fileName = $"file-simulator-config-{DateTime.UtcNow:yyyyMMdd-HHmmss}.json";
            var bytes = Encoding.UTF8.GetBytes(json);

            return File(bytes, "application/json", fileName);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Failed to export configuration");
            return StatusCode(500, new { error = "Failed to export configuration", details = ex.Message });
        }
    }

    /// <summary>
    /// Get configuration as JSON response (for preview, not file download).
    /// </summary>
    [HttpGet("preview")]
    public async Task<ActionResult<ServerConfigurationExport>> PreviewConfiguration(CancellationToken ct)
    {
        try
        {
            var config = await _exportService.ExportConfigurationAsync(ct);
            return Ok(config);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Failed to get configuration preview");
            return StatusCode(500, new { error = "Failed to get configuration", details = ex.Message });
        }
    }

    /// <summary>
    /// Validate import configuration without applying changes.
    /// </summary>
    [HttpPost("validate")]
    public async Task<ActionResult<ImportResult>> ValidateImport(
        [FromBody] ServerConfigurationExport config,
        CancellationToken ct)
    {
        try
        {
            var result = await _exportService.ValidateImportAsync(config, ct);
            return Ok(result);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Failed to validate import");
            return StatusCode(500, new { error = "Failed to validate import", details = ex.Message });
        }
    }

    /// <summary>
    /// Import configuration from JSON.
    /// </summary>
    [HttpPost("import")]
    public async Task<ActionResult<ImportResult>> ImportConfiguration(
        [FromBody] ImportConfigurationRequest request,
        CancellationToken ct)
    {
        try
        {
            // Basic validation
            if (request.Configuration?.Servers == null || !request.Configuration.Servers.Any())
            {
                return BadRequest(new { error = "Configuration must contain at least one server" });
            }

            if (string.IsNullOrEmpty(request.Configuration.Version))
            {
                return BadRequest(new { error = "Configuration must include version" });
            }

            var result = await _exportService.ImportConfigurationAsync(
                request.Configuration,
                request.Strategy,
                ct);

            if (result.Failed.Any())
            {
                // Partial success - return 207 Multi-Status
                return StatusCode(207, result);
            }

            return Ok(result);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Failed to import configuration");
            return StatusCode(500, new { error = "Failed to import configuration", details = ex.Message });
        }
    }

    /// <summary>
    /// Import configuration from uploaded JSON file.
    /// </summary>
    [HttpPost("import/file")]
    public async Task<ActionResult<ImportResult>> ImportConfigurationFile(
        IFormFile file,
        [FromQuery] ConflictResolutionStrategy strategy = ConflictResolutionStrategy.Skip,
        CancellationToken ct = default)
    {
        try
        {
            if (file == null || file.Length == 0)
            {
                return BadRequest(new { error = "No file provided" });
            }

            if (!file.FileName.EndsWith(".json", StringComparison.OrdinalIgnoreCase))
            {
                return BadRequest(new { error = "File must be JSON format" });
            }

            using var reader = new StreamReader(file.OpenReadStream());
            var json = await reader.ReadToEndAsync(ct);

            var config = JsonSerializer.Deserialize<ServerConfigurationExport>(json, new JsonSerializerOptions
            {
                PropertyNameCaseInsensitive = true
            });

            if (config == null)
            {
                return BadRequest(new { error = "Invalid JSON format" });
            }

            var result = await _exportService.ImportConfigurationAsync(config, strategy, ct);

            if (result.Failed.Any())
            {
                return StatusCode(207, result);
            }

            return Ok(result);
        }
        catch (JsonException ex)
        {
            return BadRequest(new { error = "Invalid JSON format", details = ex.Message });
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Failed to import configuration file");
            return StatusCode(500, new { error = "Failed to import configuration", details = ex.Message });
        }
    }

    /// <summary>
    /// Get configuration templates for common scenarios.
    /// </summary>
    [HttpGet("templates")]
    public ActionResult<Dictionary<string, object>> GetTemplates()
    {
        var templates = new Dictionary<string, object>
        {
            ["basic"] = new ServerConfigurationExport
            {
                Version = "2.0",
                Namespace = "file-simulator",
                ReleasePrefix = "file-sim-file-simulator",
                Servers = new List<ServerConfiguration>
                {
                    new() { Name = "ftp-1", Protocol = "FTP", IsDynamic = true,
                        Ftp = new FtpConfiguration { Username = "user1", Password = "password123" } }
                },
                Metadata = new ExportMetadata { Description = "Basic single FTP server" }
            },
            ["multi-nas"] = new ServerConfigurationExport
            {
                Version = "2.0",
                Namespace = "file-simulator",
                ReleasePrefix = "file-sim-file-simulator",
                Servers = new List<ServerConfiguration>
                {
                    new() { Name = "nas-input-1", Protocol = "NAS", IsDynamic = true,
                        Nas = new NasConfiguration { Directory = "input" } },
                    new() { Name = "nas-input-2", Protocol = "NAS", IsDynamic = true,
                        Nas = new NasConfiguration { Directory = "input" } },
                    new() { Name = "nas-output-1", Protocol = "NAS", IsDynamic = true,
                        Nas = new NasConfiguration { Directory = "output" } }
                },
                Metadata = new ExportMetadata { Description = "Multi-NAS setup with 2 input, 1 output" }
            }
        };

        return Ok(templates);
    }
}
```
  </action>
  <verify>
- `dotnet build src/FileSimulator.ControlApi` compiles
- ConfigurationController has all endpoints:
  - GET /api/configuration/export (file download)
  - GET /api/configuration/preview (JSON response)
  - POST /api/configuration/validate
  - POST /api/configuration/import
  - POST /api/configuration/import/file (form data upload)
  - GET /api/configuration/templates
- Export returns file with proper filename
- Import accepts both JSON body and file upload
  </verify>
  <done>Configuration controller with export/import endpoints, file upload support, validation, and configuration templates.</done>
</task>

</tasks>

<verification>
1. `dotnet build src/FileSimulator.ControlApi` succeeds
2. Export endpoint returns downloadable JSON with all servers
3. Import validates schema and handles conflicts
4. Three conflict strategies work: skip, replace, rename
5. Templates endpoint provides common configurations
</verification>

<success_criteria>
- Export includes ALL servers - static and dynamic (CFG-01)
- Import recreates servers from JSON (CFG-02)
- Validation before import (CFG-03)
- Templates for common scenarios (CFG-04)
- Credentials included (CONTEXT.md: user responsible for security)
</success_criteria>

<output>
After completion, create `.planning/phases/11-dynamic-server-management/11-05-SUMMARY.md`
</output>
