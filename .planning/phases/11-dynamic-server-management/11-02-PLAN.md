---
phase: 11-dynamic-server-management
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/FileSimulator.ControlApi/Services/IKubernetesManagementService.cs
  - src/FileSimulator.ControlApi/Services/KubernetesManagementService.cs
  - src/FileSimulator.ControlApi/Models/DiscoveredServer.cs
autonomous: true

must_haves:
  truths:
    - "IKubernetesManagementService interface defines CRUD operations for dynamic servers"
    - "DiscoveredServer includes IsDynamic flag distinguishing dynamic from static servers"
    - "KubernetesManagementService can create FTP deployments with ownerReferences"
  artifacts:
    - path: "src/FileSimulator.ControlApi/Services/IKubernetesManagementService.cs"
      provides: "Interface for server lifecycle management"
      exports: ["IKubernetesManagementService"]
    - path: "src/FileSimulator.ControlApi/Services/KubernetesManagementService.cs"
      provides: "Implementation with K8s API calls"
      min_lines: 150
    - path: "src/FileSimulator.ControlApi/Models/DiscoveredServer.cs"
      provides: "Extended model with IsDynamic property"
      contains: "IsDynamic"
  key_links:
    - from: "KubernetesManagementService"
      to: "k8s.Kubernetes"
      via: "IKubernetes client injection"
      pattern: "_client\\.AppsV1\\."
---

<objective>
Create the IKubernetesManagementService interface and implement FTP server creation with ownerReferences.

Purpose: This service handles write operations to Kubernetes API for dynamic server management. FTP is implemented first as the simpler protocol (single port, well-understood).
Output: Management service interface and FTP creation implementation.
</objective>

<execution_context>
@C:\Users\UserC\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\UserC\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/11-dynamic-server-management/11-RESEARCH.md

# Existing K8s integration patterns
@src/FileSimulator.ControlApi/Services/KubernetesDiscoveryService.cs
@src/FileSimulator.ControlApi/Models/DiscoveredServer.cs

# Helm template as blueprint
@helm-chart/file-simulator/templates/ftp.yaml
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create IKubernetesManagementService interface and extend DiscoveredServer</name>
  <files>
src/FileSimulator.ControlApi/Services/IKubernetesManagementService.cs
src/FileSimulator.ControlApi/Models/DiscoveredServer.cs
  </files>
  <action>
1. Create Services/IKubernetesManagementService.cs:

```csharp
namespace FileSimulator.ControlApi.Services;

using FileSimulator.ControlApi.Models;

/// <summary>
/// Service for creating, updating, and deleting dynamic server instances.
/// Uses Kubernetes API directly (not Helm) for runtime management.
/// </summary>
public interface IKubernetesManagementService
{
    /// <summary>
    /// Create a new FTP server instance.
    /// </summary>
    /// <param name="request">FTP server configuration</param>
    /// <param name="ct">Cancellation token</param>
    /// <returns>Created server details</returns>
    Task<DiscoveredServer> CreateFtpServerAsync(CreateFtpServerRequest request, CancellationToken ct = default);

    /// <summary>
    /// Create a new SFTP server instance.
    /// </summary>
    Task<DiscoveredServer> CreateSftpServerAsync(CreateSftpServerRequest request, CancellationToken ct = default);

    /// <summary>
    /// Create a new NAS (NFS) server instance.
    /// </summary>
    Task<DiscoveredServer> CreateNasServerAsync(CreateNasServerRequest request, CancellationToken ct = default);

    /// <summary>
    /// Delete a dynamic server by name. Cleans up deployment, service, and optionally data.
    /// </summary>
    /// <param name="serverName">Name of the server instance</param>
    /// <param name="deleteData">For NAS servers: whether to delete files from Windows directory</param>
    /// <param name="ct">Cancellation token</param>
    Task DeleteServerAsync(string serverName, bool deleteData = false, CancellationToken ct = default);

    /// <summary>
    /// Stop a server (scale deployment to 0 replicas).
    /// </summary>
    Task StopServerAsync(string serverName, CancellationToken ct = default);

    /// <summary>
    /// Start a stopped server (scale deployment to 1 replica).
    /// </summary>
    Task StartServerAsync(string serverName, CancellationToken ct = default);

    /// <summary>
    /// Restart a server by deleting its pod (deployment recreates it).
    /// </summary>
    Task RestartServerAsync(string serverName, CancellationToken ct = default);

    /// <summary>
    /// Check if a server name is available (not already used).
    /// </summary>
    Task<bool> IsServerNameAvailableAsync(string name, CancellationToken ct = default);

    /// <summary>
    /// Get the control plane pod (owner for dynamic resources).
    /// </summary>
    Task<k8s.Models.V1Pod> GetControlPlanePodAsync(CancellationToken ct = default);
}
```

2. Update Models/DiscoveredServer.cs to add IsDynamic and ManagedBy:

```csharp
namespace FileSimulator.ControlApi.Models;

/// <summary>
/// Server discovered via Kubernetes API, before health check.
/// </summary>
public record DiscoveredServer
{
    public required string Name { get; init; }
    public required string PodName { get; init; }
    public required string Protocol { get; init; }
    public required string ServiceName { get; init; }
    public required string ClusterIp { get; init; }
    public required int Port { get; init; }
    public int? NodePort { get; init; }
    public required string PodStatus { get; init; }
    public required bool PodReady { get; init; }
    public DateTime DiscoveredAt { get; init; } = DateTime.UtcNow;

    /// <summary>
    /// True if created via Control API, false if deployed via Helm.
    /// </summary>
    public bool IsDynamic { get; init; }

    /// <summary>
    /// Resource manager: "control-api" for dynamic, "Helm" for static.
    /// </summary>
    public string ManagedBy { get; init; } = "Helm";
}
```
  </action>
  <verify>
- `dotnet build src/FileSimulator.ControlApi` compiles
- IKubernetesManagementService has all method signatures
- DiscoveredServer has IsDynamic and ManagedBy properties
  </verify>
  <done>Interface defined with full CRUD + lifecycle methods. DiscoveredServer extended with dynamic/static distinction.</done>
</task>

<task type="auto">
  <name>Task 2: Implement KubernetesManagementService with FTP creation</name>
  <files>
src/FileSimulator.ControlApi/Services/KubernetesManagementService.cs
src/FileSimulator.ControlApi/Program.cs
  </files>
  <action>
1. Create Services/KubernetesManagementService.cs:

```csharp
namespace FileSimulator.ControlApi.Services;

using k8s;
using k8s.Models;
using Microsoft.Extensions.Logging;
using FileSimulator.ControlApi.Models;

public class KubernetesManagementService : IKubernetesManagementService
{
    private readonly IKubernetes _client;
    private readonly ILogger<KubernetesManagementService> _logger;
    private readonly string _namespace;
    private readonly string _releasePrefix;
    private readonly string _pvcName;

    public KubernetesManagementService(
        IKubernetes client,
        ILogger<KubernetesManagementService> logger,
        IConfiguration configuration)
    {
        _client = client;
        _logger = logger;
        _namespace = configuration["Kubernetes:Namespace"] ?? "file-simulator";
        _releasePrefix = configuration["Kubernetes:ReleasePrefix"] ?? "file-sim-file-simulator";
        _pvcName = configuration["Kubernetes:PvcName"] ?? $"{_releasePrefix}-pvc";
    }

    public async Task<V1Pod> GetControlPlanePodAsync(CancellationToken ct = default)
    {
        var pods = await _client.CoreV1.ListNamespacedPodAsync(
            _namespace,
            labelSelector: "app.kubernetes.io/component=control-api",
            cancellationToken: ct);

        var controlPod = pods.Items.FirstOrDefault(p =>
            p.Status?.Phase == "Running" &&
            p.Metadata?.Name?.Contains("control-api") == true);

        if (controlPod == null)
            throw new InvalidOperationException("Control plane pod not found or not running");

        return controlPod;
    }

    public async Task<bool> IsServerNameAvailableAsync(string name, CancellationToken ct = default)
    {
        // Check if any deployment exists with this instance name
        var deployments = await _client.AppsV1.ListNamespacedDeploymentAsync(
            _namespace,
            labelSelector: $"app.kubernetes.io/instance={name}",
            cancellationToken: ct);

        return !deployments.Items.Any();
    }

    public async Task<DiscoveredServer> CreateFtpServerAsync(CreateFtpServerRequest request, CancellationToken ct = default)
    {
        _logger.LogInformation("Creating FTP server {Name}", request.Name);

        // 1. Get control plane pod for ownerReference
        var controlPod = await GetControlPlanePodAsync(ct);

        var resourceName = $"{_releasePrefix}-ftp-{request.Name}";
        var labels = new Dictionary<string, string>
        {
            ["app.kubernetes.io/name"] = "file-simulator",
            ["app.kubernetes.io/component"] = "ftp",
            ["app.kubernetes.io/managed-by"] = "control-api",
            ["app.kubernetes.io/instance"] = request.Name,
            ["app.kubernetes.io/part-of"] = "file-simulator-suite"
        };

        var ownerRef = new V1OwnerReference
        {
            ApiVersion = "v1",
            Kind = "Pod",
            Name = controlPod.Metadata.Name,
            Uid = controlPod.Metadata.Uid,
            Controller = true,
            BlockOwnerDeletion = true
        };

        // 2. Create Deployment
        var deployment = new V1Deployment
        {
            Metadata = new V1ObjectMeta
            {
                Name = resourceName,
                NamespaceProperty = _namespace,
                Labels = labels,
                OwnerReferences = new List<V1OwnerReference> { ownerRef }
            },
            Spec = new V1DeploymentSpec
            {
                Replicas = 1,
                Selector = new V1LabelSelector
                {
                    MatchLabels = new Dictionary<string, string>
                    {
                        ["app.kubernetes.io/name"] = "file-simulator",
                        ["app.kubernetes.io/instance"] = request.Name
                    }
                },
                Template = new V1PodTemplateSpec
                {
                    Metadata = new V1ObjectMeta { Labels = labels },
                    Spec = new V1PodSpec
                    {
                        Containers = new List<V1Container>
                        {
                            new V1Container
                            {
                                Name = "vsftpd",
                                Image = "fauria/vsftpd:latest",
                                ImagePullPolicy = "IfNotPresent",
                                Ports = new List<V1ContainerPort>
                                {
                                    new V1ContainerPort { ContainerPortProperty = 21, Protocol = "TCP", Name = "ftp" }
                                },
                                Env = new List<V1EnvVar>
                                {
                                    new V1EnvVar { Name = "FTP_USER", Value = request.Username },
                                    new V1EnvVar { Name = "FTP_PASS", Value = request.Password },
                                    new V1EnvVar { Name = "LOG_STDOUT", Value = "YES" },
                                    new V1EnvVar { Name = "LOCAL_UMASK", Value = "022" }
                                },
                                VolumeMounts = new List<V1VolumeMount>
                                {
                                    new V1VolumeMount
                                    {
                                        Name = "data",
                                        MountPath = $"/home/vsftpd/{request.Username}"
                                    }
                                },
                                SecurityContext = new V1SecurityContext { Privileged = true },
                                Resources = new V1ResourceRequirements
                                {
                                    Requests = new Dictionary<string, ResourceQuantity>
                                    {
                                        ["memory"] = new ResourceQuantity("64Mi"),
                                        ["cpu"] = new ResourceQuantity("50m")
                                    },
                                    Limits = new Dictionary<string, ResourceQuantity>
                                    {
                                        ["memory"] = new ResourceQuantity("256Mi"),
                                        ["cpu"] = new ResourceQuantity("200m")
                                    }
                                }
                            }
                        },
                        Volumes = new List<V1Volume>
                        {
                            new V1Volume
                            {
                                Name = "data",
                                PersistentVolumeClaim = new V1PersistentVolumeClaimVolumeSource
                                {
                                    ClaimName = _pvcName
                                }
                            }
                        }
                    }
                }
            }
        };

        var createdDeployment = await _client.AppsV1.CreateNamespacedDeploymentAsync(
            deployment, _namespace, cancellationToken: ct);

        // 3. Create Service
        var service = new V1Service
        {
            Metadata = new V1ObjectMeta
            {
                Name = resourceName,
                NamespaceProperty = _namespace,
                Labels = labels,
                OwnerReferences = new List<V1OwnerReference> { ownerRef }
            },
            Spec = new V1ServiceSpec
            {
                Type = "NodePort",
                Selector = new Dictionary<string, string>
                {
                    ["app.kubernetes.io/name"] = "file-simulator",
                    ["app.kubernetes.io/instance"] = request.Name
                },
                Ports = new List<V1ServicePort>
                {
                    new V1ServicePort
                    {
                        Port = 21,
                        TargetPort = 21,
                        Protocol = "TCP",
                        Name = "ftp",
                        NodePort = request.NodePort  // null = auto-assign
                    }
                }
            }
        };

        var createdService = await _client.CoreV1.CreateNamespacedServiceAsync(
            service, _namespace, cancellationToken: ct);

        _logger.LogInformation("Created FTP server {Name} with NodePort {NodePort}",
            request.Name, createdService.Spec.Ports[0].NodePort);

        return new DiscoveredServer
        {
            Name = request.Name,
            Protocol = "FTP",
            PodName = $"{resourceName}-pending",  // Pod name not yet assigned
            ServiceName = createdService.Metadata.Name,
            ClusterIp = createdService.Spec.ClusterIP ?? "",
            Port = 21,
            NodePort = createdService.Spec.Ports[0].NodePort,
            PodStatus = "Pending",
            PodReady = false,
            IsDynamic = true,
            ManagedBy = "control-api"
        };
    }

    // Placeholder implementations for plan 11-03
    public Task<DiscoveredServer> CreateSftpServerAsync(CreateSftpServerRequest request, CancellationToken ct = default)
        => throw new NotImplementedException("Implemented in plan 11-03");

    public Task<DiscoveredServer> CreateNasServerAsync(CreateNasServerRequest request, CancellationToken ct = default)
        => throw new NotImplementedException("Implemented in plan 11-03");

    public Task DeleteServerAsync(string serverName, bool deleteData = false, CancellationToken ct = default)
        => throw new NotImplementedException("Implemented in plan 11-03");

    public Task StopServerAsync(string serverName, CancellationToken ct = default)
        => throw new NotImplementedException("Implemented in plan 11-04");

    public Task StartServerAsync(string serverName, CancellationToken ct = default)
        => throw new NotImplementedException("Implemented in plan 11-04");

    public Task RestartServerAsync(string serverName, CancellationToken ct = default)
        => throw new NotImplementedException("Implemented in plan 11-04");
}
```

2. Register KubernetesManagementService in Program.cs (add after KubernetesDiscoveryService registration):

```csharp
builder.Services.AddSingleton<IKubernetesManagementService, KubernetesManagementService>();
```
  </action>
  <verify>
- `dotnet build src/FileSimulator.ControlApi` compiles without errors
- KubernetesManagementService registered in DI
- CreateFtpServerAsync creates deployment with ownerReferences
- CreateFtpServerAsync creates NodePort service
  </verify>
  <done>KubernetesManagementService implements FTP creation with ownerReferences to control plane pod. Service registered in DI.</done>
</task>

</tasks>

<verification>
1. `dotnet build src/FileSimulator.ControlApi` succeeds
2. IKubernetesManagementService interface has all 9 methods
3. DiscoveredServer has IsDynamic and ManagedBy properties
4. KubernetesManagementService.CreateFtpServerAsync:
   - Gets control plane pod
   - Creates V1Deployment with labels and ownerReferences
   - Creates V1Service with NodePort
   - Returns DiscoveredServer with IsDynamic=true
</verification>

<success_criteria>
- Interface defines complete server lifecycle operations
- FTP creation matches Helm template structure (ftp.yaml)
- OwnerReferences point to control plane pod (not deployment)
- Dynamic servers labeled with managed-by: control-api
</success_criteria>

<output>
After completion, create `.planning/phases/11-dynamic-server-management/11-02-SUMMARY.md`
</output>
