---
phase: 11-dynamic-server-management
plan: 03
type: execute
wave: 2
depends_on: ["11-02"]
files_modified:
  - src/FileSimulator.ControlApi/Services/KubernetesManagementService.cs
  - src/FileSimulator.ControlApi/Services/KubernetesDiscoveryService.cs
autonomous: true

must_haves:
  truths:
    - "SFTP servers can be created dynamically with username/password/uid/gid"
    - "NAS servers can be created with custom directory and export options"
    - "DeleteServerAsync removes deployment, service, and optionally PVC/data"
    - "Services and PVCs are explicitly deleted (no cascade from deployment)"
  artifacts:
    - path: "src/FileSimulator.ControlApi/Services/KubernetesManagementService.cs"
      provides: "Complete SFTP, NAS creation and deletion logic"
      min_lines: 350
  key_links:
    - from: "DeleteServerAsync"
      to: "k8s.AppsV1.DeleteNamespacedDeploymentAsync"
      via: "explicit cleanup"
      pattern: "DeleteNamespacedDeploymentAsync"
    - from: "DeleteServerAsync"
      to: "k8s.CoreV1.DeleteNamespacedServiceAsync"
      via: "explicit service cleanup"
      pattern: "DeleteNamespacedServiceAsync"
---

<objective>
Implement SFTP and NAS server creation, plus deletion logic with explicit resource cleanup.

Purpose: Complete the CRUD operations for all three protocol types. Deletion must explicitly clean up services and optionally PVCs since they don't cascade from deployment deletion.
Output: Full CreateSftpServerAsync, CreateNasServerAsync, and DeleteServerAsync implementations.
</objective>

<execution_context>
@C:\Users\UserC\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\UserC\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/11-dynamic-server-management/11-RESEARCH.md

# Prior plan for FTP pattern
@.planning/phases/11-dynamic-server-management/11-02-SUMMARY.md

# Helm templates as blueprints
@helm-chart/file-simulator/templates/sftp.yaml
@helm-chart/file-simulator/templates/nas.yaml
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement SFTP and NAS server creation</name>
  <files>src/FileSimulator.ControlApi/Services/KubernetesManagementService.cs</files>
  <action>
Replace placeholder implementations with full code.

1. Implement CreateSftpServerAsync following the FTP pattern but with SFTP-specific config:

```csharp
public async Task<DiscoveredServer> CreateSftpServerAsync(CreateSftpServerRequest request, CancellationToken ct = default)
{
    _logger.LogInformation("Creating SFTP server {Name}", request.Name);

    var controlPod = await GetControlPlanePodAsync(ct);
    var resourceName = $"{_releasePrefix}-sftp-{request.Name}";

    var labels = new Dictionary<string, string>
    {
        ["app.kubernetes.io/name"] = "file-simulator",
        ["app.kubernetes.io/component"] = "sftp",
        ["app.kubernetes.io/managed-by"] = "control-api",
        ["app.kubernetes.io/instance"] = request.Name,
        ["app.kubernetes.io/part-of"] = "file-simulator-suite"
    };

    var ownerRef = new V1OwnerReference
    {
        ApiVersion = "v1",
        Kind = "Pod",
        Name = controlPod.Metadata.Name,
        Uid = controlPod.Metadata.Uid,
        Controller = true,
        BlockOwnerDeletion = true
    };

    var deployment = new V1Deployment
    {
        Metadata = new V1ObjectMeta
        {
            Name = resourceName,
            NamespaceProperty = _namespace,
            Labels = labels,
            OwnerReferences = new List<V1OwnerReference> { ownerRef }
        },
        Spec = new V1DeploymentSpec
        {
            Replicas = 1,
            Selector = new V1LabelSelector
            {
                MatchLabels = new Dictionary<string, string>
                {
                    ["app.kubernetes.io/name"] = "file-simulator",
                    ["app.kubernetes.io/instance"] = request.Name
                }
            },
            Template = new V1PodTemplateSpec
            {
                Metadata = new V1ObjectMeta { Labels = labels },
                Spec = new V1PodSpec
                {
                    Containers = new List<V1Container>
                    {
                        new V1Container
                        {
                            Name = "sftp",
                            Image = "atmoz/sftp:latest",
                            ImagePullPolicy = "IfNotPresent",
                            Ports = new List<V1ContainerPort>
                            {
                                new V1ContainerPort { ContainerPortProperty = 22, Protocol = "TCP", Name = "sftp" }
                            },
                            // User format: username:password:uid:gid
                            Args = new List<string>
                            {
                                $"{request.Username}:{request.Password}:{request.Uid}:{request.Gid}"
                            },
                            VolumeMounts = new List<V1VolumeMount>
                            {
                                new V1VolumeMount
                                {
                                    Name = "data",
                                    MountPath = $"/home/{request.Username}/data"
                                }
                            },
                            SecurityContext = new V1SecurityContext
                            {
                                Capabilities = new V1Capabilities
                                {
                                    Add = new List<string> { "SYS_CHROOT" }
                                }
                            },
                            Resources = new V1ResourceRequirements
                            {
                                Requests = new Dictionary<string, ResourceQuantity>
                                {
                                    ["memory"] = new ResourceQuantity("64Mi"),
                                    ["cpu"] = new ResourceQuantity("50m")
                                },
                                Limits = new Dictionary<string, ResourceQuantity>
                                {
                                    ["memory"] = new ResourceQuantity("256Mi"),
                                    ["cpu"] = new ResourceQuantity("200m")
                                }
                            }
                        }
                    },
                    Volumes = new List<V1Volume>
                    {
                        new V1Volume
                        {
                            Name = "data",
                            PersistentVolumeClaim = new V1PersistentVolumeClaimVolumeSource
                            {
                                ClaimName = _pvcName
                            }
                        }
                    }
                }
            }
        }
    };

    var createdDeployment = await _client.AppsV1.CreateNamespacedDeploymentAsync(
        deployment, _namespace, cancellationToken: ct);

    var service = new V1Service
    {
        Metadata = new V1ObjectMeta
        {
            Name = resourceName,
            NamespaceProperty = _namespace,
            Labels = labels,
            OwnerReferences = new List<V1OwnerReference> { ownerRef }
        },
        Spec = new V1ServiceSpec
        {
            Type = "NodePort",
            Selector = new Dictionary<string, string>
            {
                ["app.kubernetes.io/name"] = "file-simulator",
                ["app.kubernetes.io/instance"] = request.Name
            },
            Ports = new List<V1ServicePort>
            {
                new V1ServicePort
                {
                    Port = 22,
                    TargetPort = 22,
                    Protocol = "TCP",
                    Name = "sftp",
                    NodePort = request.NodePort
                }
            }
        }
    };

    var createdService = await _client.CoreV1.CreateNamespacedServiceAsync(
        service, _namespace, cancellationToken: ct);

    _logger.LogInformation("Created SFTP server {Name} with NodePort {NodePort}",
        request.Name, createdService.Spec.Ports[0].NodePort);

    return new DiscoveredServer
    {
        Name = request.Name,
        Protocol = "SFTP",
        PodName = $"{resourceName}-pending",
        ServiceName = createdService.Metadata.Name,
        ClusterIp = createdService.Spec.ClusterIP ?? "",
        Port = 22,
        NodePort = createdService.Spec.Ports[0].NodePort,
        PodStatus = "Pending",
        PodReady = false,
        IsDynamic = true,
        ManagedBy = "control-api"
    };
}
```

2. Implement CreateNasServerAsync for NFS servers:

```csharp
public async Task<DiscoveredServer> CreateNasServerAsync(CreateNasServerRequest request, CancellationToken ct = default)
{
    _logger.LogInformation("Creating NAS server {Name} with directory {Directory}", request.Name, request.Directory);

    var controlPod = await GetControlPlanePodAsync(ct);
    var resourceName = $"{_releasePrefix}-nas-{request.Name}";

    // Resolve directory preset or use custom
    var directory = request.Directory.ToLower() switch
    {
        "input" => "nas-input-dynamic",
        "output" => "nas-output-dynamic",
        "backup" => "nas-backup-dynamic",
        _ => request.Directory
    };

    var labels = new Dictionary<string, string>
    {
        ["app.kubernetes.io/name"] = "file-simulator",
        ["app.kubernetes.io/component"] = "nas",
        ["app.kubernetes.io/managed-by"] = "control-api",
        ["app.kubernetes.io/instance"] = request.Name,
        ["app.kubernetes.io/part-of"] = "file-simulator-suite"
    };

    var ownerRef = new V1OwnerReference
    {
        ApiVersion = "v1",
        Kind = "Pod",
        Name = controlPod.Metadata.Name,
        Uid = controlPod.Metadata.Uid,
        Controller = true,
        BlockOwnerDeletion = true
    };

    // NAS uses subdirectory on shared PVC, not separate PVC
    var deployment = new V1Deployment
    {
        Metadata = new V1ObjectMeta
        {
            Name = resourceName,
            NamespaceProperty = _namespace,
            Labels = labels,
            OwnerReferences = new List<V1OwnerReference> { ownerRef }
        },
        Spec = new V1DeploymentSpec
        {
            Replicas = 1,
            Selector = new V1LabelSelector
            {
                MatchLabels = new Dictionary<string, string>
                {
                    ["app.kubernetes.io/name"] = "file-simulator",
                    ["app.kubernetes.io/instance"] = request.Name
                }
            },
            Template = new V1PodTemplateSpec
            {
                Metadata = new V1ObjectMeta { Labels = labels },
                Spec = new V1PodSpec
                {
                    Containers = new List<V1Container>
                    {
                        new V1Container
                        {
                            Name = "nfs-server",
                            Image = "erichough/nfs-server:latest",
                            ImagePullPolicy = "IfNotPresent",
                            Ports = new List<V1ContainerPort>
                            {
                                new V1ContainerPort { ContainerPortProperty = 2049, Protocol = "TCP", Name = "nfs" },
                                new V1ContainerPort { ContainerPortProperty = 111, Protocol = "TCP", Name = "rpcbind" }
                            },
                            Env = new List<V1EnvVar>
                            {
                                new V1EnvVar
                                {
                                    Name = "NFS_EXPORT_0",
                                    Value = $"/data *({request.ExportOptions},fsid=0)"
                                },
                                new V1EnvVar { Name = "NFS_DISABLE_VERSION_3", Value = "false" },
                                new V1EnvVar { Name = "NFS_LOG_LEVEL", Value = "DEBUG" }
                            },
                            VolumeMounts = new List<V1VolumeMount>
                            {
                                new V1VolumeMount
                                {
                                    Name = "data",
                                    MountPath = "/data",
                                    SubPath = directory  // Use subdirectory on shared PVC
                                }
                            },
                            SecurityContext = new V1SecurityContext
                            {
                                Privileged = true,
                                Capabilities = new V1Capabilities
                                {
                                    Add = new List<string> { "SYS_ADMIN", "DAC_READ_SEARCH" }
                                }
                            },
                            Resources = new V1ResourceRequirements
                            {
                                Requests = new Dictionary<string, ResourceQuantity>
                                {
                                    ["memory"] = new ResourceQuantity("128Mi"),
                                    ["cpu"] = new ResourceQuantity("100m")
                                },
                                Limits = new Dictionary<string, ResourceQuantity>
                                {
                                    ["memory"] = new ResourceQuantity("512Mi"),
                                    ["cpu"] = new ResourceQuantity("500m")
                                }
                            }
                        }
                    },
                    Volumes = new List<V1Volume>
                    {
                        new V1Volume
                        {
                            Name = "data",
                            PersistentVolumeClaim = new V1PersistentVolumeClaimVolumeSource
                            {
                                ClaimName = _pvcName
                            }
                        }
                    }
                }
            }
        }
    };

    var createdDeployment = await _client.AppsV1.CreateNamespacedDeploymentAsync(
        deployment, _namespace, cancellationToken: ct);

    var service = new V1Service
    {
        Metadata = new V1ObjectMeta
        {
            Name = resourceName,
            NamespaceProperty = _namespace,
            Labels = labels,
            OwnerReferences = new List<V1OwnerReference> { ownerRef }
        },
        Spec = new V1ServiceSpec
        {
            Type = "NodePort",
            Selector = new Dictionary<string, string>
            {
                ["app.kubernetes.io/name"] = "file-simulator",
                ["app.kubernetes.io/instance"] = request.Name
            },
            Ports = new List<V1ServicePort>
            {
                new V1ServicePort
                {
                    Port = 2049,
                    TargetPort = 2049,
                    Protocol = "TCP",
                    Name = "nfs",
                    NodePort = request.NodePort
                }
            }
        }
    };

    var createdService = await _client.CoreV1.CreateNamespacedServiceAsync(
        service, _namespace, cancellationToken: ct);

    _logger.LogInformation("Created NAS server {Name} at directory {Directory} with NodePort {NodePort}",
        request.Name, directory, createdService.Spec.Ports[0].NodePort);

    return new DiscoveredServer
    {
        Name = request.Name,
        Protocol = "NAS",
        PodName = $"{resourceName}-pending",
        ServiceName = createdService.Metadata.Name,
        ClusterIp = createdService.Spec.ClusterIP ?? "",
        Port = 2049,
        NodePort = createdService.Spec.Ports[0].NodePort,
        PodStatus = "Pending",
        PodReady = false,
        IsDynamic = true,
        ManagedBy = "control-api"
    };
}
```
  </action>
  <verify>
- `dotnet build src/FileSimulator.ControlApi` compiles
- CreateSftpServerAsync creates SFTP container with user args format
- CreateNasServerAsync resolves directory presets and uses SubPath
- Both methods return DiscoveredServer with IsDynamic=true
  </verify>
  <done>SFTP and NAS server creation implemented with proper container configs and SubPath for directory isolation.</done>
</task>

<task type="auto">
  <name>Task 2: Implement DeleteServerAsync with explicit cleanup</name>
  <files>
src/FileSimulator.ControlApi/Services/KubernetesManagementService.cs
src/FileSimulator.ControlApi/Services/KubernetesDiscoveryService.cs
  </files>
  <action>
1. Implement DeleteServerAsync in KubernetesManagementService:

```csharp
public async Task DeleteServerAsync(string serverName, bool deleteData = false, CancellationToken ct = default)
{
    _logger.LogInformation("Deleting server {ServerName}, deleteData={DeleteData}", serverName, deleteData);

    var labelSelector = $"app.kubernetes.io/instance={serverName},app.kubernetes.io/managed-by=control-api";

    // 1. Check if this is a dynamic server (managed by control-api)
    var deployments = await _client.AppsV1.ListNamespacedDeploymentAsync(
        _namespace,
        labelSelector: labelSelector,
        cancellationToken: ct);

    if (!deployments.Items.Any())
    {
        throw new InvalidOperationException(
            $"Server '{serverName}' not found or is managed by Helm (cannot delete static servers via API)");
    }

    // 2. Delete deployments (pods cascade via ownerReferences)
    foreach (var deployment in deployments.Items)
    {
        _logger.LogDebug("Deleting deployment {Name}", deployment.Metadata.Name);
        await _client.AppsV1.DeleteNamespacedDeploymentAsync(
            deployment.Metadata.Name,
            _namespace,
            propagationPolicy: "Foreground",  // Wait for pods to terminate
            cancellationToken: ct);
    }

    // 3. Delete services explicitly (do NOT cascade from deployment)
    var services = await _client.CoreV1.ListNamespacedServiceAsync(
        _namespace,
        labelSelector: labelSelector,
        cancellationToken: ct);

    foreach (var service in services.Items)
    {
        _logger.LogDebug("Deleting service {Name}", service.Metadata.Name);
        await _client.CoreV1.DeleteNamespacedServiceAsync(
            service.Metadata.Name,
            _namespace,
            cancellationToken: ct);
    }

    // 4. Delete PVC if requested (for NAS servers with dedicated storage)
    // Note: Our NAS uses subdirectory on shared PVC, so we don't delete PVC
    // deleteData flag is for future use or could trigger file cleanup
    if (deleteData)
    {
        _logger.LogInformation("deleteData=true but NAS uses shared PVC subdirectory; " +
            "directory cleanup would require file system access");
        // TODO: Could call file cleanup API if needed
    }

    _logger.LogInformation("Deleted server {ServerName}", serverName);
}
```

2. Update KubernetesDiscoveryService to set IsDynamic based on managed-by label:

In the DiscoverServersAsync method, after reading deployment labels, determine IsDynamic:

```csharp
// Inside the loop where servers are discovered from deployments/pods
var managedBy = deployment.Metadata?.Labels?.TryGetValue("app.kubernetes.io/managed-by", out var manager) == true
    ? manager
    : "Helm";

// When creating DiscoveredServer
IsDynamic = managedBy == "control-api",
ManagedBy = managedBy
```
  </action>
  <verify>
- `dotnet build src/FileSimulator.ControlApi` compiles
- DeleteServerAsync checks for managed-by=control-api label
- DeleteServerAsync throws if server is Helm-managed
- DeleteServerAsync explicitly deletes services after deployments
- KubernetesDiscoveryService sets IsDynamic based on managed-by label
  </verify>
  <done>DeleteServerAsync prevents deletion of Helm-managed servers and explicitly cleans up services. Discovery service distinguishes dynamic from static servers.</done>
</task>

</tasks>

<verification>
1. `dotnet build src/FileSimulator.ControlApi` succeeds
2. CreateSftpServerAsync:
   - Uses atmoz/sftp image
   - Passes user:pass:uid:gid as Args
   - Mounts /home/{username}/data
3. CreateNasServerAsync:
   - Uses erichough/nfs-server image
   - Resolves "input", "output", "backup" to standard directories
   - Uses SubPath on shared PVC
4. DeleteServerAsync:
   - Rejects Helm-managed servers
   - Deletes deployment with Foreground propagation
   - Explicitly deletes services
5. DiscoveryService sets IsDynamic from managed-by label
</verification>

<success_criteria>
- All three server types can be created dynamically
- Static servers protected from deletion (CONTEXT.md: "Managed by Helm" badge)
- Services explicitly deleted (RESEARCH.md pitfall: no cascade)
- NAS uses subdirectory isolation (RESEARCH.md open question resolution)
</success_criteria>

<output>
After completion, create `.planning/phases/11-dynamic-server-management/11-03-SUMMARY.md`
</output>
