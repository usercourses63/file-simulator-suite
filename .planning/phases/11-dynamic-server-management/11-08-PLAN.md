---
phase: 11-dynamic-server-management
plan: 08
type: execute
wave: 3
depends_on: ["11-05"]
files_modified:
  - src/dashboard/src/hooks/useConfigExport.ts
  - src/dashboard/src/components/ImportConfigDialog.tsx
  - src/dashboard/src/components/ImportConfigDialog.css
  - src/dashboard/src/components/SettingsPanel.tsx
  - src/dashboard/src/components/SettingsPanel.css
  - src/dashboard/src/App.tsx
  - src/dashboard/src/App.css
autonomous: true

must_haves:
  truths:
    - "Export downloads JSON file with all servers"
    - "Import accepts JSON file upload"
    - "Import shows each conflicting server individually for user decision"
    - "User chooses skip/replace/rename per conflict (not global strategy)"
    - "Import preview shows what will be created vs conflicts"
    - "Settings panel contains export/import buttons"
  artifacts:
    - path: "src/dashboard/src/hooks/useConfigExport.ts"
      provides: "Export/import API calls and file handling"
      min_lines: 60
    - path: "src/dashboard/src/components/ImportConfigDialog.tsx"
      provides: "Import wizard with per-conflict resolution"
      min_lines: 120
    - path: "src/dashboard/src/components/SettingsPanel.tsx"
      provides: "Settings area with export/import"
      min_lines: 40
  key_links:
    - from: "useConfigExport"
      to: "/api/configuration"
      via: "fetch calls"
      pattern: "api/configuration"
    - from: "ImportConfigDialog"
      to: "useConfigExport"
      via: "hook usage"
      pattern: "useConfigExport"
---

<objective>
Implement configuration export/import UI with per-conflict resolution dialog.

Purpose: Enable users to backup and replicate test environments by exporting/importing configuration JSON files. IMPORTANT: User decision requires asking about EACH conflicting server individually, not a global strategy.
Output: Export hook, import dialog with per-conflict interactive resolution, settings panel.
</objective>

<execution_context>
@C:\Users\UserC\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\UserC\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/11-dynamic-server-management/11-CONTEXT.md
@.planning/phases/11-dynamic-server-management/11-RESEARCH.md

# Types defined earlier
@src/dashboard/src/types/serverManagement.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create useConfigExport hook with per-conflict import</name>
  <files>src/dashboard/src/hooks/useConfigExport.ts</files>
  <action>
Create src/dashboard/src/hooks/useConfigExport.ts:

```typescript
import { useState, useCallback } from 'react';
import {
  ServerConfigurationExport,
  ImportResult,
  ConflictResolution,
  ServerConfiguration
} from '../types/serverManagement';

interface UseConfigExportOptions {
  apiBaseUrl: string;
}

// Conflict detection result
export interface ConflictInfo {
  serverName: string;
  protocol: string;
  existingNodePort?: number;
  importNodePort?: number;
}

export interface ImportValidation {
  willCreate: ServerConfiguration[];
  conflicts: ConflictInfo[];
}

interface UseConfigExportReturn {
  // State
  isExporting: boolean;
  isImporting: boolean;
  isValidating: boolean;
  error: string | null;
  validation: ImportValidation | null;
  importResult: ImportResult | null;

  // Actions
  exportConfig: () => Promise<void>;
  previewConfig: () => Promise<ServerConfigurationExport | null>;
  validateImport: (config: ServerConfigurationExport) => Promise<ImportValidation>;
  importWithResolutions: (config: ServerConfigurationExport, resolutions: ConflictResolution[]) => Promise<ImportResult>;
  importFile: (file: File) => Promise<{ config: ServerConfigurationExport; validation: ImportValidation }>;
  clearError: () => void;
  clearResults: () => void;
}

export function useConfigExport({ apiBaseUrl }: UseConfigExportOptions): UseConfigExportReturn {
  const [isExporting, setIsExporting] = useState(false);
  const [isImporting, setIsImporting] = useState(false);
  const [isValidating, setIsValidating] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [validation, setValidation] = useState<ImportValidation | null>(null);
  const [importResult, setImportResult] = useState<ImportResult | null>(null);

  // Export configuration as file download
  const exportConfig = useCallback(async () => {
    setIsExporting(true);
    setError(null);

    try {
      const response = await fetch(`${apiBaseUrl}/api/configuration/export`);

      if (!response.ok) {
        throw new Error('Failed to export configuration');
      }

      // Get filename from Content-Disposition header or generate one
      const contentDisposition = response.headers.get('Content-Disposition');
      let filename = `file-simulator-config-${new Date().toISOString().slice(0, 10)}.json`;
      if (contentDisposition) {
        const match = contentDisposition.match(/filename="?([^"]+)"?/);
        if (match) filename = match[1];
      }

      // Download the file
      const blob = await response.blob();
      const url = window.URL.createObjectURL(blob);
      const link = document.createElement('a');
      link.href = url;
      link.download = filename;
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
      window.URL.revokeObjectURL(url);
    } catch (err) {
      const message = err instanceof Error ? err.message : 'Export failed';
      setError(message);
      throw err;
    } finally {
      setIsExporting(false);
    }
  }, [apiBaseUrl]);

  // Preview configuration (get as JSON, not file)
  const previewConfig = useCallback(async (): Promise<ServerConfigurationExport | null> => {
    try {
      const response = await fetch(`${apiBaseUrl}/api/configuration/preview`);
      if (!response.ok) {
        throw new Error('Failed to get configuration preview');
      }
      return response.json();
    } catch (err) {
      const message = err instanceof Error ? err.message : 'Preview failed';
      setError(message);
      return null;
    }
  }, [apiBaseUrl]);

  // Validate import and identify conflicts
  const validateImport = useCallback(async (config: ServerConfigurationExport): Promise<ImportValidation> => {
    setIsValidating(true);
    setError(null);
    setValidation(null);

    try {
      const response = await fetch(`${apiBaseUrl}/api/configuration/validate`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(config)
      });

      if (!response.ok) {
        const data = await response.json();
        throw new Error(data.error || 'Validation failed');
      }

      const result = await response.json() as ImportValidation;
      setValidation(result);
      return result;
    } catch (err) {
      const message = err instanceof Error ? err.message : 'Validation failed';
      setError(message);
      throw err;
    } finally {
      setIsValidating(false);
    }
  }, [apiBaseUrl]);

  // Import configuration with per-conflict resolutions
  // This is the key method - user provides resolution for EACH conflict individually
  const importWithResolutions = useCallback(async (
    config: ServerConfigurationExport,
    resolutions: ConflictResolution[]
  ): Promise<ImportResult> => {
    setIsImporting(true);
    setError(null);
    setImportResult(null);

    try {
      const response = await fetch(`${apiBaseUrl}/api/configuration/import`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          configuration: config,
          resolutions  // Per-conflict resolutions, not a single global strategy
        })
      });

      if (!response.ok && response.status !== 207) {
        const data = await response.json();
        throw new Error(data.error || 'Import failed');
      }

      const result = await response.json() as ImportResult;
      setImportResult(result);
      return result;
    } catch (err) {
      const message = err instanceof Error ? err.message : 'Import failed';
      setError(message);
      throw err;
    } finally {
      setIsImporting(false);
    }
  }, [apiBaseUrl]);

  // Read and validate file
  const importFile = useCallback(async (
    file: File
  ): Promise<{ config: ServerConfigurationExport; validation: ImportValidation }> => {
    setError(null);

    try {
      // Read and parse file
      const text = await file.text();
      const config = JSON.parse(text) as ServerConfigurationExport;

      // Validate structure
      if (!config.version || !config.servers) {
        throw new Error('Invalid configuration file format');
      }

      // Validate to detect conflicts
      const validationResult = await validateImport(config);

      return { config, validation: validationResult };
    } catch (err) {
      const message = err instanceof Error ? err.message : 'Import failed';
      setError(message);
      throw err;
    }
  }, [validateImport]);

  const clearError = useCallback(() => setError(null), []);
  const clearResults = useCallback(() => {
    setValidation(null);
    setImportResult(null);
  }, []);

  return {
    isExporting,
    isImporting,
    isValidating,
    error,
    validation,
    importResult,
    exportConfig,
    previewConfig,
    validateImport,
    importWithResolutions,
    importFile,
    clearError,
    clearResults
  };
}

export default useConfigExport;
```
  </action>
  <verify>
- File exists at src/dashboard/src/hooks/useConfigExport.ts
- Export triggers file download
- validateImport returns conflicts list
- importWithResolutions accepts array of ConflictResolution (one per conflict)
- No global strategy parameter - resolutions are per-server
  </verify>
  <done>useConfigExport hook with export file download, conflict detection, and per-conflict resolution import.</done>
</task>

<task type="auto">
  <name>Task 2: Create ImportConfigDialog with per-conflict resolution UI</name>
  <files>
src/dashboard/src/components/ImportConfigDialog.tsx
src/dashboard/src/components/ImportConfigDialog.css
  </files>
  <action>
1. Create src/dashboard/src/components/ImportConfigDialog.tsx:

CRITICAL: This implements per-conflict resolution as specified in CONTEXT.md.
User is asked about EACH conflicting server individually, not a global strategy.

```tsx
import { useState, useRef } from 'react';
import { useConfigExport, ConflictInfo, ImportValidation } from '../hooks/useConfigExport';
import {
  ServerConfigurationExport,
  ConflictResolution,
  ImportResult
} from '../types/serverManagement';
import './ImportConfigDialog.css';

interface ImportConfigDialogProps {
  isOpen: boolean;
  onClose: () => void;
  onImported: () => void;
  apiBaseUrl: string;
}

type ImportStep = 'select-file' | 'review-conflicts' | 'importing' | 'complete';

// Per-conflict resolution state
interface ConflictDecision {
  serverName: string;
  action: 'skip' | 'replace' | 'rename';
  newName: string;  // Only used if action === 'rename'
}

export function ImportConfigDialog({
  isOpen,
  onClose,
  onImported,
  apiBaseUrl
}: ImportConfigDialogProps) {
  const {
    isImporting,
    isValidating,
    error,
    validation,
    importResult,
    importWithResolutions,
    importFile,
    clearError,
    clearResults
  } = useConfigExport({ apiBaseUrl });

  const [step, setStep] = useState<ImportStep>('select-file');
  const [selectedFile, setSelectedFile] = useState<File | null>(null);
  const [parsedConfig, setParsedConfig] = useState<ServerConfigurationExport | null>(null);
  const fileInputRef = useRef<HTMLInputElement>(null);

  // Per-conflict decisions - key is serverName
  const [conflictDecisions, setConflictDecisions] = useState<Map<string, ConflictDecision>>(new Map());

  // Current conflict index being resolved (for stepping through conflicts)
  const [currentConflictIndex, setCurrentConflictIndex] = useState(0);

  const handleFileSelect = async (e: React.ChangeEvent<HTMLInputElement>) => {
    const file = e.target.files?.[0];
    if (!file) return;

    try {
      setSelectedFile(file);
      const { config, validation } = await importFile(file);
      setParsedConfig(config);

      // If there are conflicts, initialize decisions and go to conflict resolution
      if (validation.conflicts.length > 0) {
        const initialDecisions = new Map<string, ConflictDecision>();
        validation.conflicts.forEach(conflict => {
          initialDecisions.set(conflict.serverName, {
            serverName: conflict.serverName,
            action: 'skip',  // Default to skip
            newName: `${conflict.serverName}-imported`
          });
        });
        setConflictDecisions(initialDecisions);
        setCurrentConflictIndex(0);
        setStep('review-conflicts');
      } else {
        // No conflicts - go straight to import
        await handleImportNoConflicts(config);
      }
    } catch (err) {
      // Error displayed in dialog
    }
  };

  const handleImportNoConflicts = async (config: ServerConfigurationExport) => {
    setStep('importing');
    try {
      await importWithResolutions(config, []);
      setStep('complete');
    } catch {
      setStep('select-file');
    }
  };

  // Update decision for a specific conflict
  const updateConflictDecision = (serverName: string, action: 'skip' | 'replace' | 'rename', newName?: string) => {
    setConflictDecisions(prev => {
      const next = new Map(prev);
      const current = next.get(serverName)!;
      next.set(serverName, {
        ...current,
        action,
        newName: newName ?? current.newName
      });
      return next;
    });
  };

  // Proceed to next conflict or start import
  const handleNextConflict = () => {
    if (!validation) return;

    if (currentConflictIndex < validation.conflicts.length - 1) {
      setCurrentConflictIndex(currentConflictIndex + 1);
    } else {
      // All conflicts reviewed - start import
      handleStartImport();
    }
  };

  // Go back to previous conflict
  const handlePrevConflict = () => {
    if (currentConflictIndex > 0) {
      setCurrentConflictIndex(currentConflictIndex - 1);
    }
  };

  const handleStartImport = async () => {
    if (!parsedConfig) return;

    setStep('importing');

    // Convert decisions map to array of ConflictResolution
    const resolutions: ConflictResolution[] = Array.from(conflictDecisions.values()).map(d => ({
      serverName: d.serverName,
      action: d.action,
      newName: d.action === 'rename' ? d.newName : undefined
    }));

    try {
      await importWithResolutions(parsedConfig, resolutions);
      setStep('complete');
    } catch {
      setStep('review-conflicts');
    }
  };

  const handleClose = () => {
    setStep('select-file');
    setSelectedFile(null);
    setParsedConfig(null);
    setConflictDecisions(new Map());
    setCurrentConflictIndex(0);
    clearError();
    clearResults();
    onClose();
  };

  const handleDone = () => {
    handleClose();
    onImported();
  };

  if (!isOpen) return null;

  // Get current conflict for resolution
  const currentConflict = validation?.conflicts[currentConflictIndex];
  const currentDecision = currentConflict ? conflictDecisions.get(currentConflict.serverName) : undefined;

  const renderStepContent = () => {
    switch (step) {
      case 'select-file':
        return (
          <div className="import-step-content">
            <div
              className="file-drop-zone"
              onClick={() => fileInputRef.current?.click()}
            >
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                <path d="M21 15v4a2 2 0 01-2 2H5a2 2 0 01-2-2v-4M17 8l-5-5-5 5M12 3v12" />
              </svg>
              <p>Click to select a configuration file</p>
              <span className="file-hint">or drag and drop .json file</span>
            </div>
            <input
              ref={fileInputRef}
              type="file"
              accept=".json"
              onChange={handleFileSelect}
              style={{ display: 'none' }}
            />
            {isValidating && (
              <div className="validating-indicator">
                <div className="spinner"></div>
                <span>Analyzing configuration...</span>
              </div>
            )}
          </div>
        );

      case 'review-conflicts':
        if (!validation || !currentConflict || !currentDecision) return null;

        return (
          <div className="import-step-content">
            {/* File summary */}
            <div className="file-summary">
              <strong>{selectedFile?.name}</strong>
              <span className="summary-stats">
                {validation.willCreate.length} new, {validation.conflicts.length} conflicts
              </span>
            </div>

            {/* Progress indicator */}
            <div className="conflict-progress">
              <span>Conflict {currentConflictIndex + 1} of {validation.conflicts.length}</span>
              <div className="progress-bar">
                <div
                  className="progress-fill"
                  style={{ width: `${((currentConflictIndex + 1) / validation.conflicts.length) * 100}%` }}
                />
              </div>
            </div>

            {/* Current conflict card */}
            <div className="conflict-card">
              <div className="conflict-header">
                <span className="conflict-icon">!</span>
                <div className="conflict-info">
                  <strong>{currentConflict.serverName}</strong>
                  <span className="conflict-protocol">{currentConflict.protocol}</span>
                </div>
              </div>

              <p className="conflict-description">
                A server named <strong>{currentConflict.serverName}</strong> already exists.
                {currentConflict.existingNodePort && (
                  <> Currently on port {currentConflict.existingNodePort}.</>
                )}
              </p>

              {/* Per-conflict resolution options */}
              <div className="resolution-options">
                <label className={`resolution-option ${currentDecision.action === 'skip' ? 'selected' : ''}`}>
                  <input
                    type="radio"
                    name="resolution"
                    checked={currentDecision.action === 'skip'}
                    onChange={() => updateConflictDecision(currentConflict.serverName, 'skip')}
                  />
                  <div className="option-content">
                    <strong>Skip</strong>
                    <span>Keep existing server, don't import this one</span>
                  </div>
                </label>

                <label className={`resolution-option ${currentDecision.action === 'replace' ? 'selected' : ''}`}>
                  <input
                    type="radio"
                    name="resolution"
                    checked={currentDecision.action === 'replace'}
                    onChange={() => updateConflictDecision(currentConflict.serverName, 'replace')}
                  />
                  <div className="option-content">
                    <strong>Replace</strong>
                    <span>Delete existing server, import this one</span>
                  </div>
                </label>

                <label className={`resolution-option ${currentDecision.action === 'rename' ? 'selected' : ''}`}>
                  <input
                    type="radio"
                    name="resolution"
                    checked={currentDecision.action === 'rename'}
                    onChange={() => updateConflictDecision(currentConflict.serverName, 'rename')}
                  />
                  <div className="option-content">
                    <strong>Rename</strong>
                    <span>Import with a different name</span>
                  </div>
                </label>

                {currentDecision.action === 'rename' && (
                  <div className="rename-input">
                    <label>New name:</label>
                    <input
                      type="text"
                      value={currentDecision.newName}
                      onChange={e => updateConflictDecision(
                        currentConflict.serverName,
                        'rename',
                        e.target.value.toLowerCase().replace(/[^a-z0-9-]/g, '-')
                      )}
                      placeholder="my-server-imported"
                    />
                  </div>
                )}
              </div>
            </div>

            {/* Quick summary of all decisions */}
            <div className="decisions-summary">
              <strong>Your decisions:</strong>
              <div className="decision-list">
                {Array.from(conflictDecisions.entries()).map(([name, decision], idx) => (
                  <span
                    key={name}
                    className={`decision-badge decision-badge--${decision.action} ${idx === currentConflictIndex ? 'current' : ''}`}
                    onClick={() => setCurrentConflictIndex(idx)}
                  >
                    {name}: {decision.action}
                  </span>
                ))}
              </div>
            </div>

            {error && <div className="error-message">{error}</div>}
          </div>
        );

      case 'importing':
        return (
          <div className="import-step-content import-step-content--centered">
            <div className="import-spinner"></div>
            <p>Importing configuration...</p>
          </div>
        );

      case 'complete':
        return (
          <div className="import-step-content">
            <div className="import-complete">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                <path d="M22 11.08V12a10 10 0 11-5.93-9.14" />
                <path d="M22 4L12 14.01l-3-3" />
              </svg>
              <h3>Import Complete</h3>
            </div>

            {importResult && (
              <div className="import-results">
                {importResult.created.length > 0 && (
                  <div className="result-section result-section--success">
                    <strong>Created ({importResult.created.length}):</strong>
                    <div className="result-items">
                      {importResult.created.map(name => (
                        <span key={name}>{name}</span>
                      ))}
                    </div>
                  </div>
                )}

                {importResult.skipped.length > 0 && (
                  <div className="result-section result-section--skipped">
                    <strong>Skipped ({importResult.skipped.length}):</strong>
                    <div className="result-items">
                      {importResult.skipped.map(name => (
                        <span key={name}>{name}</span>
                      ))}
                    </div>
                  </div>
                )}

                {Object.keys(importResult.failed).length > 0 && (
                  <div className="result-section result-section--error">
                    <strong>Failed ({Object.keys(importResult.failed).length}):</strong>
                    <div className="result-items">
                      {Object.entries(importResult.failed).map(([name, error]) => (
                        <span key={name} title={error}>{name}</span>
                      ))}
                    </div>
                  </div>
                )}
              </div>
            )}
          </div>
        );
    }
  };

  return (
    <div className="modal-overlay" onClick={handleClose}>
      <div className="import-config-dialog" onClick={e => e.stopPropagation()}>
        <div className="modal-header">
          <h2>Import Configuration</h2>
          <button type="button" className="modal-close" onClick={handleClose}>&times;</button>
        </div>

        <div className="modal-body">
          {renderStepContent()}
        </div>

        <div className="modal-footer">
          {step === 'select-file' && (
            <button type="button" className="btn btn--secondary" onClick={handleClose}>
              Cancel
            </button>
          )}

          {step === 'review-conflicts' && validation && (
            <>
              <button
                type="button"
                className="btn btn--secondary"
                onClick={handlePrevConflict}
                disabled={currentConflictIndex === 0}
              >
                Previous
              </button>
              <button
                type="button"
                className="btn btn--primary"
                onClick={handleNextConflict}
                disabled={isImporting}
              >
                {currentConflictIndex < validation.conflicts.length - 1 ? 'Next' : 'Import'}
              </button>
            </>
          )}

          {step === 'complete' && (
            <button type="button" className="btn btn--primary" onClick={handleDone}>
              Done
            </button>
          )}
        </div>
      </div>
    </div>
  );
}

export default ImportConfigDialog;
```

2. Create src/dashboard/src/components/ImportConfigDialog.css:

```css
.import-config-dialog {
  background: var(--bg-primary);
  border-radius: 8px;
  width: 520px;
  max-width: 95vw;
  max-height: 90vh;
  display: flex;
  flex-direction: column;
}

.import-step-content {
  min-height: 300px;
}

.import-step-content--centered {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
}

/* File Drop Zone */
.file-drop-zone {
  border: 2px dashed var(--border-color);
  border-radius: 8px;
  padding: 40px;
  text-align: center;
  cursor: pointer;
  transition: all 0.2s;
}

.file-drop-zone:hover {
  border-color: var(--accent-color);
  background: rgba(59, 130, 246, 0.05);
}

.file-drop-zone svg {
  width: 48px;
  height: 48px;
  color: var(--text-secondary);
  margin-bottom: 16px;
}

.file-drop-zone p {
  margin: 0 0 8px;
  font-weight: 500;
}

.file-hint {
  color: var(--text-secondary);
  font-size: 13px;
}

.validating-indicator {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 12px;
  margin-top: 24px;
  color: var(--text-secondary);
}

.spinner {
  width: 20px;
  height: 20px;
  border: 2px solid var(--border-color);
  border-top-color: var(--accent-color);
  border-radius: 50%;
  animation: spin 1s linear infinite;
}

/* File Summary */
.file-summary {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 12px;
  background: var(--bg-secondary);
  border-radius: 6px;
  margin-bottom: 16px;
}

.summary-stats {
  color: var(--text-secondary);
  font-size: 13px;
}

/* Conflict Progress */
.conflict-progress {
  margin-bottom: 16px;
}

.conflict-progress span {
  display: block;
  margin-bottom: 8px;
  font-size: 13px;
  color: var(--text-secondary);
}

.progress-bar {
  height: 4px;
  background: var(--bg-secondary);
  border-radius: 2px;
  overflow: hidden;
}

.progress-fill {
  height: 100%;
  background: var(--accent-color);
  transition: width 0.3s ease;
}

/* Conflict Card */
.conflict-card {
  background: var(--bg-secondary);
  border-radius: 8px;
  padding: 16px;
  margin-bottom: 16px;
}

.conflict-header {
  display: flex;
  align-items: center;
  gap: 12px;
  margin-bottom: 12px;
}

.conflict-icon {
  width: 32px;
  height: 32px;
  display: flex;
  align-items: center;
  justify-content: center;
  background: rgba(245, 158, 11, 0.2);
  color: #f59e0b;
  border-radius: 50%;
  font-weight: bold;
}

.conflict-info strong {
  display: block;
}

.conflict-protocol {
  font-size: 12px;
  color: var(--text-secondary);
  text-transform: uppercase;
}

.conflict-description {
  margin: 0 0 16px;
  color: var(--text-secondary);
  font-size: 14px;
}

/* Resolution Options */
.resolution-options {
  display: flex;
  flex-direction: column;
  gap: 8px;
}

.resolution-option {
  display: flex;
  align-items: flex-start;
  gap: 12px;
  padding: 12px;
  border: 2px solid var(--border-color);
  border-radius: 6px;
  cursor: pointer;
  transition: all 0.2s;
}

.resolution-option:hover {
  border-color: var(--accent-color);
}

.resolution-option.selected {
  border-color: var(--accent-color);
  background: rgba(59, 130, 246, 0.05);
}

.resolution-option input {
  margin-top: 4px;
}

.option-content {
  flex: 1;
}

.option-content strong {
  display: block;
  margin-bottom: 2px;
}

.option-content span {
  font-size: 13px;
  color: var(--text-secondary);
}

/* Rename Input */
.rename-input {
  margin-top: 12px;
  padding: 12px;
  background: var(--bg-primary);
  border-radius: 4px;
}

.rename-input label {
  display: block;
  margin-bottom: 6px;
  font-size: 13px;
  color: var(--text-secondary);
}

.rename-input input {
  width: 100%;
  padding: 8px 12px;
  border: 1px solid var(--border-color);
  border-radius: 4px;
  background: var(--bg-secondary);
  color: var(--text-primary);
  font-family: monospace;
}

/* Decisions Summary */
.decisions-summary {
  margin-top: 16px;
  padding-top: 16px;
  border-top: 1px solid var(--border-color);
}

.decisions-summary strong {
  display: block;
  margin-bottom: 8px;
  font-size: 13px;
  color: var(--text-secondary);
}

.decision-list {
  display: flex;
  flex-wrap: wrap;
  gap: 6px;
}

.decision-badge {
  padding: 4px 8px;
  border-radius: 4px;
  font-size: 11px;
  cursor: pointer;
  transition: all 0.2s;
}

.decision-badge.current {
  outline: 2px solid var(--accent-color);
  outline-offset: 2px;
}

.decision-badge--skip {
  background: rgba(107, 114, 128, 0.2);
  color: #6b7280;
}

.decision-badge--replace {
  background: rgba(239, 68, 68, 0.2);
  color: #ef4444;
}

.decision-badge--rename {
  background: rgba(59, 130, 246, 0.2);
  color: #3b82f6;
}

/* Import Spinner */
.import-spinner {
  width: 48px;
  height: 48px;
  border: 4px solid var(--border-color);
  border-top-color: var(--accent-color);
  border-radius: 50%;
  animation: spin 1s linear infinite;
  margin-bottom: 16px;
}

@keyframes spin {
  to { transform: rotate(360deg); }
}

/* Import Complete */
.import-complete {
  text-align: center;
  margin-bottom: 20px;
}

.import-complete svg {
  width: 64px;
  height: 64px;
  color: var(--success-color);
  margin-bottom: 12px;
}

.import-complete h3 {
  margin: 0;
  color: var(--success-color);
}

/* Import Results */
.import-results {
  background: var(--bg-secondary);
  padding: 16px;
  border-radius: 8px;
}

.result-section {
  margin-bottom: 12px;
}

.result-section:last-child {
  margin-bottom: 0;
}

.result-items {
  display: flex;
  flex-wrap: wrap;
  gap: 6px;
  margin-top: 6px;
}

.result-items span {
  background: var(--bg-primary);
  padding: 4px 8px;
  border-radius: 4px;
  font-size: 12px;
}

.result-section--success strong {
  color: var(--success-color);
}

.result-section--skipped strong {
  color: var(--text-secondary);
}

.result-section--error strong {
  color: var(--error-color);
}

/* Error Message */
.error-message {
  margin-top: 16px;
  padding: 12px;
  background: rgba(239, 68, 68, 0.1);
  border-radius: 6px;
  color: var(--error-color);
  font-size: 14px;
}
```
  </action>
  <verify>
- ImportConfigDialog shows file selection first
- After file validation, shows per-conflict resolution UI
- User steps through each conflict individually
- Each conflict has skip/replace/rename options
- Rename shows text input for new name
- Progress indicator shows conflict X of Y
- Decision summary shows all choices with click-to-edit
- Next/Previous navigation between conflicts
- Import only starts after all conflicts resolved
  </verify>
  <done>ImportConfigDialog with per-conflict interactive resolution per CONTEXT.md decision.</done>
</task>

<task type="auto">
  <name>Task 3: Create SettingsPanel and integrate in App</name>
  <files>
src/dashboard/src/components/SettingsPanel.tsx
src/dashboard/src/components/SettingsPanel.css
src/dashboard/src/App.tsx
  </files>
  <action>
1. Create src/dashboard/src/components/SettingsPanel.tsx:

```tsx
import { useConfigExport } from '../hooks/useConfigExport';
import './SettingsPanel.css';

interface SettingsPanelProps {
  isOpen: boolean;
  onClose: () => void;
  onImport: () => void;
  apiBaseUrl: string;
}

export function SettingsPanel({
  isOpen,
  onClose,
  onImport,
  apiBaseUrl
}: SettingsPanelProps) {
  const { exportConfig, isExporting, error } = useConfigExport({ apiBaseUrl });

  if (!isOpen) return null;

  const handleExport = async () => {
    try {
      await exportConfig();
    } catch {
      // Error already handled by hook
    }
  };

  return (
    <div className="settings-panel-overlay" onClick={onClose}>
      <div className="settings-panel" onClick={e => e.stopPropagation()}>
        <div className="settings-header">
          <h2>Settings</h2>
          <button type="button" className="modal-close" onClick={onClose}>&times;</button>
        </div>

        <div className="settings-content">
          <section className="settings-section">
            <h3>Configuration</h3>
            <p className="settings-description">
              Export your current simulator configuration or import a saved configuration file.
            </p>

            <div className="settings-actions">
              <button
                type="button"
                className="btn btn--secondary"
                onClick={handleExport}
                disabled={isExporting}
              >
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                  <path d="M21 15v4a2 2 0 01-2 2H5a2 2 0 01-2-2v-4M7 10l5 5 5-5M12 15V3" />
                </svg>
                {isExporting ? 'Exporting...' : 'Export Configuration'}
              </button>

              <button
                type="button"
                className="btn btn--secondary"
                onClick={onImport}
              >
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                  <path d="M21 15v4a2 2 0 01-2 2H5a2 2 0 01-2-2v-4M17 8l-5-5-5 5M12 3v12" />
                </svg>
                Import Configuration
              </button>
            </div>

            {error && <div className="settings-error">{error}</div>}

            <p className="settings-note">
              <strong>Note:</strong> Exported files contain server credentials.
              Keep them secure.
            </p>
          </section>

          <section className="settings-section">
            <h3>About</h3>
            <div className="about-info">
              <p><strong>File Simulator Suite</strong></p>
              <p>Version 2.0</p>
              <p className="about-description">
                Multi-protocol file server simulator for Kubernetes development environments.
              </p>
            </div>
          </section>
        </div>
      </div>
    </div>
  );
}

export default SettingsPanel;
```

2. Create src/dashboard/src/components/SettingsPanel.css (same as original)

3. Update App.tsx to add Settings button and integrate panels:

Add imports:
```tsx
import SettingsPanel from './components/SettingsPanel';
import ImportConfigDialog from './components/ImportConfigDialog';
```

Add state:
```tsx
const [showSettings, setShowSettings] = useState(false);
const [showImportDialog, setShowImportDialog] = useState(false);
```

Add settings button in header (after the Add Server button):
```tsx
<button
  className="header-settings-btn"
  onClick={() => setShowSettings(true)}
  title="Settings"
>
  <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
    <circle cx="12" cy="12" r="3" />
    <path d="M19.4 15a1.65 1.65 0 00.33 1.82l.06.06a2 2 0 010 2.83 2 2 0 01-2.83 0l-.06-.06a1.65 1.65 0 00-1.82-.33 1.65 1.65 0 00-1 1.51V21a2 2 0 01-2 2 2 2 0 01-2-2v-.09A1.65 1.65 0 009 19.4a1.65 1.65 0 00-1.82.33l-.06.06a2 2 0 01-2.83 0 2 2 0 010-2.83l.06-.06a1.65 1.65 0 00.33-1.82 1.65 1.65 0 00-1.51-1H3a2 2 0 01-2-2 2 2 0 012-2h.09A1.65 1.65 0 004.6 9a1.65 1.65 0 00-.33-1.82l-.06-.06a2 2 0 010-2.83 2 2 0 012.83 0l.06.06a1.65 1.65 0 001.82.33H9a1.65 1.65 0 001-1.51V3a2 2 0 012-2 2 2 0 012 2v.09a1.65 1.65 0 001 1.51 1.65 1.65 0 001.82-.33l.06-.06a2 2 0 012.83 0 2 2 0 010 2.83l-.06.06a1.65 1.65 0 00-.33 1.82V9a1.65 1.65 0 001.51 1H21a2 2 0 012 2 2 2 0 01-2 2h-.09a1.65 1.65 0 00-1.51 1z" />
  </svg>
</button>
```

Add panels at end of component:
```tsx
<SettingsPanel
  isOpen={showSettings}
  onClose={() => setShowSettings(false)}
  onImport={() => {
    setShowSettings(false);
    setShowImportDialog(true);
  }}
  apiBaseUrl={apiBaseUrl}
/>

<ImportConfigDialog
  isOpen={showImportDialog}
  onClose={() => setShowImportDialog(false)}
  onImported={() => {
    // SignalR will push updates
  }}
  apiBaseUrl={apiBaseUrl}
/>
```

4. Add styles to App.css (same as original)
  </action>
  <verify>
- SettingsPanel has Export and Import buttons
- Settings opens as slide-in panel
- Import opens dialog from settings
- Export downloads JSON file
  </verify>
  <done>SettingsPanel with export/import buttons, integrated with App. Export downloads file, Import opens per-conflict dialog.</done>
</task>

</tasks>

<verification>
1. `npm run build` in dashboard succeeds
2. Export button downloads JSON file
3. Import wizard: file select -> per-conflict resolution -> confirm -> results
4. Each conflict asks user individually (skip/replace/rename)
5. Rename option shows text input for new name
6. Settings panel slides in from right
</verification>

<success_criteria>
- Export includes ALL servers (CFG-01)
- Import accepts JSON file (CFG-02)
- Import conflict handling: ask user per conflict (CONTEXT.md) - NOT global strategy
- User chooses skip, replace, or rename for EACH conflicting server individually
- NodePort preservation with auto-assign on conflict (CONTEXT.md)
- Export/Import in settings area (CONTEXT.md)
</success_criteria>

<output>
After completion, create `.planning/phases/11-dynamic-server-management/11-08-SUMMARY.md`
</output>
