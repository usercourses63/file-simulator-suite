---
phase: 11-dynamic-server-management
plan: 04
type: execute
wave: 2
depends_on: ["11-02"]
files_modified:
  - src/FileSimulator.ControlApi/Services/KubernetesManagementService.cs
  - src/FileSimulator.ControlApi/Services/ConfigMapUpdateService.cs
  - src/FileSimulator.ControlApi/Controllers/ServersController.cs
  - src/FileSimulator.ControlApi/Program.cs
autonomous: true

must_haves:
  truths:
    - "ConfigMap updates when servers are added or removed"
    - "ConfigMap updates when servers are stopped or started"
    - "Stop scales deployment to 0 replicas"
    - "Start scales deployment to 1 replica"
    - "Restart deletes pod to force recreation"
    - "REST endpoints exist for all server operations"
  artifacts:
    - path: "src/FileSimulator.ControlApi/Services/ConfigMapUpdateService.cs"
      provides: "ConfigMap service discovery updates"
      min_lines: 50
    - path: "src/FileSimulator.ControlApi/Controllers/ServersController.cs"
      provides: "REST API for server CRUD and lifecycle"
      exports: ["POST /api/servers/{protocol}", "DELETE /api/servers/{name}"]
  key_links:
    - from: "KubernetesManagementService"
      to: "ConfigMapUpdateService"
      via: "UpdateConfigMapAsync call after create/delete/stop/start"
      pattern: "UpdateConfigMapAsync"
    - from: "ServersController"
      to: "IKubernetesManagementService"
      via: "dependency injection"
      pattern: "IKubernetesManagementService"
---

<objective>
Implement ConfigMap updates for service discovery and server lifecycle operations (start/stop/restart), plus REST API endpoints.

Purpose: Applications discover servers via ConfigMap. Lifecycle operations enable debugging without deletion. REST endpoints expose all operations to frontend.
Output: ConfigMapUpdateService, lifecycle implementations, ServersController with all endpoints.
</objective>

<execution_context>
@C:\Users\UserC\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\UserC\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/11-dynamic-server-management/11-RESEARCH.md

# Prior plans for context
@.planning/phases/11-dynamic-server-management/11-02-SUMMARY.md
@.planning/phases/11-dynamic-server-management/11-03-SUMMARY.md

# Existing discovery service
@src/FileSimulator.ControlApi/Services/IKubernetesDiscoveryService.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create ConfigMapUpdateService and implement lifecycle operations</name>
  <files>
src/FileSimulator.ControlApi/Services/ConfigMapUpdateService.cs
src/FileSimulator.ControlApi/Services/KubernetesManagementService.cs
src/FileSimulator.ControlApi/Program.cs
  </files>
  <action>
1. Create Services/ConfigMapUpdateService.cs:

```csharp
namespace FileSimulator.ControlApi.Services;

using k8s;
using k8s.Models;
using Microsoft.Extensions.Logging;

/// <summary>
/// Updates ConfigMap with current server endpoints for service discovery.
/// Applications read this ConfigMap to discover available protocol servers.
/// </summary>
public interface IConfigMapUpdateService
{
    /// <summary>
    /// Refresh the service discovery ConfigMap with current server list.
    /// Called after create/delete operations.
    /// </summary>
    Task UpdateConfigMapAsync(CancellationToken ct = default);
}

public class ConfigMapUpdateService : IConfigMapUpdateService
{
    private readonly IKubernetes _client;
    private readonly IKubernetesDiscoveryService _discoveryService;
    private readonly ILogger<ConfigMapUpdateService> _logger;
    private readonly string _namespace;
    private readonly string _configMapName;

    public ConfigMapUpdateService(
        IKubernetes client,
        IKubernetesDiscoveryService discoveryService,
        ILogger<ConfigMapUpdateService> logger,
        IConfiguration configuration)
    {
        _client = client;
        _discoveryService = discoveryService;
        _logger = logger;
        _namespace = configuration["Kubernetes:Namespace"] ?? "file-simulator";
        var releasePrefix = configuration["Kubernetes:ReleasePrefix"] ?? "file-sim-file-simulator";
        _configMapName = configuration["Kubernetes:EndpointsConfigMap"] ?? $"{releasePrefix}-endpoints";
    }

    public async Task UpdateConfigMapAsync(CancellationToken ct = default)
    {
        _logger.LogDebug("Updating service discovery ConfigMap {Name}", _configMapName);

        // 1. Discover all current servers
        var servers = await _discoveryService.DiscoverServersAsync(ct);

        // 2. Build ConfigMap data
        var configData = new Dictionary<string, string>();

        foreach (var server in servers)
        {
            // Format: PROTOCOL_INSTANCE=service.namespace.svc.cluster.local:port
            var key = $"{server.Protocol}_{server.Name}".Replace("-", "_").ToUpper();
            var clusterAddress = $"{server.ServiceName}.{_namespace}.svc.cluster.local:{server.Port}";
            configData[key] = clusterAddress;

            // Also add NodePort for external access
            if (server.NodePort.HasValue)
            {
                var nodePortKey = $"{key}_NODEPORT";
                configData[nodePortKey] = server.NodePort.Value.ToString();
            }
        }

        // Add metadata
        configData["UPDATED_AT"] = DateTime.UtcNow.ToString("O");
        configData["SERVER_COUNT"] = servers.Count.ToString();

        // 3. Update or create ConfigMap
        try
        {
            var existingConfigMap = await _client.CoreV1.ReadNamespacedConfigMapAsync(
                _configMapName,
                _namespace,
                cancellationToken: ct);

            existingConfigMap.Data = configData;

            await _client.CoreV1.ReplaceNamespacedConfigMapAsync(
                existingConfigMap,
                _configMapName,
                _namespace,
                cancellationToken: ct);

            _logger.LogInformation("Updated ConfigMap {Name} with {Count} servers",
                _configMapName, servers.Count);
        }
        catch (k8s.Autorest.HttpOperationException ex) when (ex.Response.StatusCode == System.Net.HttpStatusCode.NotFound)
        {
            // Create new ConfigMap if it doesn't exist
            var configMap = new V1ConfigMap
            {
                Metadata = new V1ObjectMeta
                {
                    Name = _configMapName,
                    NamespaceProperty = _namespace,
                    Labels = new Dictionary<string, string>
                    {
                        ["app.kubernetes.io/name"] = "file-simulator",
                        ["app.kubernetes.io/component"] = "service-discovery",
                        ["app.kubernetes.io/managed-by"] = "control-api"
                    }
                },
                Data = configData
            };

            await _client.CoreV1.CreateNamespacedConfigMapAsync(
                configMap,
                _namespace,
                cancellationToken: ct);

            _logger.LogInformation("Created ConfigMap {Name} with {Count} servers",
                _configMapName, servers.Count);
        }
    }
}
```

2. Implement lifecycle operations in KubernetesManagementService:

```csharp
public async Task StopServerAsync(string serverName, CancellationToken ct = default)
{
    _logger.LogInformation("Stopping server {ServerName}", serverName);

    var labelSelector = $"app.kubernetes.io/instance={serverName}";
    var deployments = await _client.AppsV1.ListNamespacedDeploymentAsync(
        _namespace,
        labelSelector: labelSelector,
        cancellationToken: ct);

    foreach (var deployment in deployments.Items)
    {
        // Scale to 0 replicas
        var patch = new V1Deployment
        {
            Spec = new V1DeploymentSpec { Replicas = 0 }
        };

        await _client.AppsV1.PatchNamespacedDeploymentScaleAsync(
            new V1Scale { Spec = new V1ScaleSpec { Replicas = 0 } },
            deployment.Metadata.Name,
            _namespace,
            cancellationToken: ct);

        _logger.LogInformation("Scaled {Deployment} to 0 replicas", deployment.Metadata.Name);
    }

    // Update ConfigMap to reflect server is stopped (removed from discovery)
    await _configMapService.UpdateConfigMapAsync(ct);
}

public async Task StartServerAsync(string serverName, CancellationToken ct = default)
{
    _logger.LogInformation("Starting server {ServerName}", serverName);

    var labelSelector = $"app.kubernetes.io/instance={serverName}";
    var deployments = await _client.AppsV1.ListNamespacedDeploymentAsync(
        _namespace,
        labelSelector: labelSelector,
        cancellationToken: ct);

    foreach (var deployment in deployments.Items)
    {
        // Scale to 1 replica
        await _client.AppsV1.PatchNamespacedDeploymentScaleAsync(
            new V1Scale { Spec = new V1ScaleSpec { Replicas = 1 } },
            deployment.Metadata.Name,
            _namespace,
            cancellationToken: ct);

        _logger.LogInformation("Scaled {Deployment} to 1 replica", deployment.Metadata.Name);
    }

    // Update ConfigMap to reflect server is available again
    await _configMapService.UpdateConfigMapAsync(ct);
}

public async Task RestartServerAsync(string serverName, CancellationToken ct = default)
{
    _logger.LogInformation("Restarting server {ServerName}", serverName);

    var labelSelector = $"app.kubernetes.io/instance={serverName}";

    // Delete pods - deployment will recreate them
    var pods = await _client.CoreV1.ListNamespacedPodAsync(
        _namespace,
        labelSelector: labelSelector,
        cancellationToken: ct);

    foreach (var pod in pods.Items)
    {
        await _client.CoreV1.DeleteNamespacedPodAsync(
            pod.Metadata.Name,
            _namespace,
            gracePeriodSeconds: 5,
            cancellationToken: ct);

        _logger.LogInformation("Deleted pod {Pod} for restart", pod.Metadata.Name);
    }

    // Update ConfigMap - server temporarily unavailable during restart
    await _configMapService.UpdateConfigMapAsync(ct);
}
```

3. Inject ConfigMapUpdateService into KubernetesManagementService and call after create/delete:

Add to constructor:
```csharp
private readonly IConfigMapUpdateService _configMapService;

// In constructor
_configMapService = configMapService;
```

Add at end of CreateFtpServerAsync, CreateSftpServerAsync, CreateNasServerAsync:
```csharp
// Update service discovery
await _configMapService.UpdateConfigMapAsync(ct);
```

Add at end of DeleteServerAsync:
```csharp
// Update service discovery
await _configMapService.UpdateConfigMapAsync(ct);
```

4. Register in Program.cs:
```csharp
builder.Services.AddSingleton<IConfigMapUpdateService, ConfigMapUpdateService>();
```

Note: ConfigMapUpdateService must be registered BEFORE KubernetesManagementService due to dependency order.
  </action>
  <verify>
- `dotnet build src/FileSimulator.ControlApi` compiles
- ConfigMapUpdateService creates/updates ConfigMap with server endpoints
- StopServerAsync scales to 0 replicas AND calls UpdateConfigMapAsync
- StartServerAsync scales to 1 replica AND calls UpdateConfigMapAsync
- RestartServerAsync deletes pods AND calls UpdateConfigMapAsync
- Create and delete operations call UpdateConfigMapAsync
  </verify>
  <done>ConfigMap updates on all server lifecycle changes (create/delete/stop/start/restart). Start/stop/restart operations implemented with ConfigMap sync.</done>
</task>

<task type="auto">
  <name>Task 2: Create ServersController REST API</name>
  <files>
src/FileSimulator.ControlApi/Controllers/ServersController.cs
src/FileSimulator.ControlApi/Program.cs
  </files>
  <action>
1. Create Controllers/ServersController.cs:

```csharp
namespace FileSimulator.ControlApi.Controllers;

using Microsoft.AspNetCore.Mvc;
using FluentValidation;
using FileSimulator.ControlApi.Models;
using FileSimulator.ControlApi.Services;

[ApiController]
[Route("api/[controller]")]
public class ServersController : ControllerBase
{
    private readonly IKubernetesManagementService _managementService;
    private readonly IKubernetesDiscoveryService _discoveryService;
    private readonly ILogger<ServersController> _logger;

    public ServersController(
        IKubernetesManagementService managementService,
        IKubernetesDiscoveryService discoveryService,
        ILogger<ServersController> logger)
    {
        _managementService = managementService;
        _discoveryService = discoveryService;
        _logger = logger;
    }

    /// <summary>
    /// List all servers (static and dynamic).
    /// </summary>
    [HttpGet]
    public async Task<ActionResult<IReadOnlyList<DiscoveredServer>>> GetServers(CancellationToken ct)
    {
        var servers = await _discoveryService.DiscoverServersAsync(ct);
        return Ok(servers);
    }

    /// <summary>
    /// Get a specific server by name.
    /// </summary>
    [HttpGet("{name}")]
    public async Task<ActionResult<DiscoveredServer>> GetServer(string name, CancellationToken ct)
    {
        var server = await _discoveryService.GetServerAsync(name, ct);
        if (server == null)
            return NotFound(new { error = $"Server '{name}' not found" });
        return Ok(server);
    }

    /// <summary>
    /// Create a new FTP server.
    /// </summary>
    [HttpPost("ftp")]
    public async Task<ActionResult<DiscoveredServer>> CreateFtpServer(
        [FromBody] CreateFtpServerRequest request,
        [FromServices] IValidator<CreateFtpServerRequest> validator,
        CancellationToken ct)
    {
        var validation = await validator.ValidateAsync(request, ct);
        if (!validation.IsValid)
            return BadRequest(new { errors = validation.ToDictionary() });

        if (!await _managementService.IsServerNameAvailableAsync(request.Name, ct))
            return Conflict(new { error = $"Server name '{request.Name}' is already in use" });

        try
        {
            var server = await _managementService.CreateFtpServerAsync(request, ct);
            return CreatedAtAction(nameof(GetServer), new { name = server.Name }, server);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Failed to create FTP server {Name}", request.Name);
            return StatusCode(500, new { error = "Failed to create server", details = ex.Message });
        }
    }

    /// <summary>
    /// Create a new SFTP server.
    /// </summary>
    [HttpPost("sftp")]
    public async Task<ActionResult<DiscoveredServer>> CreateSftpServer(
        [FromBody] CreateSftpServerRequest request,
        [FromServices] IValidator<CreateSftpServerRequest> validator,
        CancellationToken ct)
    {
        var validation = await validator.ValidateAsync(request, ct);
        if (!validation.IsValid)
            return BadRequest(new { errors = validation.ToDictionary() });

        if (!await _managementService.IsServerNameAvailableAsync(request.Name, ct))
            return Conflict(new { error = $"Server name '{request.Name}' is already in use" });

        try
        {
            var server = await _managementService.CreateSftpServerAsync(request, ct);
            return CreatedAtAction(nameof(GetServer), new { name = server.Name }, server);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Failed to create SFTP server {Name}", request.Name);
            return StatusCode(500, new { error = "Failed to create server", details = ex.Message });
        }
    }

    /// <summary>
    /// Create a new NAS server.
    /// </summary>
    [HttpPost("nas")]
    public async Task<ActionResult<DiscoveredServer>> CreateNasServer(
        [FromBody] CreateNasServerRequest request,
        [FromServices] IValidator<CreateNasServerRequest> validator,
        CancellationToken ct)
    {
        var validation = await validator.ValidateAsync(request, ct);
        if (!validation.IsValid)
            return BadRequest(new { errors = validation.ToDictionary() });

        if (!await _managementService.IsServerNameAvailableAsync(request.Name, ct))
            return Conflict(new { error = $"Server name '{request.Name}' is already in use" });

        try
        {
            var server = await _managementService.CreateNasServerAsync(request, ct);
            return CreatedAtAction(nameof(GetServer), new { name = server.Name }, server);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Failed to create NAS server {Name}", request.Name);
            return StatusCode(500, new { error = "Failed to create server", details = ex.Message });
        }
    }

    /// <summary>
    /// Delete a dynamic server.
    /// </summary>
    [HttpDelete("{name}")]
    public async Task<ActionResult> DeleteServer(
        string name,
        [FromQuery] bool deleteData = false,
        CancellationToken ct = default)
    {
        try
        {
            await _managementService.DeleteServerAsync(name, deleteData, ct);
            return NoContent();
        }
        catch (InvalidOperationException ex)
        {
            return BadRequest(new { error = ex.Message });
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Failed to delete server {Name}", name);
            return StatusCode(500, new { error = "Failed to delete server", details = ex.Message });
        }
    }

    /// <summary>
    /// Stop a server (scale to 0).
    /// </summary>
    [HttpPost("{name}/stop")]
    public async Task<ActionResult> StopServer(string name, CancellationToken ct)
    {
        try
        {
            await _managementService.StopServerAsync(name, ct);
            return Ok(new { message = $"Server '{name}' stopped" });
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Failed to stop server {Name}", name);
            return StatusCode(500, new { error = "Failed to stop server", details = ex.Message });
        }
    }

    /// <summary>
    /// Start a stopped server (scale to 1).
    /// </summary>
    [HttpPost("{name}/start")]
    public async Task<ActionResult> StartServer(string name, CancellationToken ct)
    {
        try
        {
            await _managementService.StartServerAsync(name, ct);
            return Ok(new { message = $"Server '{name}' started" });
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Failed to start server {Name}", name);
            return StatusCode(500, new { error = "Failed to start server", details = ex.Message });
        }
    }

    /// <summary>
    /// Restart a server (delete pod to recreate).
    /// </summary>
    [HttpPost("{name}/restart")]
    public async Task<ActionResult> RestartServer(string name, CancellationToken ct)
    {
        try
        {
            await _managementService.RestartServerAsync(name, ct);
            return Ok(new { message = $"Server '{name}' restarting" });
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Failed to restart server {Name}", name);
            return StatusCode(500, new { error = "Failed to restart server", details = ex.Message });
        }
    }

    /// <summary>
    /// Check if a server name is available.
    /// </summary>
    [HttpGet("check-name/{name}")]
    public async Task<ActionResult> CheckNameAvailability(string name, CancellationToken ct)
    {
        var available = await _managementService.IsServerNameAvailableAsync(name, ct);
        return Ok(new { name, available });
    }
}
```

2. Ensure Controllers are mapped in Program.cs (should already exist for other controllers):
```csharp
app.MapControllers();
```
  </action>
  <verify>
- `dotnet build src/FileSimulator.ControlApi` compiles
- ServersController has all endpoints:
  - GET /api/servers
  - GET /api/servers/{name}
  - POST /api/servers/ftp
  - POST /api/servers/sftp
  - POST /api/servers/nas
  - DELETE /api/servers/{name}
  - POST /api/servers/{name}/stop
  - POST /api/servers/{name}/start
  - POST /api/servers/{name}/restart
  - GET /api/servers/check-name/{name}
- Validation errors return 400 with errors dictionary
- Name conflicts return 409 Conflict
  </verify>
  <done>Complete REST API for server management. Validation via FluentValidation, proper HTTP status codes, lifecycle endpoints for start/stop/restart.</done>
</task>

</tasks>

<verification>
1. `dotnet build src/FileSimulator.ControlApi` succeeds
2. ConfigMapUpdateService updates ConfigMap with:
   - PROTOCOL_INSTANCE=cluster-dns:port format
   - PROTOCOL_INSTANCE_NODEPORT=port format
   - UPDATED_AT and SERVER_COUNT metadata
3. Lifecycle operations:
   - Stop: scales replicas to 0 AND updates ConfigMap
   - Start: scales replicas to 1 AND updates ConfigMap
   - Restart: deletes pods AND updates ConfigMap
4. ServersController endpoints return proper status codes
5. Create operations trigger ConfigMap update
</verification>

<success_criteria>
- ConfigMap updates after server add/remove (CTRL-06)
- ConfigMap updates after server stop/start/restart (KEY LINK)
- Start/stop/restart individual servers (CTRL-07)
- REST API enables frontend integration
- Validation prevents invalid configurations (CTRL-09)
</success_criteria>

<output>
After completion, create `.planning/phases/11-dynamic-server-management/11-04-SUMMARY.md`
</output>
