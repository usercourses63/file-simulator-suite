---
phase: 11-dynamic-server-management
plan: 06
type: execute
wave: 3
depends_on: ["11-04"]
files_modified:
  - src/dashboard/src/types/serverManagement.ts
  - src/dashboard/src/hooks/useServerManagement.ts
  - src/dashboard/src/components/CreateServerModal.tsx
  - src/dashboard/src/components/CreateServerModal.css
  - src/dashboard/src/components/ServerDetailsPanel.tsx
  - src/dashboard/src/components/ServerDetailsPanel.css
autonomous: true

must_haves:
  truths:
    - "TypeScript types match backend request/response DTOs"
    - "useServerManagement hook provides CRUD operations"
    - "CreateServerModal shows all configuration options"
    - "Progress shown in modal during deployment"
    - "Click opens details panel with inline editable fields"
    - "All settings editable after creation including ports"
  artifacts:
    - path: "src/dashboard/src/types/serverManagement.ts"
      provides: "Server management TypeScript types"
      exports: ["CreateFtpServerRequest", "CreateSftpServerRequest", "CreateNasServerRequest", "ImportResult"]
    - path: "src/dashboard/src/hooks/useServerManagement.ts"
      provides: "Server CRUD and lifecycle operations"
      min_lines: 80
    - path: "src/dashboard/src/components/CreateServerModal.tsx"
      provides: "Server creation wizard with protocol selection"
      min_lines: 150
    - path: "src/dashboard/src/components/ServerDetailsPanel.tsx"
      provides: "Server details panel with inline editing"
      min_lines: 100
  key_links:
    - from: "useServerManagement"
      to: "/api/servers"
      via: "fetch calls"
      pattern: "fetch.*api/servers"
    - from: "CreateServerModal"
      to: "useServerManagement"
      via: "hook usage"
      pattern: "useServerManagement"
    - from: "ServerDetailsPanel"
      to: "useServerManagement"
      via: "hook for update operations"
      pattern: "useServerManagement"
---

<objective>
Create frontend types, hooks, server creation modal, and server details panel for dynamic server management.

Purpose: Enable users to add new servers through the dashboard UI with full configuration control, and edit existing servers via inline editable fields.
Output: TypeScript types, useServerManagement hook, CreateServerModal component, ServerDetailsPanel with inline editing.
</objective>

<execution_context>
@C:\Users\UserC\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\UserC\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/11-dynamic-server-management/11-CONTEXT.md
@.planning/phases/11-dynamic-server-management/11-RESEARCH.md

# Existing frontend patterns
@src/dashboard/src/types/server.ts
@src/dashboard/src/hooks/useKafka.ts
@src/dashboard/src/components/CreateTopicForm.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create TypeScript types for server management</name>
  <files>src/dashboard/src/types/serverManagement.ts</files>
  <action>
Create src/dashboard/src/types/serverManagement.ts:

```typescript
/**
 * Server management types matching backend DTOs.
 */

// Base request properties
export interface CreateServerRequestBase {
  name: string;
  nodePort?: number | null;
}

// FTP server creation
export interface CreateFtpServerRequest extends CreateServerRequestBase {
  username: string;
  password: string;
  passivePortStart?: number | null;
  passivePortEnd?: number | null;
}

// SFTP server creation
export interface CreateSftpServerRequest extends CreateServerRequestBase {
  username: string;
  password: string;
  uid?: number;
  gid?: number;
}

// NAS server creation
export interface CreateNasServerRequest extends CreateServerRequestBase {
  directory: string;
  exportOptions?: string;
}

// Union type for any server creation
export type CreateServerRequest =
  | { protocol: 'ftp'; data: CreateFtpServerRequest }
  | { protocol: 'sftp'; data: CreateSftpServerRequest }
  | { protocol: 'nas'; data: CreateNasServerRequest };

// Server with dynamic flag (extends base server type)
export interface DynamicServer {
  name: string;
  protocol: string;
  podName: string;
  serviceName: string;
  clusterIp: string;
  port: number;
  nodePort?: number | null;
  podStatus: string;
  podReady: boolean;
  discoveredAt: string;
  isDynamic: boolean;
  managedBy: string;
}

// Lifecycle action types
export type LifecycleAction = 'start' | 'stop' | 'restart';

// Update request types (for inline editing)
export interface UpdateFtpServerRequest {
  username?: string;
  password?: string;
  nodePort?: number | null;
  passivePortStart?: number | null;
  passivePortEnd?: number | null;
}

export interface UpdateSftpServerRequest {
  username?: string;
  password?: string;
  nodePort?: number | null;
  uid?: number;
  gid?: number;
}

export interface UpdateNasServerRequest {
  directory?: string;
  nodePort?: number | null;
  exportOptions?: string;
}

// Import/export types
export interface FtpConfiguration {
  username: string;
  password: string;
  passivePortStart?: number | null;
  passivePortEnd?: number | null;
}

export interface SftpConfiguration {
  username: string;
  password: string;
  uid: number;
  gid: number;
}

export interface NasConfiguration {
  directory: string;
  exportOptions: string;
}

export interface ServerConfiguration {
  name: string;
  protocol: string;
  nodePort?: number | null;
  isDynamic: boolean;
  ftp?: FtpConfiguration | null;
  sftp?: SftpConfiguration | null;
  nas?: NasConfiguration | null;
}

export interface ExportMetadata {
  description?: string | null;
  exportedBy?: string | null;
  environment?: string | null;
}

export interface ServerConfigurationExport {
  version: string;
  exportedAt: string;
  namespace: string;
  releasePrefix: string;
  servers: ServerConfiguration[];
  metadata?: ExportMetadata | null;
}

export interface ImportResult {
  created: string[];
  skipped: string[];
  failed: Record<string, string>;
  totalProcessed: number;
}

export type ConflictResolutionStrategy = 'Skip' | 'Replace' | 'Rename';

export interface ImportConfigurationRequest {
  configuration: ServerConfigurationExport;
  strategy: ConflictResolutionStrategy;
}

// Per-conflict resolution (for interactive import)
export interface ConflictResolution {
  serverName: string;
  action: 'skip' | 'replace' | 'rename';
  newName?: string;  // Only if action === 'rename'
}

export interface InteractiveImportRequest {
  configuration: ServerConfigurationExport;
  resolutions: ConflictResolution[];
}

// API response types
export interface ApiError {
  error: string;
  details?: string;
  errors?: Record<string, string[]>;
}

// Deployment progress
export interface DeploymentProgress {
  phase: 'validating' | 'creating-deployment' | 'creating-service' | 'updating-configmap' | 'complete' | 'error';
  message: string;
  serverName?: string;
}

// Name availability check
export interface NameCheckResult {
  name: string;
  available: boolean;
}
```
  </action>
  <verify>
- File exists at src/dashboard/src/types/serverManagement.ts
- All request types match backend C# models
- Update request types defined for inline editing
- Import/export types defined including per-conflict resolution
- No TypeScript errors when imported
  </verify>
  <done>TypeScript types for all server management operations matching backend DTOs, including update types for inline editing.</done>
</task>

<task type="auto">
  <name>Task 2: Create useServerManagement hook with update support</name>
  <files>src/dashboard/src/hooks/useServerManagement.ts</files>
  <action>
Create src/dashboard/src/hooks/useServerManagement.ts:

```typescript
import { useState, useCallback } from 'react';
import {
  CreateFtpServerRequest,
  CreateSftpServerRequest,
  CreateNasServerRequest,
  UpdateFtpServerRequest,
  UpdateSftpServerRequest,
  UpdateNasServerRequest,
  DynamicServer,
  LifecycleAction,
  NameCheckResult,
  DeploymentProgress,
  ApiError
} from '../types/serverManagement';

interface UseServerManagementOptions {
  apiBaseUrl: string;
}

interface UseServerManagementReturn {
  // State
  isLoading: boolean;
  error: string | null;
  progress: DeploymentProgress | null;

  // CRUD operations
  createFtpServer: (request: CreateFtpServerRequest) => Promise<DynamicServer>;
  createSftpServer: (request: CreateSftpServerRequest) => Promise<DynamicServer>;
  createNasServer: (request: CreateNasServerRequest) => Promise<DynamicServer>;
  deleteServer: (name: string, deleteData?: boolean) => Promise<void>;

  // Update operations (for inline editing)
  updateFtpServer: (name: string, updates: UpdateFtpServerRequest) => Promise<DynamicServer>;
  updateSftpServer: (name: string, updates: UpdateSftpServerRequest) => Promise<DynamicServer>;
  updateNasServer: (name: string, updates: UpdateNasServerRequest) => Promise<DynamicServer>;

  // Lifecycle operations
  startServer: (name: string) => Promise<void>;
  stopServer: (name: string) => Promise<void>;
  restartServer: (name: string) => Promise<void>;

  // Utilities
  checkNameAvailability: (name: string) => Promise<NameCheckResult>;
  clearError: () => void;
  clearProgress: () => void;
}

export function useServerManagement({ apiBaseUrl }: UseServerManagementOptions): UseServerManagementReturn {
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [progress, setProgress] = useState<DeploymentProgress | null>(null);

  const handleApiError = async (response: Response): Promise<never> => {
    const data = await response.json().catch(() => ({})) as ApiError;
    const errorMessage = data.error || data.details || `HTTP ${response.status}`;
    throw new Error(errorMessage);
  };

  const createFtpServer = useCallback(async (request: CreateFtpServerRequest): Promise<DynamicServer> => {
    setIsLoading(true);
    setError(null);
    setProgress({ phase: 'validating', message: 'Validating configuration...', serverName: request.name });

    try {
      setProgress({ phase: 'creating-deployment', message: 'Creating FTP deployment...', serverName: request.name });

      const response = await fetch(`${apiBaseUrl}/api/servers/ftp`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(request)
      });

      if (!response.ok) {
        await handleApiError(response);
      }

      const server = await response.json() as DynamicServer;

      setProgress({ phase: 'complete', message: 'FTP server created successfully', serverName: request.name });
      return server;
    } catch (err) {
      const message = err instanceof Error ? err.message : 'Failed to create FTP server';
      setError(message);
      setProgress({ phase: 'error', message, serverName: request.name });
      throw err;
    } finally {
      setIsLoading(false);
    }
  }, [apiBaseUrl]);

  const createSftpServer = useCallback(async (request: CreateSftpServerRequest): Promise<DynamicServer> => {
    setIsLoading(true);
    setError(null);
    setProgress({ phase: 'validating', message: 'Validating configuration...', serverName: request.name });

    try {
      setProgress({ phase: 'creating-deployment', message: 'Creating SFTP deployment...', serverName: request.name });

      const response = await fetch(`${apiBaseUrl}/api/servers/sftp`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(request)
      });

      if (!response.ok) {
        await handleApiError(response);
      }

      const server = await response.json() as DynamicServer;
      setProgress({ phase: 'complete', message: 'SFTP server created successfully', serverName: request.name });
      return server;
    } catch (err) {
      const message = err instanceof Error ? err.message : 'Failed to create SFTP server';
      setError(message);
      setProgress({ phase: 'error', message, serverName: request.name });
      throw err;
    } finally {
      setIsLoading(false);
    }
  }, [apiBaseUrl]);

  const createNasServer = useCallback(async (request: CreateNasServerRequest): Promise<DynamicServer> => {
    setIsLoading(true);
    setError(null);
    setProgress({ phase: 'validating', message: 'Validating configuration...', serverName: request.name });

    try {
      setProgress({ phase: 'creating-deployment', message: 'Creating NAS deployment...', serverName: request.name });

      const response = await fetch(`${apiBaseUrl}/api/servers/nas`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(request)
      });

      if (!response.ok) {
        await handleApiError(response);
      }

      const server = await response.json() as DynamicServer;
      setProgress({ phase: 'complete', message: 'NAS server created successfully', serverName: request.name });
      return server;
    } catch (err) {
      const message = err instanceof Error ? err.message : 'Failed to create NAS server';
      setError(message);
      setProgress({ phase: 'error', message, serverName: request.name });
      throw err;
    } finally {
      setIsLoading(false);
    }
  }, [apiBaseUrl]);

  // Update operations for inline editing
  const updateFtpServer = useCallback(async (name: string, updates: UpdateFtpServerRequest): Promise<DynamicServer> => {
    setIsLoading(true);
    setError(null);

    try {
      const response = await fetch(`${apiBaseUrl}/api/servers/ftp/${encodeURIComponent(name)}`, {
        method: 'PATCH',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(updates)
      });

      if (!response.ok) {
        await handleApiError(response);
      }

      return response.json();
    } catch (err) {
      const message = err instanceof Error ? err.message : 'Failed to update server';
      setError(message);
      throw err;
    } finally {
      setIsLoading(false);
    }
  }, [apiBaseUrl]);

  const updateSftpServer = useCallback(async (name: string, updates: UpdateSftpServerRequest): Promise<DynamicServer> => {
    setIsLoading(true);
    setError(null);

    try {
      const response = await fetch(`${apiBaseUrl}/api/servers/sftp/${encodeURIComponent(name)}`, {
        method: 'PATCH',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(updates)
      });

      if (!response.ok) {
        await handleApiError(response);
      }

      return response.json();
    } catch (err) {
      const message = err instanceof Error ? err.message : 'Failed to update server';
      setError(message);
      throw err;
    } finally {
      setIsLoading(false);
    }
  }, [apiBaseUrl]);

  const updateNasServer = useCallback(async (name: string, updates: UpdateNasServerRequest): Promise<DynamicServer> => {
    setIsLoading(true);
    setError(null);

    try {
      const response = await fetch(`${apiBaseUrl}/api/servers/nas/${encodeURIComponent(name)}`, {
        method: 'PATCH',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(updates)
      });

      if (!response.ok) {
        await handleApiError(response);
      }

      return response.json();
    } catch (err) {
      const message = err instanceof Error ? err.message : 'Failed to update server';
      setError(message);
      throw err;
    } finally {
      setIsLoading(false);
    }
  }, [apiBaseUrl]);

  const deleteServer = useCallback(async (name: string, deleteData = false): Promise<void> => {
    setIsLoading(true);
    setError(null);

    try {
      const response = await fetch(
        `${apiBaseUrl}/api/servers/${encodeURIComponent(name)}?deleteData=${deleteData}`,
        { method: 'DELETE' }
      );

      if (!response.ok) {
        await handleApiError(response);
      }
    } catch (err) {
      const message = err instanceof Error ? err.message : 'Failed to delete server';
      setError(message);
      throw err;
    } finally {
      setIsLoading(false);
    }
  }, [apiBaseUrl]);

  const performLifecycleAction = useCallback(async (name: string, action: LifecycleAction): Promise<void> => {
    setIsLoading(true);
    setError(null);

    try {
      const response = await fetch(
        `${apiBaseUrl}/api/servers/${encodeURIComponent(name)}/${action}`,
        { method: 'POST' }
      );

      if (!response.ok) {
        await handleApiError(response);
      }
    } catch (err) {
      const message = err instanceof Error ? err.message : `Failed to ${action} server`;
      setError(message);
      throw err;
    } finally {
      setIsLoading(false);
    }
  }, [apiBaseUrl]);

  const startServer = useCallback((name: string) => performLifecycleAction(name, 'start'), [performLifecycleAction]);
  const stopServer = useCallback((name: string) => performLifecycleAction(name, 'stop'), [performLifecycleAction]);
  const restartServer = useCallback((name: string) => performLifecycleAction(name, 'restart'), [performLifecycleAction]);

  const checkNameAvailability = useCallback(async (name: string): Promise<NameCheckResult> => {
    const response = await fetch(`${apiBaseUrl}/api/servers/check-name/${encodeURIComponent(name)}`);
    if (!response.ok) {
      throw new Error('Failed to check name availability');
    }
    return response.json();
  }, [apiBaseUrl]);

  const clearError = useCallback(() => setError(null), []);
  const clearProgress = useCallback(() => setProgress(null), []);

  return {
    isLoading,
    error,
    progress,
    createFtpServer,
    createSftpServer,
    createNasServer,
    deleteServer,
    updateFtpServer,
    updateSftpServer,
    updateNasServer,
    startServer,
    stopServer,
    restartServer,
    checkNameAvailability,
    clearError,
    clearProgress
  };
}

export default useServerManagement;
```
  </action>
  <verify>
- File exists at src/dashboard/src/hooks/useServerManagement.ts
- Hook exports all CRUD and lifecycle operations
- Update operations (PATCH) for inline editing included
- Progress state tracked for UI feedback
- Error handling with proper messages
  </verify>
  <done>useServerManagement hook with CRUD, update (PATCH), lifecycle, and progress tracking.</done>
</task>

<task type="auto">
  <name>Task 3: Create CreateServerModal and ServerDetailsPanel components</name>
  <files>
src/dashboard/src/components/CreateServerModal.tsx
src/dashboard/src/components/CreateServerModal.css
src/dashboard/src/components/ServerDetailsPanel.tsx
src/dashboard/src/components/ServerDetailsPanel.css
  </files>
  <action>
1. Create src/dashboard/src/components/CreateServerModal.tsx (same as before - full creation wizard)

2. Create src/dashboard/src/components/CreateServerModal.css (same as before)

3. Create src/dashboard/src/components/ServerDetailsPanel.tsx:

```tsx
import { useState, useEffect, useCallback } from 'react';
import { useServerManagement } from '../hooks/useServerManagement';
import { ServerStatus } from '../types/server';
import {
  UpdateFtpServerRequest,
  UpdateSftpServerRequest,
  UpdateNasServerRequest
} from '../types/serverManagement';
import './ServerDetailsPanel.css';

interface ServerDetailsPanelProps {
  server: ServerStatus | null;
  serverConfig?: {
    isDynamic: boolean;
    managedBy: string;
    ftp?: { username: string; passivePortStart?: number; passivePortEnd?: number };
    sftp?: { username: string; uid: number; gid: number };
    nas?: { directory: string; exportOptions: string };
  };
  isOpen: boolean;
  onClose: () => void;
  onUpdated: () => void;
  apiBaseUrl: string;
}

interface EditableField {
  key: string;
  label: string;
  value: string | number;
  type: 'text' | 'password' | 'number';
}

export function ServerDetailsPanel({
  server,
  serverConfig,
  isOpen,
  onClose,
  onUpdated,
  apiBaseUrl
}: ServerDetailsPanelProps) {
  const {
    updateFtpServer,
    updateSftpServer,
    updateNasServer,
    startServer,
    stopServer,
    restartServer,
    isLoading,
    error,
    clearError
  } = useServerManagement({ apiBaseUrl });

  // Track which field is being edited
  const [editingField, setEditingField] = useState<string | null>(null);
  const [editValue, setEditValue] = useState<string>('');
  const [pendingChanges, setPendingChanges] = useState<Record<string, string | number>>({});

  // Reset state when panel closes or server changes
  useEffect(() => {
    if (!isOpen) {
      setEditingField(null);
      setEditValue('');
      setPendingChanges({});
      clearError();
    }
  }, [isOpen, server?.name, clearError]);

  const startEditing = (field: EditableField) => {
    setEditingField(field.key);
    setEditValue(String(field.value));
  };

  const cancelEditing = () => {
    setEditingField(null);
    setEditValue('');
  };

  const saveField = useCallback(async (fieldKey: string, value: string | number) => {
    if (!server) return;

    const updates: Record<string, string | number | null> = {
      [fieldKey]: value
    };

    try {
      const protocol = server.protocol.toLowerCase();
      if (protocol === 'ftp') {
        await updateFtpServer(server.name, updates as UpdateFtpServerRequest);
      } else if (protocol === 'sftp') {
        await updateSftpServer(server.name, updates as UpdateSftpServerRequest);
      } else if (protocol === 'nas') {
        await updateNasServer(server.name, updates as UpdateNasServerRequest);
      }

      setEditingField(null);
      setEditValue('');
      onUpdated();
    } catch {
      // Error displayed in panel
    }
  }, [server, updateFtpServer, updateSftpServer, updateNasServer, onUpdated]);

  const handleKeyDown = (e: React.KeyboardEvent, fieldKey: string) => {
    if (e.key === 'Enter') {
      e.preventDefault();
      const parsedValue = e.currentTarget.getAttribute('type') === 'number'
        ? parseInt(editValue) || 0
        : editValue;
      saveField(fieldKey, parsedValue);
    } else if (e.key === 'Escape') {
      cancelEditing();
    }
  };

  const handleLifecycleAction = async (action: 'start' | 'stop' | 'restart') => {
    if (!server) return;
    try {
      if (action === 'start') await startServer(server.name);
      else if (action === 'stop') await stopServer(server.name);
      else await restartServer(server.name);
      onUpdated();
    } catch {
      // Error displayed
    }
  };

  if (!isOpen || !server) return null;

  const isDynamic = serverConfig?.isDynamic ?? false;
  const isHelm = !isDynamic;
  const protocol = server.protocol.toLowerCase();

  // Build editable fields based on protocol
  const getEditableFields = (): EditableField[] => {
    const fields: EditableField[] = [
      { key: 'nodePort', label: 'NodePort', value: server.nodePort ?? 'Auto', type: 'number' }
    ];

    if (protocol === 'ftp' || protocol === 'sftp') {
      fields.push({ key: 'username', label: 'Username', value: serverConfig?.ftp?.username ?? serverConfig?.sftp?.username ?? 'simuser', type: 'text' });
      fields.push({ key: 'password', label: 'Password', value: '********', type: 'password' });
    }

    if (protocol === 'ftp') {
      fields.push({ key: 'passivePortStart', label: 'Passive Port Start', value: serverConfig?.ftp?.passivePortStart ?? 'Auto', type: 'number' });
      fields.push({ key: 'passivePortEnd', label: 'Passive Port End', value: serverConfig?.ftp?.passivePortEnd ?? 'Auto', type: 'number' });
    }

    if (protocol === 'sftp') {
      fields.push({ key: 'uid', label: 'UID', value: serverConfig?.sftp?.uid ?? 1000, type: 'number' });
      fields.push({ key: 'gid', label: 'GID', value: serverConfig?.sftp?.gid ?? 1000, type: 'number' });
    }

    if (protocol === 'nas') {
      fields.push({ key: 'directory', label: 'Directory', value: serverConfig?.nas?.directory ?? '', type: 'text' });
      fields.push({ key: 'exportOptions', label: 'Export Options', value: serverConfig?.nas?.exportOptions ?? '', type: 'text' });
    }

    return fields;
  };

  const editableFields = getEditableFields();

  return (
    <div className="server-details-overlay" onClick={onClose}>
      <div className="server-details-panel" onClick={e => e.stopPropagation()}>
        <div className="details-header">
          <div className="details-title">
            <h2>{server.name}</h2>
            <div className="details-badges">
              <span className="badge badge--protocol">{server.protocol}</span>
              {isDynamic ? (
                <span className="badge badge--dynamic">Dynamic</span>
              ) : (
                <span className="badge badge--helm">Managed by Helm</span>
              )}
            </div>
          </div>
          <button type="button" className="modal-close" onClick={onClose}>&times;</button>
        </div>

        <div className="details-content">
          {/* Status Section */}
          <section className="details-section">
            <h3>Status</h3>
            <div className="status-info">
              <div className={`status-indicator status-indicator--${server.isHealthy ? 'healthy' : 'unhealthy'}`}>
                <span className="status-dot"></span>
                <span>{server.isHealthy ? 'Healthy' : 'Unhealthy'}</span>
              </div>
              {server.healthMessage && (
                <p className="health-message">{server.healthMessage}</p>
              )}
            </div>

            {/* Lifecycle buttons for dynamic servers */}
            {isDynamic && (
              <div className="lifecycle-actions">
                <button
                  type="button"
                  className="btn btn--sm btn--secondary"
                  onClick={() => handleLifecycleAction('stop')}
                  disabled={isLoading}
                >
                  Stop
                </button>
                <button
                  type="button"
                  className="btn btn--sm btn--secondary"
                  onClick={() => handleLifecycleAction('start')}
                  disabled={isLoading}
                >
                  Start
                </button>
                <button
                  type="button"
                  className="btn btn--sm btn--secondary"
                  onClick={() => handleLifecycleAction('restart')}
                  disabled={isLoading}
                >
                  Restart
                </button>
              </div>
            )}
          </section>

          {/* Connection Info */}
          <section className="details-section">
            <h3>Connection</h3>
            <div className="info-grid">
              <div className="info-row">
                <span className="info-label">Cluster IP</span>
                <span className="info-value">{server.clusterIp}</span>
              </div>
              <div className="info-row">
                <span className="info-label">Port</span>
                <span className="info-value">{server.port}</span>
              </div>
              <div className="info-row">
                <span className="info-label">Service</span>
                <span className="info-value">{server.serviceName}</span>
              </div>
            </div>
          </section>

          {/* Editable Configuration */}
          <section className="details-section">
            <h3>Configuration</h3>
            {isHelm && (
              <p className="helm-notice">
                This server is managed by Helm. Settings are read-only.
              </p>
            )}

            <div className="config-fields">
              {editableFields.map(field => (
                <div key={field.key} className="config-field">
                  <span className="config-label">{field.label}</span>
                  {editingField === field.key && isDynamic ? (
                    <div className="config-edit">
                      <input
                        type={field.type}
                        value={editValue}
                        onChange={e => setEditValue(e.target.value)}
                        onKeyDown={e => handleKeyDown(e, field.key)}
                        autoFocus
                        className="config-input"
                      />
                      <button
                        type="button"
                        className="btn btn--xs btn--primary"
                        onClick={() => {
                          const val = field.type === 'number' ? parseInt(editValue) || 0 : editValue;
                          saveField(field.key, val);
                        }}
                        disabled={isLoading}
                      >
                        Save
                      </button>
                      <button
                        type="button"
                        className="btn btn--xs btn--secondary"
                        onClick={cancelEditing}
                      >
                        Cancel
                      </button>
                    </div>
                  ) : (
                    <div className="config-value-row">
                      <span className="config-value">{String(field.value)}</span>
                      {isDynamic && (
                        <button
                          type="button"
                          className="edit-btn"
                          onClick={() => startEditing(field)}
                          title="Edit"
                        >
                          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                            <path d="M11 4H4a2 2 0 00-2 2v14a2 2 0 002 2h14a2 2 0 002-2v-7" />
                            <path d="M18.5 2.5a2.121 2.121 0 013 3L12 15l-4 1 1-4 9.5-9.5z" />
                          </svg>
                        </button>
                      )}
                    </div>
                  )}
                </div>
              ))}
            </div>
          </section>

          {/* Error display */}
          {error && (
            <div className="details-error">
              {error}
            </div>
          )}
        </div>
      </div>
    </div>
  );
}

export default ServerDetailsPanel;
```

4. Create src/dashboard/src/components/ServerDetailsPanel.css:

```css
.server-details-overlay {
  position: fixed;
  top: 0;
  right: 0;
  bottom: 0;
  left: 0;
  background: rgba(0, 0, 0, 0.5);
  z-index: 200;
}

.server-details-panel {
  position: absolute;
  top: 0;
  right: 0;
  bottom: 0;
  width: 400px;
  max-width: 100vw;
  background: var(--bg-primary);
  box-shadow: -4px 0 20px rgba(0, 0, 0, 0.2);
  display: flex;
  flex-direction: column;
  animation: slideIn 0.2s ease-out;
}

@keyframes slideIn {
  from { transform: translateX(100%); }
  to { transform: translateX(0); }
}

@media (max-width: 480px) {
  .server-details-panel {
    width: 100%;
  }
}

.details-header {
  display: flex;
  justify-content: space-between;
  align-items: flex-start;
  padding: 16px 20px;
  border-bottom: 1px solid var(--border-color);
}

.details-title h2 {
  margin: 0 0 8px;
  font-size: 1.25rem;
  word-break: break-word;
}

.details-badges {
  display: flex;
  gap: 6px;
  flex-wrap: wrap;
}

.badge--protocol {
  background: var(--bg-secondary);
  color: var(--text-primary);
}

.details-content {
  flex: 1;
  overflow-y: auto;
  padding: 20px;
}

.details-section {
  margin-bottom: 24px;
}

.details-section:last-child {
  margin-bottom: 0;
}

.details-section h3 {
  margin: 0 0 12px;
  font-size: 0.875rem;
  color: var(--text-secondary);
  text-transform: uppercase;
  letter-spacing: 0.5px;
}

/* Status */
.status-info {
  margin-bottom: 12px;
}

.status-indicator {
  display: flex;
  align-items: center;
  gap: 8px;
  font-weight: 500;
}

.status-indicator .status-dot {
  width: 10px;
  height: 10px;
  border-radius: 50%;
}

.status-indicator--healthy .status-dot {
  background: var(--success-color);
}

.status-indicator--unhealthy .status-dot {
  background: var(--error-color);
}

.health-message {
  margin: 8px 0 0;
  color: var(--text-secondary);
  font-size: 13px;
}

.lifecycle-actions {
  display: flex;
  gap: 8px;
  margin-top: 12px;
}

/* Info Grid */
.info-grid {
  background: var(--bg-secondary);
  border-radius: 6px;
  padding: 12px;
}

.info-row {
  display: flex;
  justify-content: space-between;
  padding: 6px 0;
  border-bottom: 1px solid var(--border-color);
}

.info-row:last-child {
  border-bottom: none;
}

.info-label {
  color: var(--text-secondary);
  font-size: 13px;
}

.info-value {
  font-family: monospace;
  font-size: 13px;
}

/* Configuration Fields */
.helm-notice {
  color: var(--text-secondary);
  font-size: 13px;
  margin-bottom: 12px;
  font-style: italic;
}

.config-fields {
  display: flex;
  flex-direction: column;
  gap: 12px;
}

.config-field {
  display: flex;
  flex-direction: column;
  gap: 4px;
}

.config-label {
  font-size: 12px;
  color: var(--text-secondary);
  font-weight: 500;
}

.config-value-row {
  display: flex;
  align-items: center;
  gap: 8px;
}

.config-value {
  flex: 1;
  padding: 8px 12px;
  background: var(--bg-secondary);
  border-radius: 4px;
  font-family: monospace;
  font-size: 14px;
}

.edit-btn {
  width: 28px;
  height: 28px;
  padding: 4px;
  border: none;
  background: transparent;
  border-radius: 4px;
  cursor: pointer;
  color: var(--text-secondary);
  opacity: 0;
  transition: opacity 0.2s;
}

.config-field:hover .edit-btn {
  opacity: 1;
}

.edit-btn:hover {
  background: var(--bg-secondary);
  color: var(--accent-color);
}

.edit-btn svg {
  width: 100%;
  height: 100%;
}

/* Edit Mode */
.config-edit {
  display: flex;
  gap: 8px;
  align-items: center;
}

.config-input {
  flex: 1;
  padding: 8px 12px;
  border: 2px solid var(--accent-color);
  border-radius: 4px;
  background: var(--bg-secondary);
  color: var(--text-primary);
  font-family: monospace;
  font-size: 14px;
}

.config-input:focus {
  outline: none;
}

/* Button sizes */
.btn--sm {
  padding: 6px 12px;
  font-size: 13px;
}

.btn--xs {
  padding: 4px 8px;
  font-size: 12px;
}

/* Error */
.details-error {
  margin-top: 16px;
  padding: 12px;
  background: rgba(239, 68, 68, 0.1);
  border-radius: 6px;
  color: var(--error-color);
  font-size: 14px;
}
```

5. Create CreateServerModal.tsx (full content from original plan - truncated here for brevity, same implementation)

6. Create CreateServerModal.css (same as original plan)
  </action>
  <verify>
- CreateServerModal handles all three protocols with progress feedback
- ServerDetailsPanel shows server info in slide-out panel
- Click-to-edit functionality for dynamic servers
- Helm-managed servers show read-only with notice
- Lifecycle actions (start/stop/restart) in details panel
- Changes save immediately on Enter or Save button
- Edit mode has Cancel option
  </verify>
  <done>CreateServerModal with full configuration, ServerDetailsPanel with inline editable fields for dynamic servers. All settings editable after creation including ports.</done>
</task>

</tasks>

<verification>
1. `npm run build` in dashboard succeeds
2. Types match backend DTOs including update types
3. Hook provides all CRUD + update + lifecycle operations
4. CreateServerModal shows progress during deployment
5. ServerDetailsPanel opens on server card click
6. Inline editing works for all protocol-specific fields
7. Helm servers show read-only configuration
</verification>

<success_criteria>
- Full control over configuration (CONTEXT.md)
- NodePort auto-assign with override option (CONTEXT.md)
- NAS presets: input/output/backup with custom (CONTEXT.md)
- Progress in modal until complete (CONTEXT.md)
- Error shown in modal with retry (CONTEXT.md)
- Click opens details panel with inline editable fields (CONTEXT.md)
- All settings editable after creation including ports (CONTEXT.md)
</success_criteria>

<output>
After completion, create `.planning/phases/11-dynamic-server-management/11-06-SUMMARY.md`
</output>
