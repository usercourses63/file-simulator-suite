---
phase: 11-dynamic-server-management
plan: 06
type: execute
wave: 3
depends_on: ["11-04"]
files_modified:
  - src/dashboard/src/types/serverManagement.ts
  - src/dashboard/src/hooks/useServerManagement.ts
  - src/dashboard/src/components/CreateServerModal.tsx
  - src/dashboard/src/components/CreateServerModal.css
autonomous: true

must_haves:
  truths:
    - "TypeScript types match backend request/response DTOs"
    - "useServerManagement hook provides CRUD operations"
    - "CreateServerModal shows all configuration options"
    - "Progress shown in modal during deployment"
  artifacts:
    - path: "src/dashboard/src/types/serverManagement.ts"
      provides: "Server management TypeScript types"
      exports: ["CreateFtpServerRequest", "CreateSftpServerRequest", "CreateNasServerRequest", "ImportResult"]
    - path: "src/dashboard/src/hooks/useServerManagement.ts"
      provides: "Server CRUD and lifecycle operations"
      min_lines: 80
    - path: "src/dashboard/src/components/CreateServerModal.tsx"
      provides: "Server creation wizard with protocol selection"
      min_lines: 150
  key_links:
    - from: "useServerManagement"
      to: "/api/servers"
      via: "fetch calls"
      pattern: "fetch.*api/servers"
    - from: "CreateServerModal"
      to: "useServerManagement"
      via: "hook usage"
      pattern: "useServerManagement"
---

<objective>
Create frontend types, hooks, and server creation modal for dynamic server management.

Purpose: Enable users to add new servers through the dashboard UI with full configuration control.
Output: TypeScript types, useServerManagement hook, CreateServerModal component with progress feedback.
</objective>

<execution_context>
@C:\Users\UserC\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\UserC\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/11-dynamic-server-management/11-CONTEXT.md
@.planning/phases/11-dynamic-server-management/11-RESEARCH.md

# Existing frontend patterns
@src/dashboard/src/types/server.ts
@src/dashboard/src/hooks/useKafka.ts
@src/dashboard/src/components/CreateTopicForm.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create TypeScript types for server management</name>
  <files>src/dashboard/src/types/serverManagement.ts</files>
  <action>
Create src/dashboard/src/types/serverManagement.ts:

```typescript
/**
 * Server management types matching backend DTOs.
 */

// Base request properties
export interface CreateServerRequestBase {
  name: string;
  nodePort?: number | null;
}

// FTP server creation
export interface CreateFtpServerRequest extends CreateServerRequestBase {
  username: string;
  password: string;
  passivePortStart?: number | null;
  passivePortEnd?: number | null;
}

// SFTP server creation
export interface CreateSftpServerRequest extends CreateServerRequestBase {
  username: string;
  password: string;
  uid?: number;
  gid?: number;
}

// NAS server creation
export interface CreateNasServerRequest extends CreateServerRequestBase {
  directory: string;
  exportOptions?: string;
}

// Union type for any server creation
export type CreateServerRequest =
  | { protocol: 'ftp'; data: CreateFtpServerRequest }
  | { protocol: 'sftp'; data: CreateSftpServerRequest }
  | { protocol: 'nas'; data: CreateNasServerRequest };

// Server with dynamic flag (extends base server type)
export interface DynamicServer {
  name: string;
  protocol: string;
  podName: string;
  serviceName: string;
  clusterIp: string;
  port: number;
  nodePort?: number | null;
  podStatus: string;
  podReady: boolean;
  discoveredAt: string;
  isDynamic: boolean;
  managedBy: string;
}

// Lifecycle action types
export type LifecycleAction = 'start' | 'stop' | 'restart';

// Import/export types
export interface FtpConfiguration {
  username: string;
  password: string;
  passivePortStart?: number | null;
  passivePortEnd?: number | null;
}

export interface SftpConfiguration {
  username: string;
  password: string;
  uid: number;
  gid: number;
}

export interface NasConfiguration {
  directory: string;
  exportOptions: string;
}

export interface ServerConfiguration {
  name: string;
  protocol: string;
  nodePort?: number | null;
  isDynamic: boolean;
  ftp?: FtpConfiguration | null;
  sftp?: SftpConfiguration | null;
  nas?: NasConfiguration | null;
}

export interface ExportMetadata {
  description?: string | null;
  exportedBy?: string | null;
  environment?: string | null;
}

export interface ServerConfigurationExport {
  version: string;
  exportedAt: string;
  namespace: string;
  releasePrefix: string;
  servers: ServerConfiguration[];
  metadata?: ExportMetadata | null;
}

export interface ImportResult {
  created: string[];
  skipped: string[];
  failed: Record<string, string>;
  totalProcessed: number;
}

export type ConflictResolutionStrategy = 'Skip' | 'Replace' | 'Rename';

export interface ImportConfigurationRequest {
  configuration: ServerConfigurationExport;
  strategy: ConflictResolutionStrategy;
}

// API response types
export interface ApiError {
  error: string;
  details?: string;
  errors?: Record<string, string[]>;
}

// Deployment progress
export interface DeploymentProgress {
  phase: 'validating' | 'creating-deployment' | 'creating-service' | 'updating-configmap' | 'complete' | 'error';
  message: string;
  serverName?: string;
}

// Name availability check
export interface NameCheckResult {
  name: string;
  available: boolean;
}
```
  </action>
  <verify>
- File exists at src/dashboard/src/types/serverManagement.ts
- All request types match backend C# models
- Import/export types defined
- No TypeScript errors when imported
  </verify>
  <done>TypeScript types for all server management operations matching backend DTOs.</done>
</task>

<task type="auto">
  <name>Task 2: Create useServerManagement hook</name>
  <files>src/dashboard/src/hooks/useServerManagement.ts</files>
  <action>
Create src/dashboard/src/hooks/useServerManagement.ts:

```typescript
import { useState, useCallback } from 'react';
import {
  CreateFtpServerRequest,
  CreateSftpServerRequest,
  CreateNasServerRequest,
  DynamicServer,
  LifecycleAction,
  NameCheckResult,
  DeploymentProgress,
  ApiError
} from '../types/serverManagement';

interface UseServerManagementOptions {
  apiBaseUrl: string;
}

interface UseServerManagementReturn {
  // State
  isLoading: boolean;
  error: string | null;
  progress: DeploymentProgress | null;

  // CRUD operations
  createFtpServer: (request: CreateFtpServerRequest) => Promise<DynamicServer>;
  createSftpServer: (request: CreateSftpServerRequest) => Promise<DynamicServer>;
  createNasServer: (request: CreateNasServerRequest) => Promise<DynamicServer>;
  deleteServer: (name: string, deleteData?: boolean) => Promise<void>;

  // Lifecycle operations
  startServer: (name: string) => Promise<void>;
  stopServer: (name: string) => Promise<void>;
  restartServer: (name: string) => Promise<void>;

  // Utilities
  checkNameAvailability: (name: string) => Promise<NameCheckResult>;
  clearError: () => void;
  clearProgress: () => void;
}

export function useServerManagement({ apiBaseUrl }: UseServerManagementOptions): UseServerManagementReturn {
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [progress, setProgress] = useState<DeploymentProgress | null>(null);

  const handleApiError = async (response: Response): Promise<never> => {
    const data = await response.json().catch(() => ({})) as ApiError;
    const errorMessage = data.error || data.details || `HTTP ${response.status}`;
    throw new Error(errorMessage);
  };

  const createFtpServer = useCallback(async (request: CreateFtpServerRequest): Promise<DynamicServer> => {
    setIsLoading(true);
    setError(null);
    setProgress({ phase: 'validating', message: 'Validating configuration...', serverName: request.name });

    try {
      setProgress({ phase: 'creating-deployment', message: 'Creating FTP deployment...', serverName: request.name });

      const response = await fetch(`${apiBaseUrl}/api/servers/ftp`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(request)
      });

      if (!response.ok) {
        await handleApiError(response);
      }

      const server = await response.json() as DynamicServer;

      setProgress({ phase: 'complete', message: 'FTP server created successfully', serverName: request.name });
      return server;
    } catch (err) {
      const message = err instanceof Error ? err.message : 'Failed to create FTP server';
      setError(message);
      setProgress({ phase: 'error', message, serverName: request.name });
      throw err;
    } finally {
      setIsLoading(false);
    }
  }, [apiBaseUrl]);

  const createSftpServer = useCallback(async (request: CreateSftpServerRequest): Promise<DynamicServer> => {
    setIsLoading(true);
    setError(null);
    setProgress({ phase: 'validating', message: 'Validating configuration...', serverName: request.name });

    try {
      setProgress({ phase: 'creating-deployment', message: 'Creating SFTP deployment...', serverName: request.name });

      const response = await fetch(`${apiBaseUrl}/api/servers/sftp`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(request)
      });

      if (!response.ok) {
        await handleApiError(response);
      }

      const server = await response.json() as DynamicServer;
      setProgress({ phase: 'complete', message: 'SFTP server created successfully', serverName: request.name });
      return server;
    } catch (err) {
      const message = err instanceof Error ? err.message : 'Failed to create SFTP server';
      setError(message);
      setProgress({ phase: 'error', message, serverName: request.name });
      throw err;
    } finally {
      setIsLoading(false);
    }
  }, [apiBaseUrl]);

  const createNasServer = useCallback(async (request: CreateNasServerRequest): Promise<DynamicServer> => {
    setIsLoading(true);
    setError(null);
    setProgress({ phase: 'validating', message: 'Validating configuration...', serverName: request.name });

    try {
      setProgress({ phase: 'creating-deployment', message: 'Creating NAS deployment...', serverName: request.name });

      const response = await fetch(`${apiBaseUrl}/api/servers/nas`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(request)
      });

      if (!response.ok) {
        await handleApiError(response);
      }

      const server = await response.json() as DynamicServer;
      setProgress({ phase: 'complete', message: 'NAS server created successfully', serverName: request.name });
      return server;
    } catch (err) {
      const message = err instanceof Error ? err.message : 'Failed to create NAS server';
      setError(message);
      setProgress({ phase: 'error', message, serverName: request.name });
      throw err;
    } finally {
      setIsLoading(false);
    }
  }, [apiBaseUrl]);

  const deleteServer = useCallback(async (name: string, deleteData = false): Promise<void> => {
    setIsLoading(true);
    setError(null);

    try {
      const response = await fetch(
        `${apiBaseUrl}/api/servers/${encodeURIComponent(name)}?deleteData=${deleteData}`,
        { method: 'DELETE' }
      );

      if (!response.ok) {
        await handleApiError(response);
      }
    } catch (err) {
      const message = err instanceof Error ? err.message : 'Failed to delete server';
      setError(message);
      throw err;
    } finally {
      setIsLoading(false);
    }
  }, [apiBaseUrl]);

  const performLifecycleAction = useCallback(async (name: string, action: LifecycleAction): Promise<void> => {
    setIsLoading(true);
    setError(null);

    try {
      const response = await fetch(
        `${apiBaseUrl}/api/servers/${encodeURIComponent(name)}/${action}`,
        { method: 'POST' }
      );

      if (!response.ok) {
        await handleApiError(response);
      }
    } catch (err) {
      const message = err instanceof Error ? err.message : `Failed to ${action} server`;
      setError(message);
      throw err;
    } finally {
      setIsLoading(false);
    }
  }, [apiBaseUrl]);

  const startServer = useCallback((name: string) => performLifecycleAction(name, 'start'), [performLifecycleAction]);
  const stopServer = useCallback((name: string) => performLifecycleAction(name, 'stop'), [performLifecycleAction]);
  const restartServer = useCallback((name: string) => performLifecycleAction(name, 'restart'), [performLifecycleAction]);

  const checkNameAvailability = useCallback(async (name: string): Promise<NameCheckResult> => {
    const response = await fetch(`${apiBaseUrl}/api/servers/check-name/${encodeURIComponent(name)}`);
    if (!response.ok) {
      throw new Error('Failed to check name availability');
    }
    return response.json();
  }, [apiBaseUrl]);

  const clearError = useCallback(() => setError(null), []);
  const clearProgress = useCallback(() => setProgress(null), []);

  return {
    isLoading,
    error,
    progress,
    createFtpServer,
    createSftpServer,
    createNasServer,
    deleteServer,
    startServer,
    stopServer,
    restartServer,
    checkNameAvailability,
    clearError,
    clearProgress
  };
}

export default useServerManagement;
```
  </action>
  <verify>
- File exists at src/dashboard/src/hooks/useServerManagement.ts
- Hook exports all CRUD and lifecycle operations
- Progress state tracked for UI feedback
- Error handling with proper messages
  </verify>
  <done>useServerManagement hook with CRUD, lifecycle, and progress tracking.</done>
</task>

<task type="auto">
  <name>Task 3: Create CreateServerModal component</name>
  <files>
src/dashboard/src/components/CreateServerModal.tsx
src/dashboard/src/components/CreateServerModal.css
  </files>
  <action>
1. Create src/dashboard/src/components/CreateServerModal.tsx:

```tsx
import { useState, useEffect } from 'react';
import { useServerManagement } from '../hooks/useServerManagement';
import {
  CreateFtpServerRequest,
  CreateSftpServerRequest,
  CreateNasServerRequest,
  DeploymentProgress
} from '../types/serverManagement';
import './CreateServerModal.css';

interface CreateServerModalProps {
  isOpen: boolean;
  onClose: () => void;
  onCreated: () => void;
  apiBaseUrl: string;
}

type Protocol = 'ftp' | 'sftp' | 'nas';

const NAS_PRESETS = [
  { value: 'input', label: 'Input Directory' },
  { value: 'output', label: 'Output Directory' },
  { value: 'backup', label: 'Backup Directory' },
  { value: 'custom', label: 'Custom Path' }
];

export function CreateServerModal({ isOpen, onClose, onCreated, apiBaseUrl }: CreateServerModalProps) {
  const {
    isLoading,
    error,
    progress,
    createFtpServer,
    createSftpServer,
    createNasServer,
    checkNameAvailability,
    clearError,
    clearProgress
  } = useServerManagement({ apiBaseUrl });

  // Form state
  const [protocol, setProtocol] = useState<Protocol>('ftp');
  const [name, setName] = useState('');
  const [nameError, setNameError] = useState<string | null>(null);
  const [showAdvanced, setShowAdvanced] = useState(false);

  // Common fields
  const [nodePort, setNodePort] = useState<string>('');

  // FTP/SFTP fields
  const [username, setUsername] = useState('simuser');
  const [password, setPassword] = useState('');

  // FTP specific
  const [passivePortStart, setPassivePortStart] = useState<string>('');
  const [passivePortEnd, setPassivePortEnd] = useState<string>('');

  // SFTP specific
  const [uid, setUid] = useState<string>('1000');
  const [gid, setGid] = useState<string>('1000');

  // NAS specific
  const [nasPreset, setNasPreset] = useState<string>('input');
  const [customDirectory, setCustomDirectory] = useState('');
  const [exportOptions, setExportOptions] = useState('rw,sync,no_subtree_check,no_root_squash');

  // Reset form when closed
  useEffect(() => {
    if (!isOpen) {
      setProtocol('ftp');
      setName('');
      setNameError(null);
      setShowAdvanced(false);
      setNodePort('');
      setUsername('simuser');
      setPassword('');
      setPassivePortStart('');
      setPassivePortEnd('');
      setUid('1000');
      setGid('1000');
      setNasPreset('input');
      setCustomDirectory('');
      clearError();
      clearProgress();
    }
  }, [isOpen, clearError, clearProgress]);

  // Validate name on change
  useEffect(() => {
    const validateName = async () => {
      if (!name) {
        setNameError(null);
        return;
      }

      // Local validation
      if (!/^[a-z0-9-]+$/.test(name)) {
        setNameError('Name must be lowercase alphanumeric with hyphens only');
        return;
      }
      if (name.length < 3 || name.length > 32) {
        setNameError('Name must be 3-32 characters');
        return;
      }

      // Server-side availability check
      try {
        const result = await checkNameAvailability(name);
        if (!result.available) {
          setNameError('Name is already in use');
        } else {
          setNameError(null);
        }
      } catch {
        // Ignore check failures
      }
    };

    const debounce = setTimeout(validateName, 300);
    return () => clearTimeout(debounce);
  }, [name, checkNameAvailability]);

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();

    if (nameError || !name) return;

    try {
      switch (protocol) {
        case 'ftp': {
          const request: CreateFtpServerRequest = {
            name,
            username,
            password,
            nodePort: nodePort ? parseInt(nodePort) : null,
            passivePortStart: passivePortStart ? parseInt(passivePortStart) : null,
            passivePortEnd: passivePortEnd ? parseInt(passivePortEnd) : null
          };
          await createFtpServer(request);
          break;
        }
        case 'sftp': {
          const request: CreateSftpServerRequest = {
            name,
            username,
            password,
            nodePort: nodePort ? parseInt(nodePort) : null,
            uid: uid ? parseInt(uid) : 1000,
            gid: gid ? parseInt(gid) : 1000
          };
          await createSftpServer(request);
          break;
        }
        case 'nas': {
          const directory = nasPreset === 'custom' ? customDirectory : nasPreset;
          const request: CreateNasServerRequest = {
            name,
            directory,
            nodePort: nodePort ? parseInt(nodePort) : null,
            exportOptions: showAdvanced ? exportOptions : undefined
          };
          await createNasServer(request);
          break;
        }
      }
      onCreated();
    } catch {
      // Error already set by hook
    }
  };

  const renderProgress = () => {
    if (!progress) return null;

    const phaseLabels: Record<DeploymentProgress['phase'], string> = {
      'validating': 'Validating...',
      'creating-deployment': 'Creating deployment...',
      'creating-service': 'Creating service...',
      'updating-configmap': 'Updating service discovery...',
      'complete': 'Complete!',
      'error': 'Error'
    };

    return (
      <div className={`create-server-progress create-server-progress--${progress.phase}`}>
        {progress.phase !== 'complete' && progress.phase !== 'error' && (
          <div className="progress-spinner"></div>
        )}
        <span>{phaseLabels[progress.phase]}</span>
        {progress.phase === 'complete' && (
          <button type="button" className="btn btn--primary" onClick={onClose}>
            Done
          </button>
        )}
      </div>
    );
  };

  if (!isOpen) return null;

  const isComplete = progress?.phase === 'complete';

  return (
    <div className="modal-overlay" onClick={onClose}>
      <div className="create-server-modal" onClick={e => e.stopPropagation()}>
        <div className="modal-header">
          <h2>Add Server</h2>
          <button type="button" className="modal-close" onClick={onClose}>&times;</button>
        </div>

        {isComplete || progress?.phase === 'error' ? (
          <div className="modal-body">
            {renderProgress()}
            {error && (
              <div className="error-message">
                {error}
                <button type="button" className="btn btn--secondary" onClick={() => { clearError(); clearProgress(); }}>
                  Try Again
                </button>
              </div>
            )}
          </div>
        ) : (
          <form onSubmit={handleSubmit}>
            <div className="modal-body">
              {/* Protocol Selection */}
              <div className="form-group">
                <label>Protocol</label>
                <div className="protocol-selector">
                  {(['ftp', 'sftp', 'nas'] as Protocol[]).map(p => (
                    <button
                      key={p}
                      type="button"
                      className={`protocol-btn ${protocol === p ? 'protocol-btn--selected' : ''}`}
                      onClick={() => setProtocol(p)}
                      disabled={isLoading}
                    >
                      {p.toUpperCase()}
                    </button>
                  ))}
                </div>
              </div>

              {/* Server Name */}
              <div className="form-group">
                <label htmlFor="server-name">Server Name</label>
                <input
                  id="server-name"
                  type="text"
                  value={name}
                  onChange={e => setName(e.target.value.toLowerCase())}
                  placeholder="my-server-1"
                  disabled={isLoading}
                  className={nameError ? 'input--error' : ''}
                />
                {nameError && <span className="field-error">{nameError}</span>}
              </div>

              {/* FTP/SFTP: Username & Password */}
              {(protocol === 'ftp' || protocol === 'sftp') && (
                <>
                  <div className="form-row">
                    <div className="form-group">
                      <label htmlFor="username">Username</label>
                      <input
                        id="username"
                        type="text"
                        value={username}
                        onChange={e => setUsername(e.target.value)}
                        disabled={isLoading}
                      />
                    </div>
                    <div className="form-group">
                      <label htmlFor="password">Password</label>
                      <input
                        id="password"
                        type="password"
                        value={password}
                        onChange={e => setPassword(e.target.value)}
                        placeholder="Min 8 characters"
                        disabled={isLoading}
                      />
                    </div>
                  </div>
                </>
              )}

              {/* NAS: Directory Selection */}
              {protocol === 'nas' && (
                <div className="form-group">
                  <label>Directory</label>
                  <div className="nas-presets">
                    {NAS_PRESETS.map(preset => (
                      <label key={preset.value} className="radio-label">
                        <input
                          type="radio"
                          name="nas-preset"
                          value={preset.value}
                          checked={nasPreset === preset.value}
                          onChange={e => setNasPreset(e.target.value)}
                          disabled={isLoading}
                        />
                        {preset.label}
                      </label>
                    ))}
                  </div>
                  {nasPreset === 'custom' && (
                    <input
                      type="text"
                      value={customDirectory}
                      onChange={e => setCustomDirectory(e.target.value)}
                      placeholder="my-custom-dir"
                      disabled={isLoading}
                      className="custom-dir-input"
                    />
                  )}
                </div>
              )}

              {/* Advanced Settings Toggle */}
              <button
                type="button"
                className="advanced-toggle"
                onClick={() => setShowAdvanced(!showAdvanced)}
              >
                {showAdvanced ? '- Hide' : '+ Show'} Advanced Settings
              </button>

              {/* Advanced Settings */}
              {showAdvanced && (
                <div className="advanced-settings">
                  <div className="form-group">
                    <label htmlFor="nodeport">NodePort (optional)</label>
                    <input
                      id="nodeport"
                      type="number"
                      value={nodePort}
                      onChange={e => setNodePort(e.target.value)}
                      placeholder="Auto-assign (30000-32767)"
                      min={30000}
                      max={32767}
                      disabled={isLoading}
                    />
                  </div>

                  {protocol === 'ftp' && (
                    <div className="form-row">
                      <div className="form-group">
                        <label htmlFor="pasv-start">Passive Port Start</label>
                        <input
                          id="pasv-start"
                          type="number"
                          value={passivePortStart}
                          onChange={e => setPassivePortStart(e.target.value)}
                          min={30000}
                          max={32700}
                          disabled={isLoading}
                        />
                      </div>
                      <div className="form-group">
                        <label htmlFor="pasv-end">Passive Port End</label>
                        <input
                          id="pasv-end"
                          type="number"
                          value={passivePortEnd}
                          onChange={e => setPassivePortEnd(e.target.value)}
                          min={30000}
                          max={32767}
                          disabled={isLoading}
                        />
                      </div>
                    </div>
                  )}

                  {protocol === 'sftp' && (
                    <div className="form-row">
                      <div className="form-group">
                        <label htmlFor="uid">UID</label>
                        <input
                          id="uid"
                          type="number"
                          value={uid}
                          onChange={e => setUid(e.target.value)}
                          disabled={isLoading}
                        />
                      </div>
                      <div className="form-group">
                        <label htmlFor="gid">GID</label>
                        <input
                          id="gid"
                          type="number"
                          value={gid}
                          onChange={e => setGid(e.target.value)}
                          disabled={isLoading}
                        />
                      </div>
                    </div>
                  )}

                  {protocol === 'nas' && (
                    <div className="form-group">
                      <label htmlFor="export-options">NFS Export Options</label>
                      <input
                        id="export-options"
                        type="text"
                        value={exportOptions}
                        onChange={e => setExportOptions(e.target.value)}
                        disabled={isLoading}
                      />
                    </div>
                  )}
                </div>
              )}

              {/* Progress indicator */}
              {renderProgress()}

              {/* Error display */}
              {error && !progress && (
                <div className="error-message">{error}</div>
              )}
            </div>

            <div className="modal-footer">
              <button type="button" className="btn btn--secondary" onClick={onClose} disabled={isLoading}>
                Cancel
              </button>
              <button
                type="submit"
                className="btn btn--primary"
                disabled={isLoading || !!nameError || !name || (protocol !== 'nas' && !password)}
              >
                {isLoading ? 'Creating...' : 'Create Server'}
              </button>
            </div>
          </form>
        )}
      </div>
    </div>
  );
}

export default CreateServerModal;
```

2. Create src/dashboard/src/components/CreateServerModal.css:

```css
.modal-overlay {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: rgba(0, 0, 0, 0.5);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 1000;
}

.create-server-modal {
  background: var(--bg-primary);
  border-radius: 8px;
  width: 480px;
  max-width: 95vw;
  max-height: 90vh;
  overflow: hidden;
  display: flex;
  flex-direction: column;
  box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
}

.modal-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 16px 20px;
  border-bottom: 1px solid var(--border-color);
}

.modal-header h2 {
  margin: 0;
  font-size: 1.25rem;
}

.modal-close {
  background: none;
  border: none;
  font-size: 1.5rem;
  cursor: pointer;
  color: var(--text-secondary);
  line-height: 1;
}

.modal-body {
  padding: 20px;
  overflow-y: auto;
  flex: 1;
}

.modal-footer {
  display: flex;
  justify-content: flex-end;
  gap: 12px;
  padding: 16px 20px;
  border-top: 1px solid var(--border-color);
}

/* Protocol Selector */
.protocol-selector {
  display: flex;
  gap: 8px;
}

.protocol-btn {
  flex: 1;
  padding: 12px;
  border: 2px solid var(--border-color);
  background: var(--bg-secondary);
  border-radius: 6px;
  cursor: pointer;
  font-weight: 600;
  transition: all 0.2s;
}

.protocol-btn:hover {
  border-color: var(--accent-color);
}

.protocol-btn--selected {
  border-color: var(--accent-color);
  background: var(--accent-color);
  color: white;
}

/* Form Elements */
.form-group {
  margin-bottom: 16px;
}

.form-group label {
  display: block;
  margin-bottom: 6px;
  font-weight: 500;
  color: var(--text-secondary);
}

.form-group input {
  width: 100%;
  padding: 10px 12px;
  border: 1px solid var(--border-color);
  border-radius: 4px;
  background: var(--bg-secondary);
  color: var(--text-primary);
  font-size: 14px;
}

.form-group input:focus {
  outline: none;
  border-color: var(--accent-color);
}

.form-group input.input--error {
  border-color: var(--error-color);
}

.form-row {
  display: flex;
  gap: 16px;
}

.form-row .form-group {
  flex: 1;
}

.field-error {
  display: block;
  margin-top: 4px;
  color: var(--error-color);
  font-size: 12px;
}

/* NAS Presets */
.nas-presets {
  display: flex;
  flex-wrap: wrap;
  gap: 12px;
  margin-bottom: 12px;
}

.radio-label {
  display: flex;
  align-items: center;
  gap: 6px;
  cursor: pointer;
}

.custom-dir-input {
  margin-top: 8px;
}

/* Advanced Settings */
.advanced-toggle {
  background: none;
  border: none;
  color: var(--accent-color);
  cursor: pointer;
  padding: 8px 0;
  font-size: 14px;
}

.advanced-settings {
  margin-top: 16px;
  padding-top: 16px;
  border-top: 1px solid var(--border-color);
}

/* Progress Indicator */
.create-server-progress {
  display: flex;
  align-items: center;
  gap: 12px;
  padding: 16px;
  border-radius: 6px;
  margin-top: 16px;
  background: var(--bg-secondary);
}

.create-server-progress--complete {
  background: rgba(52, 211, 153, 0.1);
  color: var(--success-color);
}

.create-server-progress--error {
  background: rgba(239, 68, 68, 0.1);
  color: var(--error-color);
}

.progress-spinner {
  width: 20px;
  height: 20px;
  border: 2px solid var(--border-color);
  border-top-color: var(--accent-color);
  border-radius: 50%;
  animation: spin 1s linear infinite;
}

@keyframes spin {
  to { transform: rotate(360deg); }
}

/* Error Message */
.error-message {
  padding: 12px;
  background: rgba(239, 68, 68, 0.1);
  border-radius: 6px;
  color: var(--error-color);
  margin-top: 16px;
}

/* Buttons */
.btn {
  padding: 10px 20px;
  border-radius: 6px;
  font-weight: 500;
  cursor: pointer;
  border: none;
  transition: all 0.2s;
}

.btn:disabled {
  opacity: 0.5;
  cursor: not-allowed;
}

.btn--primary {
  background: var(--accent-color);
  color: white;
}

.btn--primary:hover:not(:disabled) {
  filter: brightness(1.1);
}

.btn--secondary {
  background: var(--bg-secondary);
  border: 1px solid var(--border-color);
  color: var(--text-primary);
}

.btn--secondary:hover:not(:disabled) {
  background: var(--bg-tertiary);
}
```
  </action>
  <verify>
- Both files created
- CreateServerModal handles all three protocols
- Progress displayed in modal during creation
- Advanced settings collapsible
- Name validation with debounce
- Error handling and retry
  </verify>
  <done>CreateServerModal with protocol selection, full configuration options, progress feedback, and proper error handling.</done>
</task>

</tasks>

<verification>
1. `npm run build` in dashboard succeeds
2. Types match backend DTOs
3. Hook provides all CRUD + lifecycle operations
4. Modal shows progress during deployment
5. Name validation with availability check
</verification>

<success_criteria>
- Full control over configuration (CONTEXT.md)
- NodePort auto-assign with override option (CONTEXT.md)
- NAS presets: input/output/backup with custom (CONTEXT.md)
- Progress in modal until complete (CONTEXT.md)
- Error shown in modal with retry (CONTEXT.md)
</success_criteria>

<output>
After completion, create `.planning/phases/11-dynamic-server-management/11-06-SUMMARY.md`
</output>
