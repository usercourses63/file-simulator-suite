---
phase: 14-comprehensive-api-driven-integration-testing
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - tests/FileSimulator.IntegrationTests/FileSimulator.IntegrationTests.csproj
  - tests/FileSimulator.IntegrationTests/Fixtures/SimulatorCollectionFixture.cs
  - tests/FileSimulator.IntegrationTests/Fixtures/SimulatorCollection.cs
  - tests/FileSimulator.IntegrationTests/Support/RetryPolicies.cs
  - tests/FileSimulator.IntegrationTests/Support/TestHelpers.cs
  - tests/FileSimulator.IntegrationTests/Models/ConnectionInfo.cs
  - tests/FileSimulator.IntegrationTests/appsettings.test.json
  - tests/FileSimulator.IntegrationTests/xunit.runner.json
autonomous: true

must_haves:
  truths:
    - "Test project builds successfully with dotnet build"
    - "Collection fixture can connect to Control API"
    - "Retry policies handle transient failures gracefully"
  artifacts:
    - path: "tests/FileSimulator.IntegrationTests/FileSimulator.IntegrationTests.csproj"
      provides: "xUnit test project with FluentAssertions, Polly, and JUnit XML logger"
      contains: "xunit"
    - path: "tests/FileSimulator.IntegrationTests/Fixtures/SimulatorCollectionFixture.cs"
      provides: "Shared test fixture with HttpClient and connection validation"
      exports: ["SimulatorCollectionFixture"]
    - path: "tests/FileSimulator.IntegrationTests/Support/RetryPolicies.cs"
      provides: "Polly retry policies for infrastructure tests"
      exports: ["HttpRetryPolicy", "ServerReadinessPolicy"]
  key_links:
    - from: "tests/FileSimulator.IntegrationTests/Fixtures/SimulatorCollectionFixture.cs"
      to: "http://file-simulator.local:30500/api/health"
      via: "HttpClient GET in constructor"
      pattern: "GetAsync.*api/health"
---

<objective>
Set up the FileSimulator.IntegrationTests xUnit project with shared fixtures and retry infrastructure.

Purpose: Establish the foundation for all integration tests with proper test isolation, retry policies, and shared context management. This enables CI/CD integration via JUnit XML output.

Output: Working xUnit test project with collection fixture that validates API connectivity on startup.
</objective>

<execution_context>
@C:\Users\UserC\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\UserC\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/14-comprehensive-api-driven-integration-testing/14-RESEARCH.md
@tests/FileSimulator.E2ETests/FileSimulator.E2ETests.csproj
@tests/FileSimulator.E2ETests/Fixtures/SimulatorTestFixture.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create xUnit test project with dependencies</name>
  <files>
    tests/FileSimulator.IntegrationTests/FileSimulator.IntegrationTests.csproj
    tests/FileSimulator.IntegrationTests/appsettings.test.json
    tests/FileSimulator.IntegrationTests/xunit.runner.json
  </files>
  <action>
Create the integration test project structure:

1. Create `tests/FileSimulator.IntegrationTests/FileSimulator.IntegrationTests.csproj`:
   - Target net9.0
   - Add packages: xunit 2.9.0, xunit.runner.visualstudio 2.8.2, FluentAssertions 6.12.2, Microsoft.NET.Test.Sdk 17.12.0, JunitXml.TestLogger 4.0.254
   - Add packages: Polly 8.5.2, Polly.Extensions 8.5.2
   - Add protocol client packages: FluentFTP 50.0.1, SSH.NET 2024.1.0, AWSSDK.S3 3.7.305, SMBLibrary 1.5.2, Confluent.Kafka 2.12.0
   - Reference FileSimulator.Client project
   - Set IsPackable=false, IsTestProject=true

2. Create `tests/FileSimulator.IntegrationTests/appsettings.test.json`:
   - ControlApi.BaseUrl: "http://file-simulator.local:30500"
   - Timeouts.ServerReadiness: 60000 (60 seconds)
   - Timeouts.HttpRequest: 30000 (30 seconds)
   - Kafka.BootstrapServers: "file-simulator.local:30093"
   - Retry.MaxAttempts: 3
   - Retry.BaseDelayMs: 2000

3. Create `tests/FileSimulator.IntegrationTests/xunit.runner.json`:
   - parallelizeTestCollections: false (tests share infrastructure)
   - methodDisplay: "classAndMethod"
   - diagnosticMessages: true
  </action>
  <verify>
Run `dotnet build tests/FileSimulator.IntegrationTests` - should compile without errors.
  </verify>
  <done>
Project created with all required NuGet packages and configuration files.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create collection fixture and retry policies</name>
  <files>
    tests/FileSimulator.IntegrationTests/Fixtures/SimulatorCollectionFixture.cs
    tests/FileSimulator.IntegrationTests/Fixtures/SimulatorCollection.cs
    tests/FileSimulator.IntegrationTests/Support/RetryPolicies.cs
    tests/FileSimulator.IntegrationTests/Support/TestHelpers.cs
    tests/FileSimulator.IntegrationTests/Models/ConnectionInfo.cs
  </files>
  <action>
Create shared test infrastructure:

1. Create `Models/ConnectionInfo.cs`:
   - ConnectionInfoResponse class with nested protocol configs (Ftp, Sftp, Http, WebDav, S3, Smb, Nfs, Kafka)
   - Each protocol config has: Host, Port, Username, Password, BasePath (optional: ServiceUrl, BucketName, ShareName, MountPath)
   - Use System.Text.Json.Serialization attributes with PropertyNameCaseInsensitive

2. Create `Support/RetryPolicies.cs`:
   - HttpRetryPolicy: AsyncRetryPolicy<HttpResponseMessage> - retry on non-success status or HttpRequestException, 3 attempts, exponential backoff (2, 4, 8 seconds)
   - ServerReadinessPolicy: AsyncRetryPolicy<bool> - retry on false result, 30 attempts, 2 second delay (total 60s max wait)
   - TcpConnectivityPolicy: AsyncRetryPolicy<bool> - retry on false or SocketException, 5 attempts, 1 second delay
   - Log retry attempts to console for debugging

3. Create `Support/TestHelpers.cs`:
   - GenerateUniqueFileName(prefix) - returns "{prefix}-{Guid:N}.txt"
   - GenerateUniqueServerName(type) - returns "test-{type}-{Guid:N}" (max 20 chars for K8s name limits)
   - WaitForServerReadyAsync(HttpClient, serverName, timeout) - polls /api/servers/{name} until PodReady=true and Status="Running"
   - GetConnectionInfoAsync(HttpClient) - fetches /api/connection-info and deserializes
   - AssertFileContent(expected, actual) - FluentAssertions wrapper with clear failure message

4. Create `Fixtures/SimulatorCollectionFixture.cs`:
   - Implements IDisposable
   - Properties: HttpClient ApiClient, string ApiUrl (from appsettings.test.json)
   - Constructor: Create HttpClient with BaseAddress and Timeout from config
   - Constructor: Verify API is reachable via /api/health (throw InvalidOperationException if not)
   - GetConnectionInfoAsync() - cached ConnectionInfoResponse
   - Dispose(): Dispose HttpClient

5. Create `Fixtures/SimulatorCollection.cs`:
   - [CollectionDefinition("Simulator")]
   - Implements ICollectionFixture<SimulatorCollectionFixture>
   - Empty class (marker only)
  </action>
  <verify>
Run `dotnet build tests/FileSimulator.IntegrationTests` - should compile without errors.
  </verify>
  <done>
Collection fixture validates API connectivity on construction, retry policies ready for use, helper methods available.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create smoke test to validate fixture</name>
  <files>
    tests/FileSimulator.IntegrationTests/SmokeTests.cs
  </files>
  <action>
Create a simple smoke test to validate the test infrastructure:

1. Create `SmokeTests.cs`:
   - [Collection("Simulator")] attribute
   - Constructor takes SimulatorCollectionFixture
   - Test: ApiHealth_ReturnsSuccess() - GET /api/health, assert IsSuccessStatusCode
   - Test: ConnectionInfo_ReturnsValidData() - GET /api/connection-info, assert all protocol configs have Host and Port
   - Test: RetryPolicy_HandlesTransientFailures() - verify Polly retry policy executes without error

Use FluentAssertions for all assertions:
- response.IsSuccessStatusCode.Should().BeTrue()
- connectionInfo.Ftp.Host.Should().NotBeNullOrEmpty()
- connectionInfo.Ftp.Port.Should().BeGreaterThan(0)
  </action>
  <verify>
Run `dotnet test tests/FileSimulator.IntegrationTests --filter "FullyQualifiedName~SmokeTests"` against running simulator.
Note: Requires simulator to be running (via Deploy-Production.ps1 or Start-Simulator.ps1).
  </verify>
  <done>
Smoke tests pass, validating that fixture connects to API and connection info is retrievable.
  </done>
</task>

</tasks>

<verification>
1. `dotnet build tests/FileSimulator.IntegrationTests` compiles without errors
2. `dotnet test tests/FileSimulator.IntegrationTests --filter "FullyQualifiedName~SmokeTests"` passes (requires running simulator)
3. JUnit XML can be generated: `dotnet test tests/FileSimulator.IntegrationTests --logger:"junit;LogFilePath=test-results/junit.xml"`
</verification>

<success_criteria>
- Integration test project created with xUnit, FluentAssertions, Polly, JUnit XML logger
- Collection fixture connects to Control API and validates health
- Retry policies defined for HTTP requests and server readiness polling
- Smoke tests pass when simulator is running
</success_criteria>

<output>
After completion, create `.planning/phases/14-comprehensive-api-driven-integration-testing/14-01-SUMMARY.md`
</output>
