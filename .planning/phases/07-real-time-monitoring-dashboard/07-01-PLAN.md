---
phase: 07-real-time-monitoring-dashboard
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/dashboard/package.json
  - src/dashboard/vite.config.ts
  - src/dashboard/tsconfig.json
  - src/dashboard/index.html
  - src/dashboard/src/main.tsx
  - src/dashboard/src/App.tsx
  - src/dashboard/src/App.css
  - src/dashboard/src/vite-env.d.ts
  - src/dashboard/.env.development
  - src/dashboard/src/types/server.ts
  - src/dashboard/src/hooks/useSignalR.ts
  - src/dashboard/src/utils/healthStatus.ts
autonomous: true

must_haves:
  truths:
    - "Dashboard project builds with npm run build without errors"
    - "TypeScript types match backend ServerStatus and ServerStatusUpdate models"
    - "useSignalR hook can establish WebSocket connection to SignalR hub"
    - "useSignalR hook handles reconnection with attempt counter"
  artifacts:
    - path: "src/dashboard/package.json"
      provides: "React 19 + Vite project with @microsoft/signalr dependency"
      contains: "@microsoft/signalr"
    - path: "src/dashboard/src/hooks/useSignalR.ts"
      provides: "SignalR connection management hook"
      exports: ["useSignalR"]
    - path: "src/dashboard/src/types/server.ts"
      provides: "TypeScript type definitions for backend models"
      exports: ["ServerStatus", "ServerStatusUpdate", "HealthState"]
  key_links:
    - from: "src/dashboard/src/hooks/useSignalR.ts"
      to: "@microsoft/signalr"
      via: "import * as signalR"
      pattern: "signalR\\.HubConnectionBuilder"
    - from: "src/dashboard/src/hooks/useSignalR.ts"
      to: "src/dashboard/src/types/server.ts"
      via: "generic type parameter"
      pattern: "useSignalR<T>"
---

<objective>
Create React 19 + Vite + TypeScript dashboard project with SignalR integration foundation.

Purpose: Establish the frontend project structure and core SignalR hook that all dashboard components will depend on. The useSignalR hook encapsulates WebSocket lifecycle, automatic reconnection, and connection state tracking.

Output:
- Vite React TypeScript project at src/dashboard/
- TypeScript types matching backend ServerStatus models
- useSignalR hook with automatic reconnection and state tracking
- Vite dev server proxy configuration for backend API
</objective>

<execution_context>
@C:\Users\UserC\.claude\get-shit-done\workflows\execute-plan.md
@C:\Users\UserC\.claude\get-shit-done\templates\summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-real-time-monitoring-dashboard/07-CONTEXT.md
@.planning/phases/07-real-time-monitoring-dashboard/07-RESEARCH.md
@.planning/phases/06-backend-api-foundation/06-03-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Vite React TypeScript project</name>
  <files>
    src/dashboard/package.json
    src/dashboard/vite.config.ts
    src/dashboard/tsconfig.json
    src/dashboard/index.html
    src/dashboard/src/main.tsx
    src/dashboard/src/App.tsx
    src/dashboard/src/App.css
    src/dashboard/src/vite-env.d.ts
    src/dashboard/.env.development
  </files>
  <action>
Create the Vite React TypeScript project structure for the dashboard. Do NOT use npm create vite - create files directly for deterministic output.

**package.json** - Create with these dependencies:
```json
{
  "name": "file-simulator-dashboard",
  "private": true,
  "version": "0.0.1",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "tsc -b && vite build",
    "lint": "eslint .",
    "preview": "vite preview"
  },
  "dependencies": {
    "react": "^19.0.0",
    "react-dom": "^19.0.0",
    "@microsoft/signalr": "^8.0.7"
  },
  "devDependencies": {
    "@eslint/js": "^9.17.0",
    "@types/react": "^19.0.0",
    "@types/react-dom": "^19.0.0",
    "@vitejs/plugin-react": "^4.3.4",
    "eslint": "^9.17.0",
    "eslint-plugin-react-hooks": "^5.1.0",
    "eslint-plugin-react-refresh": "^0.4.16",
    "globals": "^15.14.0",
    "typescript": "~5.6.2",
    "typescript-eslint": "^8.18.2",
    "vite": "^6.0.7"
  }
}
```

**vite.config.ts** - Configure with proxy for backend API:
```typescript
import { defineConfig, loadEnv } from 'vite'
import react from '@vitejs/plugin-react'

export default defineConfig(({ mode }) => {
  const env = loadEnv(mode, process.cwd(), '')
  const apiUrl = env.VITE_API_URL || 'http://192.168.49.2:30500'

  return {
    plugins: [react()],
    server: {
      port: 3000,
      proxy: {
        '/api': {
          target: apiUrl,
          changeOrigin: true
        },
        '/hubs': {
          target: apiUrl,
          changeOrigin: true,
          ws: true
        }
      }
    },
    build: {
      outDir: 'dist',
      sourcemap: true
    }
  }
})
```

**tsconfig.json** - Standard React TypeScript config:
```json
{
  "compilerOptions": {
    "target": "ES2020",
    "useDefineForClassFields": true,
    "lib": ["ES2020", "DOM", "DOM.Iterable"],
    "module": "ESNext",
    "skipLibCheck": true,
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "isolatedModules": true,
    "moduleDetection": "force",
    "noEmit": true,
    "jsx": "react-jsx",
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true
  },
  "include": ["src"]
}
```

**index.html** - Entry point:
```html
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>File Simulator Suite - Dashboard</title>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.tsx"></script>
  </body>
</html>
```

**src/main.tsx** - React 19 entry:
```tsx
import { StrictMode } from 'react'
import { createRoot } from 'react-dom/client'
import './App.css'
import App from './App.tsx'

createRoot(document.getElementById('root')!).render(
  <StrictMode>
    <App />
  </StrictMode>,
)
```

**src/App.tsx** - Placeholder app component:
```tsx
function App() {
  return (
    <div className="app">
      <header className="app-header">
        <h1>File Simulator Suite</h1>
        <p>Monitoring Dashboard</p>
      </header>
      <main className="app-main">
        <p>Loading dashboard...</p>
      </main>
    </div>
  )
}

export default App
```

**src/App.css** - Minimal base styles:
```css
* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}

body {
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
  background-color: #f5f5f5;
  color: #333;
}

.app {
  min-height: 100vh;
  display: flex;
  flex-direction: column;
}

.app-header {
  background-color: #1e293b;
  color: white;
  padding: 1rem 2rem;
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.app-header h1 {
  font-size: 1.5rem;
  font-weight: 600;
}

.app-main {
  flex: 1;
  padding: 2rem;
}
```

**src/vite-env.d.ts** - Vite environment types:
```typescript
/// <reference types="vite/client" />

interface ImportMetaEnv {
  readonly VITE_API_URL: string
  readonly VITE_SIGNALR_HUB_URL: string
}

interface ImportMeta {
  readonly env: ImportMetaEnv
}
```

**.env.development** - Development environment variables:
```
VITE_API_URL=http://192.168.49.2:30500
VITE_SIGNALR_HUB_URL=http://192.168.49.2:30500/hubs/status
```

Run `npm install` in src/dashboard directory after creating files.
  </action>
  <verify>
```bash
cd src/dashboard && npm install && npm run build
```
Build must complete without TypeScript errors.
  </verify>
  <done>
Vite React TypeScript project created at src/dashboard/, npm install succeeds, npm run build succeeds.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create TypeScript types for backend models</name>
  <files>
    src/dashboard/src/types/server.ts
    src/dashboard/src/utils/healthStatus.ts
  </files>
  <action>
Create TypeScript type definitions that match the backend ServerStatus and ServerStatusUpdate models from Phase 6.

**src/types/server.ts** - Type definitions matching backend models:
```typescript
/**
 * Protocol types supported by the file simulator suite.
 * Matches backend Protocol enum.
 */
export type Protocol = 'FTP' | 'SFTP' | 'HTTP' | 'S3' | 'SMB' | 'NFS';

/**
 * Kubernetes pod status.
 * Matches backend PodStatus values.
 */
export type PodStatus = 'Running' | 'Pending' | 'Failed' | 'Unknown';

/**
 * Health state derived from IsHealthy + LatencyMs for UI display.
 * - healthy: Pod running, health check passed, latency < 3000ms
 * - degraded: Pod running, health check passed, latency >= 3000ms
 * - down: Pod not running or health check failed
 * - unknown: Initial state before first health check
 */
export type HealthState = 'healthy' | 'degraded' | 'down' | 'unknown';

/**
 * Real-time status of a protocol server.
 * Matches backend ServerStatus record.
 */
export interface ServerStatus {
  Name: string;
  Protocol: Protocol;
  PodStatus: PodStatus;
  IsHealthy: boolean;
  HealthMessage?: string;
  LatencyMs?: number;
  CheckedAt: string; // ISO 8601 timestamp
}

/**
 * Collection of all server statuses, broadcast via SignalR.
 * Matches backend ServerStatusUpdate record.
 */
export interface ServerStatusUpdate {
  Servers: ServerStatus[];
  Timestamp: string; // ISO 8601 timestamp
  TotalServers: number;
  HealthyServers: number;
}
```

**src/utils/healthStatus.ts** - Health state calculation:
```typescript
import { ServerStatus, HealthState } from '../types/server';

/**
 * Latency threshold in ms above which server is considered degraded.
 */
const DEGRADED_LATENCY_THRESHOLD = 3000;

/**
 * Determine the health state of a server for UI display.
 *
 * @param server - Server status from backend
 * @returns HealthState for CSS class and display
 */
export function getHealthState(server: ServerStatus): HealthState {
  // Pod not running = down
  if (server.PodStatus !== 'Running') {
    return 'down';
  }

  // Health check failed = down
  if (!server.IsHealthy) {
    return 'down';
  }

  // High latency = degraded
  if (server.LatencyMs !== undefined && server.LatencyMs >= DEGRADED_LATENCY_THRESHOLD) {
    return 'degraded';
  }

  // All checks passed = healthy
  return 'healthy';
}

/**
 * Get display text for health state.
 */
export function getHealthStateText(state: HealthState): string {
  switch (state) {
    case 'healthy':
      return 'Healthy';
    case 'degraded':
      return 'Degraded';
    case 'down':
      return 'Down';
    case 'unknown':
      return 'Checking...';
  }
}

/**
 * Count servers by health state.
 */
export function countByHealthState(servers: ServerStatus[]): Record<HealthState, number> {
  const counts: Record<HealthState, number> = {
    healthy: 0,
    degraded: 0,
    down: 0,
    unknown: 0
  };

  for (const server of servers) {
    const state = getHealthState(server);
    counts[state]++;
  }

  return counts;
}
```
  </action>
  <verify>
```bash
cd src/dashboard && npm run build
```
Build must complete. Types should be importable without errors.
  </verify>
  <done>
TypeScript types created matching backend ServerStatus and ServerStatusUpdate models. Health state calculation utilities implemented.
  </done>
</task>

<task type="auto">
  <name>Task 3: Implement useSignalR hook with automatic reconnection</name>
  <files>src/dashboard/src/hooks/useSignalR.ts</files>
  <action>
Create the custom useSignalR hook that encapsulates SignalR connection lifecycle with automatic reconnection handling.

**src/hooks/useSignalR.ts**:
```typescript
import { useEffect, useState, useRef, useCallback } from 'react';
import * as signalR from '@microsoft/signalr';

/**
 * Result returned by useSignalR hook.
 */
export interface UseSignalRResult<T> {
  /** Latest data received from SignalR */
  data: T | null;
  /** Whether WebSocket is connected */
  isConnected: boolean;
  /** Whether currently reconnecting */
  isReconnecting: boolean;
  /** Current reconnection attempt number (resets on success) */
  reconnectAttempt: number;
  /** Error message if connection failed */
  error: string | null;
  /** Timestamp of last received message */
  lastUpdate: Date | null;
}

/**
 * Custom hook for managing SignalR WebSocket connections with automatic reconnection.
 *
 * @param hubUrl - URL of the SignalR hub (e.g., "http://localhost:30500/hubs/status")
 * @param eventName - Name of the event to subscribe to (e.g., "ServerStatusUpdate")
 * @returns Connection state and latest data
 *
 * @example
 * const { data, isConnected, isReconnecting, reconnectAttempt, error, lastUpdate } =
 *   useSignalR<ServerStatusUpdate>('http://localhost:30500/hubs/status', 'ServerStatusUpdate');
 */
export function useSignalR<T>(
  hubUrl: string,
  eventName: string
): UseSignalRResult<T> {
  const [data, setData] = useState<T | null>(null);
  const [isConnected, setIsConnected] = useState(false);
  const [isReconnecting, setIsReconnecting] = useState(false);
  const [reconnectAttempt, setReconnectAttempt] = useState(0);
  const [error, setError] = useState<string | null>(null);
  const [lastUpdate, setLastUpdate] = useState<Date | null>(null);

  // Use ref to store connection to prevent recreating on re-renders
  const connectionRef = useRef<signalR.HubConnection | null>(null);

  // Track if component is mounted to prevent state updates after unmount
  const isMountedRef = useRef(true);

  useEffect(() => {
    isMountedRef.current = true;

    // Build connection with automatic reconnection
    // Default retry delays: 0, 2000, 10000, 30000 ms
    const connection = new signalR.HubConnectionBuilder()
      .withUrl(hubUrl)
      .withAutomaticReconnect([0, 2000, 5000, 10000, 30000]) // Custom retry intervals
      .configureLogging(signalR.LogLevel.Information)
      .build();

    connectionRef.current = connection;

    // Connection lifecycle handlers
    connection.onreconnecting((err) => {
      if (!isMountedRef.current) return;

      setIsReconnecting(true);
      setIsConnected(false);
      setReconnectAttempt(prev => prev + 1);
      console.log('SignalR reconnecting...', err?.message);
    });

    connection.onreconnected((connectionId) => {
      if (!isMountedRef.current) return;

      setIsReconnecting(false);
      setIsConnected(true);
      setReconnectAttempt(0);
      setError(null);
      console.log('SignalR reconnected, connectionId:', connectionId);
    });

    connection.onclose((err) => {
      if (!isMountedRef.current) return;

      setIsConnected(false);
      setIsReconnecting(false);
      if (err) {
        setError(err.message);
        console.error('SignalR connection closed with error:', err);
      } else {
        console.log('SignalR connection closed');
      }
    });

    // Subscribe to messages
    connection.on(eventName, (message: T) => {
      if (!isMountedRef.current) return;

      setData(message);
      setLastUpdate(new Date());
    });

    // Start connection
    connection.start()
      .then(() => {
        if (!isMountedRef.current) return;

        setIsConnected(true);
        setError(null);
        console.log('SignalR connected to', hubUrl);
      })
      .catch((err) => {
        if (!isMountedRef.current) return;

        setError(err.message);
        console.error('SignalR connection failed:', err);
      });

    // Cleanup on unmount
    return () => {
      isMountedRef.current = false;
      connection.off(eventName);
      connection.stop().catch(err => {
        console.warn('Error stopping SignalR connection:', err);
      });
    };
  }, [hubUrl, eventName]);

  return { data, isConnected, isReconnecting, reconnectAttempt, error, lastUpdate };
}

export default useSignalR;
```
  </action>
  <verify>
```bash
cd src/dashboard && npm run build
```
Build must complete. Hook should be importable from components.
  </verify>
  <done>
useSignalR hook implemented with automatic reconnection, connection state tracking, and cleanup. Hook returns data, isConnected, isReconnecting, reconnectAttempt, error, and lastUpdate.
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. **Project structure exists:**
   ```bash
   ls src/dashboard/src/types/server.ts
   ls src/dashboard/src/hooks/useSignalR.ts
   ls src/dashboard/src/utils/healthStatus.ts
   ```

2. **Build succeeds:**
   ```bash
   cd src/dashboard && npm run build
   ```

3. **Dependencies installed:**
   ```bash
   cd src/dashboard && npm list @microsoft/signalr
   ```
</verification>

<success_criteria>
- React 19 + Vite project exists at src/dashboard/
- npm install completes without errors
- npm run build completes without TypeScript errors
- useSignalR hook exports from src/dashboard/src/hooks/useSignalR.ts
- TypeScript types match backend ServerStatus and ServerStatusUpdate models
- Vite proxy configured for /api and /hubs WebSocket routes
</success_criteria>

<output>
After completion, create `.planning/phases/07-real-time-monitoring-dashboard/07-01-SUMMARY.md`
</output>
