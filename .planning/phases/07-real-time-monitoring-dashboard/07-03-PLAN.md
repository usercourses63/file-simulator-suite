---
phase: 07-real-time-monitoring-dashboard
plan: 03
type: execute
wave: 2
depends_on: ["07-01"]
files_modified:
  - src/dashboard/src/components/ServerDetailsPanel.tsx
  - src/dashboard/src/utils/protocolInfo.ts
autonomous: true

must_haves:
  truths:
    - "Details panel shows server connection information when card is clicked"
    - "Protocol-specific sections display FTP/SFTP/HTTP/S3/SMB/NFS configuration"
    - "Copy-to-clipboard buttons work on connection strings"
    - "Panel can be closed via X button"
  artifacts:
    - path: "src/dashboard/src/components/ServerDetailsPanel.tsx"
      provides: "Right sidebar details panel for selected server"
      exports: ["ServerDetailsPanel"]
    - path: "src/dashboard/src/utils/protocolInfo.ts"
      provides: "Protocol-specific configuration templates"
      exports: ["getProtocolInfo", "ProtocolInfo"]
  key_links:
    - from: "src/dashboard/src/components/ServerDetailsPanel.tsx"
      to: "src/dashboard/src/utils/protocolInfo.ts"
      via: "protocol info lookup"
      pattern: "getProtocolInfo\\(server"
    - from: "src/dashboard/src/components/ServerDetailsPanel.tsx"
      to: "src/dashboard/src/types/server.ts"
      via: "ServerStatus import"
      pattern: "ServerStatus"
---

<objective>
Create the protocol details panel as a right sidebar that shows connection information and protocol-specific configuration.

Purpose: When users click a server card, they need detailed connection information including host:port, connection string examples, and protocol-specific settings (FTP passive mode, S3 bucket name, NFS mount path, etc.). This panel provides the actionable information developers need to configure their applications.

Output:
- ServerDetailsPanel component as right sidebar with slide-in animation
- Protocol-specific information utility with connection templates
- Copy-to-clipboard functionality for connection strings
- Credentials displayed in plain text (dev environment convenience)
</objective>

<execution_context>
@C:\Users\UserC\.claude\get-shit-done\workflows\execute-plan.md
@C:\Users\UserC\.claude\get-shit-done\templates\summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/07-real-time-monitoring-dashboard/07-CONTEXT.md
@.planning/phases/07-real-time-monitoring-dashboard/07-RESEARCH.md
@.planning/phases/07-real-time-monitoring-dashboard/07-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create protocol information utility</name>
  <files>src/dashboard/src/utils/protocolInfo.ts</files>
  <action>
Create utility functions for protocol-specific connection information.

**src/utils/protocolInfo.ts**:
```typescript
import { Protocol } from '../types/server';

/**
 * Protocol-specific connection information.
 */
export interface ProtocolInfo {
  /** Display name for the protocol */
  displayName: string;
  /** Default port number */
  defaultPort: number;
  /** Service hostname template (cluster internal) */
  serviceHost: string;
  /** NodePort for external access */
  nodePort: number;
  /** Connection string example */
  connectionString: string;
  /** Protocol-specific configuration items */
  config: Record<string, string>;
  /** Default credentials (dev environment) */
  credentials?: {
    username: string;
    password: string;
  };
}

/**
 * Get protocol-specific connection information for a server.
 *
 * @param serverName - Name of the server (used for host resolution)
 * @param protocol - Protocol type
 * @param namespace - Kubernetes namespace (default: file-simulator)
 * @returns Protocol-specific connection info
 */
export function getProtocolInfo(
  serverName: string,
  protocol: Protocol,
  namespace: string = 'file-simulator'
): ProtocolInfo {
  // Build service hostname
  const serviceBase = `${serverName}.${namespace}.svc.cluster.local`;

  switch (protocol) {
    case 'FTP':
      return {
        displayName: 'FTP Server',
        defaultPort: 21,
        serviceHost: serviceBase,
        nodePort: 30021,
        connectionString: `ftp://${serviceBase}:21`,
        config: {
          'Mode': 'Passive (PASV)',
          'Passive Ports': '30000-30009',
          'Transfer Mode': 'Binary',
          'Anonymous': 'Disabled'
        },
        credentials: {
          username: 'ftpuser',
          password: 'ftppass'
        }
      };

    case 'SFTP':
      return {
        displayName: 'SFTP Server',
        defaultPort: 22,
        serviceHost: serviceBase,
        nodePort: 30022,
        connectionString: `sftp://${serviceBase}:22`,
        config: {
          'SSH Version': 'OpenSSH',
          'Key Auth': 'Supported',
          'Root Directory': '/data'
        },
        credentials: {
          username: 'sftpuser',
          password: 'sftppass'
        }
      };

    case 'HTTP':
      return {
        displayName: 'HTTP/WebDAV Server',
        defaultPort: 80,
        serviceHost: serviceBase,
        nodePort: 30088,
        connectionString: `http://${serviceBase}:80`,
        config: {
          'WebDAV': 'Enabled',
          'Auth': 'Basic',
          'Methods': 'GET, PUT, DELETE, MKCOL, PROPFIND'
        },
        credentials: {
          username: 'webdav',
          password: 'webdav'
        }
      };

    case 'S3':
      return {
        displayName: 'S3/MinIO Server',
        defaultPort: 9000,
        serviceHost: serviceBase,
        nodePort: 30900,
        connectionString: `http://${serviceBase}:9000`,
        config: {
          'Bucket': 'simulator-data',
          'Region': 'us-east-1',
          'Console Port': '9001',
          'Path Style': 'Enabled'
        },
        credentials: {
          username: 'minioadmin',
          password: 'minioadmin'
        }
      };

    case 'SMB':
      return {
        displayName: 'SMB/Samba Server',
        defaultPort: 445,
        serviceHost: serviceBase,
        nodePort: 30445,
        connectionString: `\\\\${serviceBase}\\simulator-data`,
        config: {
          'Share Name': 'simulator-data',
          'Protocol': 'SMB2/SMB3',
          'Guest Access': 'Disabled'
        },
        credentials: {
          username: 'smbuser',
          password: 'smbpass'
        }
      };

    case 'NFS':
      return {
        displayName: 'NFS Server',
        defaultPort: 2049,
        serviceHost: serviceBase,
        nodePort: 32049,
        connectionString: `${serviceBase}:/exports/data`,
        config: {
          'Export Path': '/exports/data',
          'NFS Version': 'v3 (unfs3)',
          'Sync Mode': 'async',
          'Access': 'rw,no_root_squash'
        }
      };

    default:
      return {
        displayName: protocol,
        defaultPort: 0,
        serviceHost: serviceBase,
        nodePort: 0,
        connectionString: serviceBase,
        config: {}
      };
  }
}

/**
 * Get Minikube IP-based connection info for external access.
 *
 * @param protocol - Protocol type
 * @param minikubeIp - Minikube IP address (default: 192.168.49.2)
 * @returns External connection string
 */
export function getExternalConnectionString(
  protocol: Protocol,
  minikubeIp: string = '192.168.49.2'
): string {
  const portMap: Record<Protocol, number> = {
    'FTP': 30021,
    'SFTP': 30022,
    'HTTP': 30088,
    'S3': 30900,
    'SMB': 30445,
    'NFS': 32049
  };

  const port = portMap[protocol];

  switch (protocol) {
    case 'FTP':
      return `ftp://${minikubeIp}:${port}`;
    case 'SFTP':
      return `sftp://${minikubeIp}:${port}`;
    case 'HTTP':
      return `http://${minikubeIp}:${port}`;
    case 'S3':
      return `http://${minikubeIp}:${port}`;
    case 'SMB':
      return `\\\\${minikubeIp}\\simulator-data (via tunnel)`;
    case 'NFS':
      return `${minikubeIp}:/exports/data`;
    default:
      return `${minikubeIp}:${port}`;
  }
}
```
  </action>
  <verify>
```bash
cd src/dashboard && npm run build
```
Build must complete. Protocol info utility should be importable.
  </verify>
  <done>
Protocol information utility created with connection templates for all 6 protocols including credentials.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create ServerDetailsPanel component</name>
  <files>src/dashboard/src/components/ServerDetailsPanel.tsx</files>
  <action>
Create the ServerDetailsPanel component as a right sidebar with protocol-specific information.

**src/components/ServerDetailsPanel.tsx**:
```tsx
import { useState, useCallback } from 'react';
import { ServerStatus } from '../types/server';
import { getHealthState, getHealthStateText } from '../utils/healthStatus';
import { getProtocolInfo, getExternalConnectionString } from '../utils/protocolInfo';

interface ServerDetailsPanelProps {
  server: ServerStatus | null;
  onClose: () => void;
}

/**
 * Right sidebar panel showing detailed server information.
 *
 * Features:
 * - Slide-in animation when opening
 * - Server name, protocol, and health status
 * - Connection strings with copy-to-clipboard
 * - Protocol-specific configuration details
 * - Credentials displayed in plain text (dev convenience)
 * - Last 5 check timestamps (if available)
 */
export function ServerDetailsPanel({ server, onClose }: ServerDetailsPanelProps) {
  const [copiedField, setCopiedField] = useState<string | null>(null);

  // Copy text to clipboard with visual feedback
  const copyToClipboard = useCallback(async (text: string, fieldName: string) => {
    try {
      await navigator.clipboard.writeText(text);
      setCopiedField(fieldName);
      setTimeout(() => setCopiedField(null), 2000);
    } catch (err) {
      console.error('Failed to copy:', err);
    }
  }, []);

  // Don't render if no server selected
  if (!server) {
    return null;
  }

  const healthState = getHealthState(server);
  const healthText = getHealthStateText(healthState);
  const protocolInfo = getProtocolInfo(server.Name, server.Protocol);
  const externalConnection = getExternalConnectionString(server.Protocol);

  // Render a copiable field with button
  const renderCopyField = (label: string, value: string, fieldKey: string) => (
    <div className="detail-field detail-field--copyable">
      <span className="field-label">{label}</span>
      <div className="field-value-wrapper">
        <code className="field-value">{value}</code>
        <button
          className={`copy-button ${copiedField === fieldKey ? 'copy-button--copied' : ''}`}
          onClick={() => copyToClipboard(value, fieldKey)}
          title="Copy to clipboard"
        >
          {copiedField === fieldKey ? 'Copied!' : 'Copy'}
        </button>
      </div>
    </div>
  );

  return (
    <aside className={`details-panel ${server ? 'details-panel--open' : ''}`}>
      <div className="panel-header">
        <div className="panel-title">
          <h3>{server.Name}</h3>
          <span className="panel-protocol">{protocolInfo.displayName}</span>
        </div>
        <button
          className="panel-close"
          onClick={onClose}
          aria-label="Close details panel"
        >
          &times;
        </button>
      </div>

      <div className="panel-content">
        {/* Status Section */}
        <section className="panel-section">
          <h4 className="section-heading">Status</h4>
          <div className="detail-field">
            <span className="field-label">Health</span>
            <span className={`field-value status-badge status-badge--${healthState}`}>
              {healthText}
            </span>
          </div>
          <div className="detail-field">
            <span className="field-label">Pod Status</span>
            <span className="field-value">{server.PodStatus}</span>
          </div>
          {server.HealthMessage && (
            <div className="detail-field">
              <span className="field-label">Message</span>
              <span className="field-value field-value--message">{server.HealthMessage}</span>
            </div>
          )}
        </section>

        {/* Metrics Section */}
        <section className="panel-section">
          <h4 className="section-heading">Metrics</h4>
          <div className="detail-field">
            <span className="field-label">Latency</span>
            <span className="field-value">
              {server.LatencyMs !== undefined ? `${server.LatencyMs}ms` : 'N/A'}
            </span>
          </div>
          <div className="detail-field">
            <span className="field-label">Last Checked</span>
            <span className="field-value">
              {new Date(server.CheckedAt).toLocaleTimeString()}
            </span>
          </div>
        </section>

        {/* Connection Section */}
        <section className="panel-section">
          <h4 className="section-heading">Connection</h4>
          {renderCopyField('Cluster Internal', protocolInfo.connectionString, 'internal')}
          {renderCopyField('External (Minikube)', externalConnection, 'external')}
          <div className="detail-field">
            <span className="field-label">Port</span>
            <span className="field-value">{protocolInfo.defaultPort}</span>
          </div>
          <div className="detail-field">
            <span className="field-label">NodePort</span>
            <span className="field-value">{protocolInfo.nodePort}</span>
          </div>
        </section>

        {/* Credentials Section (if available) */}
        {protocolInfo.credentials && (
          <section className="panel-section">
            <h4 className="section-heading">Credentials</h4>
            {renderCopyField('Username', protocolInfo.credentials.username, 'username')}
            {renderCopyField('Password', protocolInfo.credentials.password, 'password')}
          </section>
        )}

        {/* Protocol-Specific Configuration */}
        <section className="panel-section">
          <h4 className="section-heading">Configuration</h4>
          {Object.entries(protocolInfo.config).map(([key, value]) => (
            <div key={key} className="detail-field">
              <span className="field-label">{key}</span>
              <span className="field-value">{value}</span>
            </div>
          ))}
        </section>
      </div>
    </aside>
  );
}

export default ServerDetailsPanel;
```
  </action>
  <verify>
```bash
cd src/dashboard && npm run build
```
Build must complete. ServerDetailsPanel component should be importable.
  </verify>
  <done>
ServerDetailsPanel component created with status, metrics, connection info, credentials, and protocol-specific configuration sections. Copy-to-clipboard functionality implemented.
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. **Components exist:**
   ```bash
   ls src/dashboard/src/components/ServerDetailsPanel.tsx
   ls src/dashboard/src/utils/protocolInfo.ts
   ```

2. **Build succeeds:**
   ```bash
   cd src/dashboard && npm run build
   ```

3. **Protocol info covers all protocols:**
   The getProtocolInfo function should handle: FTP, SFTP, HTTP, S3, SMB, NFS
</verification>

<success_criteria>
- ServerDetailsPanel component renders connection information for selected server
- Protocol-specific sections display correct configuration for each protocol type
- Copy-to-clipboard buttons copy text and show "Copied!" feedback
- Panel can be closed via X button
- Build completes without TypeScript errors
</success_criteria>

<output>
After completion, create `.planning/phases/07-real-time-monitoring-dashboard/07-03-SUMMARY.md`
</output>
