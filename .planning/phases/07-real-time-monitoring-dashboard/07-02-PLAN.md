---
phase: 07-real-time-monitoring-dashboard
plan: 02
type: execute
wave: 2
depends_on: ["07-01"]
files_modified:
  - src/dashboard/src/components/ConnectionStatus.tsx
  - src/dashboard/src/components/SummaryHeader.tsx
  - src/dashboard/src/components/ServerCard.tsx
  - src/dashboard/src/components/ServerGrid.tsx
  - src/dashboard/src/App.tsx
autonomous: true

must_haves:
  truths:
    - "Dashboard displays all 13 servers in a grid layout"
    - "Servers are grouped by type: NAS servers (7) and Protocol servers (6)"
    - "Each server card shows name, status, and latency"
    - "Summary header shows health counts: X Healthy - Y Degraded - Z Down"
    - "Connection status indicator shows Connected or Reconnecting with attempt count"
  artifacts:
    - path: "src/dashboard/src/components/ServerGrid.tsx"
      provides: "Grid layout grouping servers by type"
      exports: ["ServerGrid"]
    - path: "src/dashboard/src/components/ServerCard.tsx"
      provides: "Individual server status card"
      exports: ["ServerCard"]
    - path: "src/dashboard/src/components/ConnectionStatus.tsx"
      provides: "WebSocket connection indicator"
      exports: ["ConnectionStatus"]
    - path: "src/dashboard/src/components/SummaryHeader.tsx"
      provides: "Health status summary counts"
      exports: ["SummaryHeader"]
  key_links:
    - from: "src/dashboard/src/App.tsx"
      to: "src/dashboard/src/hooks/useSignalR.ts"
      via: "useSignalR hook import"
      pattern: "useSignalR<ServerStatusUpdate>"
    - from: "src/dashboard/src/components/ServerGrid.tsx"
      to: "src/dashboard/src/components/ServerCard.tsx"
      via: "component composition"
      pattern: "<ServerCard"
    - from: "src/dashboard/src/components/ServerCard.tsx"
      to: "src/dashboard/src/utils/healthStatus.ts"
      via: "health state calculation"
      pattern: "getHealthState\\(server\\)"
---

<objective>
Create core dashboard components: server grid, server cards, summary header, and connection status indicator.

Purpose: Deliver the main dashboard UI that displays all 13 servers with real-time status updates. Users can see health status at a glance via the summary header and identify individual server states via cards grouped by type (NAS vs Protocol).

Output:
- ConnectionStatus component showing WebSocket state with retry counter
- SummaryHeader component showing "X Healthy - Y Degraded - Z Down" counts
- ServerCard component with health state colors and latency display
- ServerGrid component grouping servers by NAS (7) and Protocol (6)
- App.tsx integration wiring useSignalR to components
</objective>

<execution_context>
@C:\Users\UserC\.claude\get-shit-done\workflows\execute-plan.md
@C:\Users\UserC\.claude\get-shit-done\templates\summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/07-real-time-monitoring-dashboard/07-CONTEXT.md
@.planning/phases/07-real-time-monitoring-dashboard/07-RESEARCH.md
@.planning/phases/07-real-time-monitoring-dashboard/07-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create ConnectionStatus component</name>
  <files>src/dashboard/src/components/ConnectionStatus.tsx</files>
  <action>
Create the ConnectionStatus component that displays WebSocket connection state in the dashboard header.

**src/components/ConnectionStatus.tsx**:
```tsx
import { useMemo } from 'react';

interface ConnectionStatusProps {
  isConnected: boolean;
  isReconnecting: boolean;
  reconnectAttempt: number;
  lastUpdate: Date | null;
}

/**
 * Displays SignalR WebSocket connection status with reconnection feedback.
 *
 * Shows:
 * - "Connected" with green dot when connected
 * - "Reconnecting (attempt X/5)..." with yellow dot during reconnection
 * - "Disconnected" with red dot when not connected
 * - "Last update: Xs ago" timestamp
 */
export function ConnectionStatus({
  isConnected,
  isReconnecting,
  reconnectAttempt,
  lastUpdate
}: ConnectionStatusProps) {
  // Calculate time since last update
  const timeAgo = useMemo(() => {
    if (!lastUpdate) return null;
    const seconds = Math.floor((Date.now() - lastUpdate.getTime()) / 1000);
    if (seconds < 60) return `${seconds}s ago`;
    const minutes = Math.floor(seconds / 60);
    return `${minutes}m ago`;
  }, [lastUpdate]);

  // Determine status text and state
  const getStatusInfo = () => {
    if (isReconnecting) {
      return {
        text: `Reconnecting (attempt ${reconnectAttempt}/5)...`,
        state: 'reconnecting' as const
      };
    }
    if (isConnected) {
      return {
        text: 'Connected',
        state: 'connected' as const
      };
    }
    return {
      text: 'Disconnected',
      state: 'disconnected' as const
    };
  };

  const { text, state } = getStatusInfo();

  return (
    <div className="connection-status">
      <div className={`connection-indicator connection-indicator--${state}`}>
        <span className="connection-dot"></span>
        <span className="connection-text">{text}</span>
      </div>
      {lastUpdate && (
        <span className="connection-time">Last update: {timeAgo}</span>
      )}
    </div>
  );
}

export default ConnectionStatus;
```
  </action>
  <verify>
```bash
cd src/dashboard && npm run build
```
Build must complete. ConnectionStatus component should be importable.
  </verify>
  <done>
ConnectionStatus component created showing Connected/Reconnecting/Disconnected state with retry counter and last update timestamp.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create SummaryHeader component</name>
  <files>src/dashboard/src/components/SummaryHeader.tsx</files>
  <action>
Create the SummaryHeader component that shows health status counts at a glance.

**src/components/SummaryHeader.tsx**:
```tsx
import { ServerStatus } from '../types/server';
import { countByHealthState } from '../utils/healthStatus';

interface SummaryHeaderProps {
  servers: ServerStatus[];
}

/**
 * Displays summary health counts: "X Healthy - Y Degraded - Z Down"
 *
 * Provides at-a-glance overview of all 13 servers without scanning individual cards.
 */
export function SummaryHeader({ servers }: SummaryHeaderProps) {
  const counts = countByHealthState(servers);

  return (
    <div className="summary-header">
      <div className="summary-counts">
        <span className="summary-count summary-count--healthy">
          <span className="summary-dot summary-dot--healthy"></span>
          {counts.healthy} Healthy
        </span>
        <span className="summary-separator">-</span>
        <span className="summary-count summary-count--degraded">
          <span className="summary-dot summary-dot--degraded"></span>
          {counts.degraded} Degraded
        </span>
        <span className="summary-separator">-</span>
        <span className="summary-count summary-count--down">
          <span className="summary-dot summary-dot--down"></span>
          {counts.down} Down
        </span>
      </div>
      <div className="summary-total">
        {servers.length} servers monitored
      </div>
    </div>
  );
}

export default SummaryHeader;
```
  </action>
  <verify>
```bash
cd src/dashboard && npm run build
```
Build must complete. SummaryHeader component should be importable.
  </verify>
  <done>
SummaryHeader component created showing health status counts with colored dots.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create ServerCard component</name>
  <files>src/dashboard/src/components/ServerCard.tsx</files>
  <action>
Create the ServerCard component that displays individual server status.

**src/components/ServerCard.tsx**:
```tsx
import { useState, useEffect, useRef } from 'react';
import { ServerStatus } from '../types/server';
import { getHealthState, getHealthStateText } from '../utils/healthStatus';

interface ServerCardProps {
  server: ServerStatus;
  onClick: () => void;
}

/**
 * Individual server status card showing name, protocol, health, and latency.
 *
 * Features:
 * - Colored left border indicating health state (green/yellow/red)
 * - Status dot with health state text
 * - Latency display in milliseconds
 * - Brief pulse animation when status changes
 * - Click handler to open details panel
 */
export function ServerCard({ server, onClick }: ServerCardProps) {
  const healthState = getHealthState(server);
  const healthText = getHealthStateText(healthState);

  // Track previous health state to trigger animation on change
  const prevHealthState = useRef(healthState);
  const [isAnimating, setIsAnimating] = useState(false);

  useEffect(() => {
    if (prevHealthState.current !== healthState) {
      setIsAnimating(true);
      prevHealthState.current = healthState;

      // Remove animation class after animation completes
      const timer = setTimeout(() => setIsAnimating(false), 600);
      return () => clearTimeout(timer);
    }
  }, [healthState]);

  // Format latency for display
  const formatLatency = (latencyMs?: number) => {
    if (latencyMs === undefined) return '-';
    if (latencyMs < 1000) return `${latencyMs}ms`;
    return `${(latencyMs / 1000).toFixed(1)}s`;
  };

  return (
    <div
      className={`server-card server-card--${healthState} ${isAnimating ? 'server-card--pulse' : ''}`}
      onClick={onClick}
      role="button"
      tabIndex={0}
      onKeyDown={(e) => e.key === 'Enter' && onClick()}
    >
      <div className="server-card-header">
        <span className="server-name">{server.Name}</span>
        <span className="server-protocol">{server.Protocol}</span>
      </div>

      <div className="server-card-body">
        <div className="server-status">
          <span className={`status-dot status-dot--${healthState}`}></span>
          <span className="status-text">{healthText}</span>
        </div>

        <div className="server-metrics">
          <span className="metric-label">Latency:</span>
          <span className="metric-value">{formatLatency(server.LatencyMs)}</span>
        </div>
      </div>

      {server.HealthMessage && (
        <div className="server-card-footer">
          <span className="health-message">{server.HealthMessage}</span>
        </div>
      )}
    </div>
  );
}

export default ServerCard;
```
  </action>
  <verify>
```bash
cd src/dashboard && npm run build
```
Build must complete. ServerCard component should be importable.
  </verify>
  <done>
ServerCard component created with health state colors, latency display, pulse animation on status change, and click handler.
  </done>
</task>

<task type="auto">
  <name>Task 4: Create ServerGrid component</name>
  <files>src/dashboard/src/components/ServerGrid.tsx</files>
  <action>
Create the ServerGrid component that groups servers by type and renders cards.

**src/components/ServerGrid.tsx**:
```tsx
import { ServerStatus } from '../types/server';
import ServerCard from './ServerCard';

interface ServerGridProps {
  servers: ServerStatus[];
  onCardClick: (server: ServerStatus) => void;
}

/**
 * Displays server cards in a responsive grid, grouped by type.
 *
 * Groups:
 * - NAS Servers (7): Protocol === 'NFS'
 * - Protocol Servers (6): FTP, SFTP, HTTP, S3, SMB
 *
 * Uses CSS Grid with auto-fit for responsive wrapping.
 */
export function ServerGrid({ servers, onCardClick }: ServerGridProps) {
  // Group servers by type
  const nasServers = servers.filter(s => s.Protocol === 'NFS');
  const protocolServers = servers.filter(s => s.Protocol !== 'NFS');

  return (
    <div className="server-grid-container">
      <section className="server-section">
        <h2 className="section-title">
          NAS Servers
          <span className="section-count">({nasServers.length})</span>
        </h2>
        <div className="server-grid">
          {nasServers.map(server => (
            <ServerCard
              key={server.Name}
              server={server}
              onClick={() => onCardClick(server)}
            />
          ))}
          {nasServers.length === 0 && (
            <div className="server-grid-empty">No NAS servers found</div>
          )}
        </div>
      </section>

      <section className="server-section">
        <h2 className="section-title">
          Protocol Servers
          <span className="section-count">({protocolServers.length})</span>
        </h2>
        <div className="server-grid">
          {protocolServers.map(server => (
            <ServerCard
              key={server.Name}
              server={server}
              onClick={() => onCardClick(server)}
            />
          ))}
          {protocolServers.length === 0 && (
            <div className="server-grid-empty">No protocol servers found</div>
          )}
        </div>
      </section>
    </div>
  );
}

export default ServerGrid;
```
  </action>
  <verify>
```bash
cd src/dashboard && npm run build
```
Build must complete. ServerGrid component should be importable.
  </verify>
  <done>
ServerGrid component created grouping servers by NAS (7) and Protocol (6) types with responsive grid layout.
  </done>
</task>

<task type="auto">
  <name>Task 5: Integrate components in App.tsx</name>
  <files>src/dashboard/src/App.tsx</files>
  <action>
Update App.tsx to wire all components together with useSignalR hook.

**src/App.tsx** - Replace entire file:
```tsx
import { useState } from 'react';
import { useSignalR } from './hooks/useSignalR';
import { ServerStatus, ServerStatusUpdate } from './types/server';
import ConnectionStatus from './components/ConnectionStatus';
import SummaryHeader from './components/SummaryHeader';
import ServerGrid from './components/ServerGrid';
import './App.css';

function App() {
  // Get SignalR hub URL from environment
  const hubUrl = import.meta.env.VITE_SIGNALR_HUB_URL || 'http://192.168.49.2:30500/hubs/status';

  // Connect to SignalR hub and receive status updates
  const { data, isConnected, isReconnecting, reconnectAttempt, error, lastUpdate } =
    useSignalR<ServerStatusUpdate>(hubUrl, 'ServerStatusUpdate');

  // Track selected server for details panel
  const [selectedServer, setSelectedServer] = useState<ServerStatus | null>(null);

  return (
    <div className="app">
      <header className="app-header">
        <div className="header-title">
          <h1>File Simulator Suite</h1>
          <span className="header-subtitle">Monitoring Dashboard</span>
        </div>
        <ConnectionStatus
          isConnected={isConnected}
          isReconnecting={isReconnecting}
          reconnectAttempt={reconnectAttempt}
          lastUpdate={lastUpdate}
        />
      </header>

      <main className="app-main">
        {error && !isReconnecting && (
          <div className="error-banner">
            <span className="error-icon">!</span>
            <span className="error-message">Connection error: {error}</span>
          </div>
        )}

        {data ? (
          <>
            <SummaryHeader servers={data.Servers} />
            <ServerGrid
              servers={data.Servers}
              onCardClick={setSelectedServer}
            />
          </>
        ) : (
          <div className="loading-state">
            <div className="loading-spinner"></div>
            <p>Connecting to server...</p>
            {error && <p className="loading-error">{error}</p>}
          </div>
        )}
      </main>

      {/* Details panel placeholder - implemented in Plan 03 */}
      {selectedServer && (
        <div className="details-panel-placeholder">
          Selected: {selectedServer.Name}
          <button onClick={() => setSelectedServer(null)}>Close</button>
        </div>
      )}
    </div>
  );
}

export default App;
```
  </action>
  <verify>
```bash
cd src/dashboard && npm run build
```
Build must complete. App should integrate all components.
  </verify>
  <done>
App.tsx updated to wire useSignalR hook with ConnectionStatus, SummaryHeader, ServerGrid components. Placeholder added for details panel.
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. **All components exist:**
   ```bash
   ls src/dashboard/src/components/ConnectionStatus.tsx
   ls src/dashboard/src/components/SummaryHeader.tsx
   ls src/dashboard/src/components/ServerCard.tsx
   ls src/dashboard/src/components/ServerGrid.tsx
   ```

2. **Build succeeds:**
   ```bash
   cd src/dashboard && npm run build
   ```

3. **Component exports verify:**
   All components should export named functions matching component names.
</verification>

<success_criteria>
- ConnectionStatus component shows WebSocket state with retry counter
- SummaryHeader component shows "X Healthy - Y Degraded - Z Down" counts
- ServerCard component shows name, status, latency with health state colors
- ServerGrid component groups servers by NAS (7) and Protocol (6)
- App.tsx integrates all components with useSignalR hook
- Build completes without TypeScript errors
</success_criteria>

<output>
After completion, create `.planning/phases/07-real-time-monitoring-dashboard/07-02-SUMMARY.md`
</output>
