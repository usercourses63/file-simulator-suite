---
phase: 06-backend-api-foundation
plan: 03
type: execute
wave: 2
depends_on: ["06-01", "06-02"]
files_modified:
  - src/FileSimulator.ControlApi/Hubs/ServerStatusHub.cs
  - src/FileSimulator.ControlApi/Services/KubernetesDiscoveryService.cs
  - src/FileSimulator.ControlApi/Services/HealthCheckService.cs
  - src/FileSimulator.ControlApi/Services/ServerStatusBroadcaster.cs
  - src/FileSimulator.ControlApi/Models/ServerStatus.cs
  - src/FileSimulator.ControlApi/Program.cs
autonomous: true

must_haves:
  truths:
    - "KubernetesClient lists all pods in file-simulator namespace"
    - "SignalR hub broadcasts ServerStatus updates to connected clients"
    - "Health check service validates TCP connectivity to protocol servers"
    - "GET /api/servers returns JSON list of discovered servers"
    - "WebSocket connection to /hubs/status receives periodic status updates"
    - "v1.0 servers (7 NAS + 6 protocols) remain operational during testing"
  artifacts:
    - path: "src/FileSimulator.ControlApi/Hubs/ServerStatusHub.cs"
      provides: "SignalR hub for real-time status broadcasting"
      contains: "class ServerStatusHub"
    - path: "src/FileSimulator.ControlApi/Services/KubernetesDiscoveryService.cs"
      provides: "Kubernetes API integration for server discovery"
      contains: "IKubernetes"
    - path: "src/FileSimulator.ControlApi/Services/HealthCheckService.cs"
      provides: "Protocol-specific health checking"
      contains: "TcpClient"
    - path: "src/FileSimulator.ControlApi/Services/ServerStatusBroadcaster.cs"
      provides: "Background service for periodic status collection and broadcast"
      contains: "BackgroundService"
  key_links:
    - from: "ServerStatusBroadcaster.cs"
      to: "ServerStatusHub.cs"
      via: "IHubContext injection"
      pattern: "IHubContext<ServerStatusHub>"
    - from: "ServerStatusBroadcaster.cs"
      to: "KubernetesDiscoveryService.cs"
      via: "Service discovery call"
      pattern: "IKubernetesDiscoveryService"
    - from: "Program.cs"
      to: "All services"
      via: "DI registration"
      pattern: "AddHostedService<ServerStatusBroadcaster>"
---

<objective>
Implement SignalR hub, Kubernetes discovery, and health check services to complete the backend control plane foundation.

Purpose: Enable real-time server status broadcasting via SignalR, Kubernetes API integration for discovering existing protocol servers, and health check services that validate connectivity. This completes Phase 6's backend foundation for Phase 7's React dashboard.

Output: Fully functional backend API that discovers servers, checks health, and broadcasts status via WebSocket.
</objective>

<execution_context>
@C:\Users\UserC\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\UserC\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-backend-api-foundation/06-CONTEXT.md
@.planning/phases/06-backend-api-foundation/06-01-SUMMARY.md
@.planning/phases/06-backend-api-foundation/06-02-SUMMARY.md
@src/FileSimulator.ControlApi/Program.cs
@helm-chart/file-simulator/values.yaml
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Data Models and Interfaces</name>
  <files>
    src/FileSimulator.ControlApi/Models/ServerStatus.cs
    src/FileSimulator.ControlApi/Models/DiscoveredServer.cs
    src/FileSimulator.ControlApi/Services/IKubernetesDiscoveryService.cs
    src/FileSimulator.ControlApi/Services/IHealthCheckService.cs
  </files>
  <action>
Create model classes and service interfaces:

**Models/ServerStatus.cs:**
```csharp
namespace FileSimulator.ControlApi.Models;

/// <summary>
/// Real-time status of a protocol server, broadcast via SignalR.
/// </summary>
public record ServerStatus
{
    public required string Name { get; init; }
    public required string Protocol { get; init; }  // FTP, SFTP, NFS, HTTP, S3, SMB
    public required string PodStatus { get; init; }  // Running, Pending, Failed
    public required bool IsHealthy { get; init; }
    public string? HealthMessage { get; init; }
    public int? LatencyMs { get; init; }
    public DateTime CheckedAt { get; init; } = DateTime.UtcNow;
}

/// <summary>
/// Collection of all server statuses, broadcast as single message.
/// </summary>
public record ServerStatusUpdate
{
    public required IReadOnlyList<ServerStatus> Servers { get; init; }
    public DateTime Timestamp { get; init; } = DateTime.UtcNow;
    public int TotalServers => Servers.Count;
    public int HealthyServers => Servers.Count(s => s.IsHealthy);
}
```

**Models/DiscoveredServer.cs:**
```csharp
namespace FileSimulator.ControlApi.Models;

/// <summary>
/// Server discovered via Kubernetes API, before health check.
/// </summary>
public record DiscoveredServer
{
    public required string Name { get; init; }
    public required string PodName { get; init; }
    public required string Protocol { get; init; }
    public required string ServiceName { get; init; }
    public required string ClusterIp { get; init; }
    public required int Port { get; init; }
    public int? NodePort { get; init; }
    public required string PodStatus { get; init; }
    public required bool PodReady { get; init; }
    public DateTime DiscoveredAt { get; init; } = DateTime.UtcNow;
}
```

**Services/IKubernetesDiscoveryService.cs:**
```csharp
namespace FileSimulator.ControlApi.Services;

using FileSimulator.ControlApi.Models;

public interface IKubernetesDiscoveryService
{
    /// <summary>
    /// Discover all protocol servers in the namespace.
    /// </summary>
    Task<IReadOnlyList<DiscoveredServer>> DiscoverServersAsync(CancellationToken ct = default);

    /// <summary>
    /// Get server details by name.
    /// </summary>
    Task<DiscoveredServer?> GetServerAsync(string name, CancellationToken ct = default);
}
```

**Services/IHealthCheckService.cs:**
```csharp
namespace FileSimulator.ControlApi.Services;

using FileSimulator.ControlApi.Models;

public interface IHealthCheckService
{
    /// <summary>
    /// Check health of a discovered server.
    /// </summary>
    Task<ServerStatus> CheckHealthAsync(DiscoveredServer server, CancellationToken ct = default);

    /// <summary>
    /// Check health of all discovered servers.
    /// </summary>
    Task<IReadOnlyList<ServerStatus>> CheckAllHealthAsync(
        IEnumerable<DiscoveredServer> servers,
        CancellationToken ct = default);
}
```

Create directories first:
```bash
mkdir -p src/FileSimulator.ControlApi/Models
mkdir -p src/FileSimulator.ControlApi/Services
mkdir -p src/FileSimulator.ControlApi/Hubs
```
  </action>
  <verify>
```bash
dotnet build src/FileSimulator.ControlApi/FileSimulator.ControlApi.csproj
```
Should compile without errors (interfaces and records are valid).
  </verify>
  <done>
Model classes (ServerStatus, ServerStatusUpdate, DiscoveredServer) and service interfaces (IKubernetesDiscoveryService, IHealthCheckService) created. Project compiles successfully.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement Kubernetes Discovery Service</name>
  <files>src/FileSimulator.ControlApi/Services/KubernetesDiscoveryService.cs</files>
  <action>
Implement KubernetesDiscoveryService using KubernetesClient:

```csharp
namespace FileSimulator.ControlApi.Services;

using k8s;
using k8s.Models;
using FileSimulator.ControlApi.Models;
using Microsoft.Extensions.Options;

public class KubernetesOptions
{
    public bool InCluster { get; set; } = true;
    public string Namespace { get; set; } = "file-simulator";
}

public class KubernetesDiscoveryService : IKubernetesDiscoveryService
{
    private readonly IKubernetes _client;
    private readonly KubernetesOptions _options;
    private readonly ILogger<KubernetesDiscoveryService> _logger;

    // Label selectors for file-simulator components
    private const string AppLabel = "app.kubernetes.io/part-of";
    private const string AppValue = "file-simulator-suite";

    // Protocol detection from deployment names
    private static readonly Dictionary<string, string> ProtocolMappings = new()
    {
        { "ftp", "FTP" },
        { "sftp", "SFTP" },
        { "nas", "NFS" },
        { "http", "HTTP" },
        { "s3", "S3" },
        { "smb", "SMB" },
        { "management", "HTTP" }  // FileBrowser
    };

    public KubernetesDiscoveryService(
        IOptions<KubernetesOptions> options,
        ILogger<KubernetesDiscoveryService> logger)
    {
        _options = options.Value;
        _logger = logger;

        // Create K8s client based on environment
        if (_options.InCluster)
        {
            var config = KubernetesClientConfiguration.InClusterConfig();
            _client = new Kubernetes(config);
            _logger.LogInformation("Kubernetes client configured for in-cluster access");
        }
        else
        {
            var config = KubernetesClientConfiguration.BuildConfigFromConfigFile();
            _client = new Kubernetes(config);
            _logger.LogInformation("Kubernetes client configured from kubeconfig");
        }
    }

    public async Task<IReadOnlyList<DiscoveredServer>> DiscoverServersAsync(CancellationToken ct = default)
    {
        var servers = new List<DiscoveredServer>();

        try
        {
            // Get all pods in namespace with file-simulator labels
            var pods = await _client.CoreV1.ListNamespacedPodAsync(
                _options.Namespace,
                labelSelector: $"{AppLabel}={AppValue}",
                cancellationToken: ct);

            // Get all services in namespace
            var services = await _client.CoreV1.ListNamespacedServiceAsync(
                _options.Namespace,
                labelSelector: $"{AppLabel}={AppValue}",
                cancellationToken: ct);

            _logger.LogDebug("Found {PodCount} pods and {ServiceCount} services",
                pods.Items.Count, services.Items.Count);

            // Match pods to services
            foreach (var pod in pods.Items)
            {
                // Skip control-api itself
                if (pod.Metadata.Name.Contains("control-api"))
                    continue;

                var protocol = DetectProtocol(pod.Metadata.Name);
                if (protocol == null)
                {
                    _logger.LogDebug("Skipping pod {Pod} - unknown protocol", pod.Metadata.Name);
                    continue;
                }

                // Find matching service
                var service = FindMatchingService(pod, services.Items);
                if (service == null)
                {
                    _logger.LogWarning("No service found for pod {Pod}", pod.Metadata.Name);
                    continue;
                }

                var port = service.Spec.Ports.FirstOrDefault();
                var nodePort = port?.NodePort;

                servers.Add(new DiscoveredServer
                {
                    Name = GetServerName(pod.Metadata.Name),
                    PodName = pod.Metadata.Name,
                    Protocol = protocol,
                    ServiceName = service.Metadata.Name,
                    ClusterIp = service.Spec.ClusterIP,
                    Port = port?.Port ?? 0,
                    NodePort = nodePort,
                    PodStatus = pod.Status.Phase,
                    PodReady = IsPodReady(pod)
                });
            }

            _logger.LogInformation("Discovered {Count} protocol servers", servers.Count);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Failed to discover servers from Kubernetes API");
        }

        return servers;
    }

    public async Task<DiscoveredServer?> GetServerAsync(string name, CancellationToken ct = default)
    {
        var servers = await DiscoverServersAsync(ct);
        return servers.FirstOrDefault(s =>
            s.Name.Equals(name, StringComparison.OrdinalIgnoreCase));
    }

    private static string? DetectProtocol(string podName)
    {
        foreach (var (key, value) in ProtocolMappings)
        {
            if (podName.Contains(key, StringComparison.OrdinalIgnoreCase))
                return value;
        }
        return null;
    }

    private static string GetServerName(string podName)
    {
        // Extract meaningful name: "file-sim-file-simulator-nas-input-1-xxx" -> "nas-input-1"
        var parts = podName.Split('-');

        // Look for NAS patterns
        for (int i = 0; i < parts.Length - 1; i++)
        {
            if (parts[i] == "nas" && i + 2 < parts.Length)
            {
                // nas-input-1, nas-output-2, nas-backup
                var nasType = parts[i + 1];
                if (nasType == "backup")
                    return "nas-backup";
                if (i + 2 < parts.Length && int.TryParse(parts[i + 2], out _))
                    return $"nas-{nasType}-{parts[i + 2]}";
            }
        }

        // For other protocols, use second-to-last meaningful part
        foreach (var (key, _) in ProtocolMappings)
        {
            if (podName.Contains(key, StringComparison.OrdinalIgnoreCase))
                return key;
        }

        return podName;
    }

    private static V1Service? FindMatchingService(V1Pod pod, IList<V1Service> services)
    {
        // Match by selector labels
        var podLabels = pod.Metadata.Labels ?? new Dictionary<string, string>();

        foreach (var service in services)
        {
            var selector = service.Spec.Selector;
            if (selector == null) continue;

            bool matches = selector.All(kv =>
                podLabels.TryGetValue(kv.Key, out var value) && value == kv.Value);

            if (matches)
                return service;
        }

        return null;
    }

    private static bool IsPodReady(V1Pod pod)
    {
        var readyCondition = pod.Status.Conditions?
            .FirstOrDefault(c => c.Type == "Ready");
        return readyCondition?.Status == "True";
    }
}
```

**Key design:**
- Uses InCluster config when running in Kubernetes, kubeconfig when local
- Label selector finds only file-simulator components
- Skips control-api itself (not a protocol server)
- Matches pods to services via selector labels
- Extracts meaningful server names (nas-input-1, ftp, sftp, etc.)
  </action>
  <verify>
```bash
dotnet build src/FileSimulator.ControlApi/FileSimulator.ControlApi.csproj
```
Should compile without errors.
  </verify>
  <done>
KubernetesDiscoveryService implemented with InCluster/kubeconfig support, label-based pod discovery, service matching, and protocol detection. Correctly identifies all 7 NAS + 6 protocol servers.
  </done>
</task>

<task type="auto">
  <name>Task 3: Implement Health Check Service</name>
  <files>src/FileSimulator.ControlApi/Services/HealthCheckService.cs</files>
  <action>
Implement HealthCheckService with TCP connectivity checks:

```csharp
namespace FileSimulator.ControlApi.Services;

using System.Diagnostics;
using System.Net.Sockets;
using FileSimulator.ControlApi.Models;

public class HealthCheckService : IHealthCheckService
{
    private readonly ILogger<HealthCheckService> _logger;
    private readonly TimeSpan _timeout = TimeSpan.FromSeconds(5);

    public HealthCheckService(ILogger<HealthCheckService> logger)
    {
        _logger = logger;
    }

    public async Task<ServerStatus> CheckHealthAsync(DiscoveredServer server, CancellationToken ct = default)
    {
        // If pod isn't ready, don't bother with TCP check
        if (!server.PodReady)
        {
            return new ServerStatus
            {
                Name = server.Name,
                Protocol = server.Protocol,
                PodStatus = server.PodStatus,
                IsHealthy = false,
                HealthMessage = $"Pod not ready: {server.PodStatus}"
            };
        }

        var sw = Stopwatch.StartNew();
        bool isHealthy;
        string? message = null;

        try
        {
            isHealthy = await CheckTcpConnectivityAsync(
                server.ClusterIp,
                server.Port,
                ct);

            if (!isHealthy)
            {
                message = "TCP connection failed";
            }
        }
        catch (OperationCanceledException)
        {
            isHealthy = false;
            message = "Health check cancelled";
        }
        catch (Exception ex)
        {
            isHealthy = false;
            message = $"Health check error: {ex.Message}";
            _logger.LogWarning(ex, "Health check failed for {Server}", server.Name);
        }

        sw.Stop();

        return new ServerStatus
        {
            Name = server.Name,
            Protocol = server.Protocol,
            PodStatus = server.PodStatus,
            IsHealthy = isHealthy,
            HealthMessage = message,
            LatencyMs = (int)sw.ElapsedMilliseconds
        };
    }

    public async Task<IReadOnlyList<ServerStatus>> CheckAllHealthAsync(
        IEnumerable<DiscoveredServer> servers,
        CancellationToken ct = default)
    {
        // Run health checks in parallel for speed
        var tasks = servers.Select(s => CheckHealthAsync(s, ct));
        var results = await Task.WhenAll(tasks);

        var healthy = results.Count(r => r.IsHealthy);
        _logger.LogInformation(
            "Health check complete: {Healthy}/{Total} servers healthy",
            healthy, results.Length);

        return results;
    }

    private async Task<bool> CheckTcpConnectivityAsync(
        string host,
        int port,
        CancellationToken ct)
    {
        using var cts = CancellationTokenSource.CreateLinkedTokenSource(ct);
        cts.CancelAfter(_timeout);

        try
        {
            using var client = new TcpClient();
            await client.ConnectAsync(host, port, cts.Token);
            return client.Connected;
        }
        catch (SocketException ex)
        {
            _logger.LogDebug(
                "TCP check failed for {Host}:{Port} - {Error}",
                host, port, ex.SocketErrorCode);
            return false;
        }
        catch (OperationCanceledException)
        {
            _logger.LogDebug(
                "TCP check timed out for {Host}:{Port}",
                host, port);
            return false;
        }
    }
}
```

**Design decisions:**
- TCP-level health check (not protocol-specific)
  - FTP: TCP 21
  - SFTP: TCP 22
  - NFS: TCP 2049
  - HTTP: TCP 80
  - S3: TCP 9000
  - SMB: TCP 445
- 5-second timeout per check
- Parallel checks for all servers
- Returns latency in milliseconds for dashboard display
- Graceful handling of pod not ready state
  </action>
  <verify>
```bash
dotnet build src/FileSimulator.ControlApi/FileSimulator.ControlApi.csproj
```
Should compile without errors.
  </verify>
  <done>
HealthCheckService implemented with TCP connectivity checks, 5s timeout, parallel execution, and latency measurement. Handles pod-not-ready and connection errors gracefully.
  </done>
</task>

<task type="auto">
  <name>Task 4: Implement SignalR Hub and Broadcaster</name>
  <files>
    src/FileSimulator.ControlApi/Hubs/ServerStatusHub.cs
    src/FileSimulator.ControlApi/Services/ServerStatusBroadcaster.cs
  </files>
  <action>
**Hubs/ServerStatusHub.cs:**
```csharp
namespace FileSimulator.ControlApi.Hubs;

using Microsoft.AspNetCore.SignalR;
using FileSimulator.ControlApi.Models;

/// <summary>
/// SignalR hub for real-time server status updates.
/// Clients connect to receive periodic status broadcasts.
/// </summary>
public class ServerStatusHub : Hub
{
    private readonly ILogger<ServerStatusHub> _logger;

    public ServerStatusHub(ILogger<ServerStatusHub> logger)
    {
        _logger = logger;
    }

    public override async Task OnConnectedAsync()
    {
        _logger.LogInformation(
            "Client connected: {ConnectionId}",
            Context.ConnectionId);
        await base.OnConnectedAsync();
    }

    public override async Task OnDisconnectedAsync(Exception? exception)
    {
        if (exception != null)
        {
            _logger.LogWarning(exception,
                "Client disconnected with error: {ConnectionId}",
                Context.ConnectionId);
        }
        else
        {
            _logger.LogInformation(
                "Client disconnected: {ConnectionId}",
                Context.ConnectionId);
        }
        await base.OnDisconnectedAsync(exception);
    }

    /// <summary>
    /// Client can request immediate status update.
    /// </summary>
    public async Task RequestStatus()
    {
        _logger.LogDebug(
            "Status request from: {ConnectionId}",
            Context.ConnectionId);

        // Broadcaster will handle this by sending to just this client
        await Clients.Caller.SendAsync("StatusRequested");
    }
}
```

**Services/ServerStatusBroadcaster.cs:**
```csharp
namespace FileSimulator.ControlApi.Services;

using Microsoft.AspNetCore.SignalR;
using FileSimulator.ControlApi.Hubs;
using FileSimulator.ControlApi.Models;

/// <summary>
/// Background service that periodically discovers servers,
/// checks health, and broadcasts status via SignalR.
/// </summary>
public class ServerStatusBroadcaster : BackgroundService
{
    private readonly IHubContext<ServerStatusHub> _hubContext;
    private readonly IKubernetesDiscoveryService _discovery;
    private readonly IHealthCheckService _healthCheck;
    private readonly ILogger<ServerStatusBroadcaster> _logger;

    // Broadcast interval - matches dashboard refresh expectations
    private readonly TimeSpan _interval = TimeSpan.FromSeconds(5);

    // Cache latest status for API requests
    private ServerStatusUpdate? _latestStatus;
    private readonly object _statusLock = new();

    public ServerStatusBroadcaster(
        IHubContext<ServerStatusHub> hubContext,
        IKubernetesDiscoveryService discovery,
        IHealthCheckService healthCheck,
        ILogger<ServerStatusBroadcaster> logger)
    {
        _hubContext = hubContext;
        _discovery = discovery;
        _healthCheck = healthCheck;
        _logger = logger;
    }

    /// <summary>
    /// Get the latest cached status (for REST API endpoint).
    /// </summary>
    public ServerStatusUpdate? GetLatestStatus()
    {
        lock (_statusLock)
        {
            return _latestStatus;
        }
    }

    protected override async Task ExecuteAsync(CancellationToken stoppingToken)
    {
        _logger.LogInformation(
            "ServerStatusBroadcaster started, interval: {Interval}s",
            _interval.TotalSeconds);

        // Initial delay to let K8s client initialize
        await Task.Delay(TimeSpan.FromSeconds(2), stoppingToken);

        while (!stoppingToken.IsCancellationRequested)
        {
            try
            {
                await BroadcastStatusAsync(stoppingToken);
            }
            catch (OperationCanceledException) when (stoppingToken.IsCancellationRequested)
            {
                break;
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error during status broadcast");
            }

            await Task.Delay(_interval, stoppingToken);
        }

        _logger.LogInformation("ServerStatusBroadcaster stopped");
    }

    private async Task BroadcastStatusAsync(CancellationToken ct)
    {
        // Discover servers
        var servers = await _discovery.DiscoverServersAsync(ct);

        if (servers.Count == 0)
        {
            _logger.LogWarning("No servers discovered - is RBAC configured?");
            return;
        }

        // Check health of all servers
        var statuses = await _healthCheck.CheckAllHealthAsync(servers, ct);

        // Create update message
        var update = new ServerStatusUpdate
        {
            Servers = statuses
        };

        // Cache for REST API
        lock (_statusLock)
        {
            _latestStatus = update;
        }

        // Broadcast to all connected clients
        await _hubContext.Clients.All.SendAsync(
            "ServerStatusUpdate",
            update,
            ct);

        _logger.LogDebug(
            "Broadcast status: {Healthy}/{Total} healthy",
            update.HealthyServers, update.TotalServers);
    }
}
```

**Key design:**
- 5-second broadcast interval matches Phase 7 dashboard requirements
- Caches latest status for REST API endpoint
- Background service pattern for continuous operation
- Broadcasts to all connected SignalR clients
- Graceful shutdown on SIGTERM
  </action>
  <verify>
```bash
dotnet build src/FileSimulator.ControlApi/FileSimulator.ControlApi.csproj
```
Should compile without errors.
  </verify>
  <done>
ServerStatusHub (SignalR) and ServerStatusBroadcaster (BackgroundService) implemented. Broadcasts server status every 5 seconds to all connected WebSocket clients. Caches latest status for REST API.
  </done>
</task>

<task type="auto">
  <name>Task 5: Update Program.cs with Service Registration and API Endpoints</name>
  <files>src/FileSimulator.ControlApi/Program.cs</files>
  <action>
Update Program.cs to wire up all services and add REST endpoints:

**Replace the placeholder ServerStatusHub with proper registration:**

1. **Remove inline ServerStatusHub class** (now in Hubs/ folder)

2. **Add service registrations:**
```csharp
// Configuration
builder.Services.Configure<KubernetesOptions>(
    builder.Configuration.GetSection("Kubernetes"));

// Services
builder.Services.AddSingleton<IKubernetesDiscoveryService, KubernetesDiscoveryService>();
builder.Services.AddSingleton<IHealthCheckService, HealthCheckService>();
builder.Services.AddSingleton<ServerStatusBroadcaster>();
builder.Services.AddHostedService(sp => sp.GetRequiredService<ServerStatusBroadcaster>());
```

3. **Add REST API endpoints** (after middleware setup):
```csharp
// API: List all discovered servers
app.MapGet("/api/servers", async (IKubernetesDiscoveryService discovery, CancellationToken ct) =>
{
    var servers = await discovery.DiscoverServersAsync(ct);
    return Results.Ok(servers);
})
.WithName("GetServers")
.WithOpenApi();

// API: Get current status (from broadcaster cache)
app.MapGet("/api/status", (ServerStatusBroadcaster broadcaster) =>
{
    var status = broadcaster.GetLatestStatus();
    return status != null
        ? Results.Ok(status)
        : Results.NotFound("Status not yet available");
})
.WithName("GetStatus")
.WithOpenApi();

// API: Get specific server
app.MapGet("/api/servers/{name}", async (
    string name,
    IKubernetesDiscoveryService discovery,
    CancellationToken ct) =>
{
    var server = await discovery.GetServerAsync(name, ct);
    return server != null
        ? Results.Ok(server)
        : Results.NotFound($"Server '{name}' not found");
})
.WithName("GetServer")
.WithOpenApi();
```

4. **Update hub mapping:**
```csharp
app.MapHub<ServerStatusHub>("/hubs/status");
```

5. **Add usings at top:**
```csharp
using FileSimulator.ControlApi.Hubs;
using FileSimulator.ControlApi.Services;
using FileSimulator.ControlApi.Models;
```

**Final Program.cs structure:**
- Serilog configuration
- Builder with services (SignalR, CORS, HealthChecks, custom services)
- App with middleware (Serilog, CORS)
- Endpoints (health, hub, REST APIs)
- Graceful shutdown
  </action>
  <verify>
```bash
dotnet build src/FileSimulator.ControlApi/FileSimulator.ControlApi.csproj
```
Should compile without errors.

Local run test (K8s calls will fail but HTTP should work):
```bash
cd src/FileSimulator.ControlApi && dotnet run &
sleep 5
curl -s http://localhost:5000/health
curl -s http://localhost:5000/api/servers  # Will return [] or error (no K8s)
curl -s http://localhost:5000/
kill %1
```
Health should return "Healthy", /api/servers may return empty or error depending on kubeconfig.
  </verify>
  <done>
Program.cs updated with all service registrations, REST API endpoints (/api/servers, /api/status, /api/servers/{name}), and proper using statements. Application compiles and runs locally.
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. Project compiles:
   ```bash
   dotnet build src/FileSimulator.ControlApi/FileSimulator.ControlApi.csproj
   ```

2. Container builds:
   ```bash
   cd src && docker build -f FileSimulator.ControlApi/Dockerfile -t file-simulator-control-api:dev .
   ```

3. Load image into Minikube and deploy (requires 06-02 Helm templates):
   ```bash
   # Load image into Minikube
   minikube -p file-simulator image load file-simulator-control-api:dev

   # Deploy with Helm
   helm upgrade --install file-sim ./helm-chart/file-simulator \
       --kube-context=file-simulator \
       --namespace file-simulator

   # Wait for control-api pod
   kubectl --context=file-simulator wait --for=condition=ready pod \
       -l app.kubernetes.io/component=control-api \
       -n file-simulator --timeout=60s

   # Test REST API
   CONTROL_IP=$(minikube -p file-simulator ip)
   curl -s http://${CONTROL_IP}:30500/health
   curl -s http://${CONTROL_IP}:30500/api/servers
   curl -s http://${CONTROL_IP}:30500/api/status
   ```

4. Verify server discovery:
   ```bash
   curl -s http://${CONTROL_IP}:30500/api/servers | jq '.[] | .name'
   ```
   Should list: ftp, sftp, nas-input-1, nas-input-2, nas-input-3, nas-backup, nas-output-1, nas-output-2, nas-output-3, http, s3, smb, management (13 total)

5. Verify health status:
   ```bash
   curl -s http://${CONTROL_IP}:30500/api/status | jq '.healthyServers'
   ```
   Should return 13 (or close to it if some servers still starting)

6. Verify v1.0 servers still operational:
   ```bash
   kubectl --context=file-simulator get pods -n file-simulator -o wide
   ```
   All existing pods should show Running/Ready status.
</verification>

<success_criteria>
1. Models (ServerStatus, DiscoveredServer) compile with required properties
2. IKubernetesDiscoveryService and IHealthCheckService interfaces defined
3. KubernetesDiscoveryService discovers pods via K8s API with label selector
4. HealthCheckService performs TCP connectivity checks with timeout
5. ServerStatusHub handles client connections/disconnections
6. ServerStatusBroadcaster runs as BackgroundService with 5s interval
7. REST endpoints return server list and status
8. Container builds and runs successfully
9. When deployed, discovers all 13 v1.0 servers (7 NAS + 6 protocols)
10. v1.0 servers remain operational (success criteria #5 from phase)
</success_criteria>

<output>
After completion, create `.planning/phases/06-backend-api-foundation/06-03-SUMMARY.md`
</output>
