---
phase: 06-backend-api-foundation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/FileSimulator.ControlApi/FileSimulator.ControlApi.csproj
  - src/FileSimulator.ControlApi/Program.cs
  - src/FileSimulator.ControlApi/Dockerfile
  - src/FileSimulator.ControlApi/appsettings.json
  - src/FileSimulator.ControlApi/appsettings.Development.json
autonomous: true

must_haves:
  truths:
    - "dotnet build src/FileSimulator.ControlApi succeeds without errors"
    - "dotnet run starts Kestrel on configured ports"
    - "GET /health returns 200 OK"
    - "Dockerfile builds successfully with docker build"
    - "Container runs and responds to health check"
  artifacts:
    - path: "src/FileSimulator.ControlApi/FileSimulator.ControlApi.csproj"
      provides: "ASP.NET Core 9.0 project with required NuGet packages"
      contains: "KubernetesClient"
    - path: "src/FileSimulator.ControlApi/Program.cs"
      provides: "Minimal API with SignalR hub registration"
      contains: "MapHub"
    - path: "src/FileSimulator.ControlApi/Dockerfile"
      provides: "Multi-stage Docker build for .NET 9.0"
      contains: "mcr.microsoft.com/dotnet/aspnet:9.0"
  key_links:
    - from: "Program.cs"
      to: "SignalR"
      via: "AddSignalR() and MapHub()"
      pattern: "builder\\.Services\\.AddSignalR"
    - from: "Dockerfile"
      to: "csproj"
      via: "dotnet restore and publish"
      pattern: "dotnet publish"
---

<objective>
Create the ASP.NET Core 9.0 Control API project with SignalR hub registration and Docker containerization.

Purpose: Establish the foundational backend project structure with all required dependencies (SignalR, KubernetesClient, health checks). This project will host the real-time communication hub and Kubernetes integration for Phase 7's dashboard.

Output: Buildable .NET project with Dockerfile ready for Helm deployment.
</objective>

<execution_context>
@C:\Users\UserC\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\UserC\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-backend-api-foundation/06-CONTEXT.md
@src/FileSimulator.Client/FileSimulator.Client.csproj
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create ASP.NET Core Project with Dependencies</name>
  <files>src/FileSimulator.ControlApi/FileSimulator.ControlApi.csproj</files>
  <action>
Create the ASP.NET Core 9.0 minimal API project with required NuGet packages.

1. Create project directory:
   ```bash
   mkdir -p src/FileSimulator.ControlApi
   ```

2. Create FileSimulator.ControlApi.csproj with:
   - TargetFramework: net9.0
   - Sdk: Microsoft.NET.Sdk.Web
   - ImplicitUsings and Nullable enabled
   - Required packages:
     - KubernetesClient (official .NET K8s API client)
     - Microsoft.AspNetCore.SignalR (built into ASP.NET Core)
     - Microsoft.Extensions.Diagnostics.HealthChecks
     - Serilog.AspNetCore (structured logging)
     - Serilog.Sinks.Console

3. Include project reference to FileSimulator.Client (for future protocol health checks using existing services).

NuGet package versions (latest stable):
- KubernetesClient: 13.0.1 (supports .NET 8/9)
- Serilog.AspNetCore: 8.0.3
- Serilog.Sinks.Console: 6.0.0

Do NOT add Microsoft.AspNetCore.SignalR as explicit package - it's part of the ASP.NET Core shared framework.
  </action>
  <verify>
```bash
cd src/FileSimulator.ControlApi && dotnet restore
```
Should complete without errors. Verify package references exist:
```bash
grep -E "(KubernetesClient|Serilog)" src/FileSimulator.ControlApi/FileSimulator.ControlApi.csproj
```
  </verify>
  <done>
FileSimulator.ControlApi.csproj created with net9.0 target, KubernetesClient package, Serilog logging, and project reference to FileSimulator.Client.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create Program.cs with Minimal API and SignalR Setup</name>
  <files>
    src/FileSimulator.ControlApi/Program.cs
    src/FileSimulator.ControlApi/appsettings.json
    src/FileSimulator.ControlApi/appsettings.Development.json
  </files>
  <action>
Create Program.cs with ASP.NET Core minimal API pattern:

**Program.cs structure:**

1. **Serilog configuration** (before builder creation):
   ```csharp
   Log.Logger = new LoggerConfiguration()
       .MinimumLevel.Information()
       .MinimumLevel.Override("Microsoft.AspNetCore", LogEventLevel.Warning)
       .WriteTo.Console(outputTemplate: "[{Timestamp:HH:mm:ss} {Level:u3}] {Message:lj}{NewLine}{Exception}")
       .CreateLogger();
   ```

2. **Builder configuration:**
   - AddSignalR() with JSON protocol
   - AddHealthChecks()
   - AddCors() with AllowAnyOrigin for development (Phase 7 dashboard needs this)
   - Configure Kestrel to listen on port 5000 (HTTP) and 5001 (HTTPS)

3. **Placeholder hub class** (inline in Program.cs for now):
   ```csharp
   public class ServerStatusHub : Hub
   {
       public override async Task OnConnectedAsync()
       {
           await base.OnConnectedAsync();
           Log.Information("Client connected: {ConnectionId}", Context.ConnectionId);
       }

       public override async Task OnDisconnectedAsync(Exception? exception)
       {
           Log.Information("Client disconnected: {ConnectionId}", Context.ConnectionId);
           await base.OnDisconnectedAsync(exception);
       }
   }
   ```

4. **Middleware pipeline:**
   - UseSerilogRequestLogging()
   - UseCors()
   - MapHealthChecks("/health")
   - MapHub<ServerStatusHub>("/hubs/status")
   - GET "/" returns API info JSON
   - GET "/api/version" returns version info

5. **Graceful shutdown:**
   - Handle SIGTERM for Kubernetes pod termination

**appsettings.json:**
```json
{
  "AllowedHosts": "*",
  "Kestrel": {
    "Endpoints": {
      "Http": { "Url": "http://0.0.0.0:5000" }
    }
  },
  "Kubernetes": {
    "InCluster": true,
    "Namespace": "file-simulator"
  }
}
```

**appsettings.Development.json:**
```json
{
  "Kestrel": {
    "Endpoints": {
      "Http": { "Url": "http://localhost:5000" },
      "Https": { "Url": "https://localhost:5001" }
    }
  },
  "Kubernetes": {
    "InCluster": false
  }
}
```
  </action>
  <verify>
```bash
cd src/FileSimulator.ControlApi && dotnet build
```
Should complete without errors.

Run locally (will fail K8s connection but HTTP should work):
```bash
cd src/FileSimulator.ControlApi && dotnet run &
sleep 3
curl -s http://localhost:5000/health
curl -s http://localhost:5000/
kill %1
```
Health endpoint should return "Healthy".
  </verify>
  <done>
Program.cs created with SignalR hub registration, health check endpoint, CORS for dashboard, and Serilog logging. Application starts successfully and responds to /health and / endpoints.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create Dockerfile for Container Build</name>
  <files>src/FileSimulator.ControlApi/Dockerfile</files>
  <action>
Create multi-stage Dockerfile optimized for .NET 9.0:

```dockerfile
# Build stage
FROM mcr.microsoft.com/dotnet/sdk:9.0 AS build
WORKDIR /src

# Copy csproj files and restore (layer caching)
COPY ["FileSimulator.ControlApi/FileSimulator.ControlApi.csproj", "FileSimulator.ControlApi/"]
COPY ["FileSimulator.Client/FileSimulator.Client.csproj", "FileSimulator.Client/"]
RUN dotnet restore "FileSimulator.ControlApi/FileSimulator.ControlApi.csproj"

# Copy source and build
COPY . .
WORKDIR "/src/FileSimulator.ControlApi"
RUN dotnet publish -c Release -o /app/publish --no-restore

# Runtime stage
FROM mcr.microsoft.com/dotnet/aspnet:9.0 AS runtime
WORKDIR /app

# Create non-root user for security
RUN addgroup --gid 1000 appgroup && \
    adduser --uid 1000 --gid 1000 --disabled-password --gecos "" appuser

# Copy published app
COPY --from=build /app/publish .

# Set ownership and switch to non-root user
RUN chown -R appuser:appgroup /app
USER appuser

# Expose port (Kestrel default)
EXPOSE 5000

# Health check
HEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \
    CMD curl -f http://localhost:5000/health || exit 1

# Entry point
ENTRYPOINT ["dotnet", "FileSimulator.ControlApi.dll"]
```

**Key decisions:**
- Multi-stage build reduces final image size (~200MB vs ~800MB with SDK)
- Non-root user (appuser:1000) for Kubernetes security best practices
- Health check built into container (Kubernetes will also have liveness/readiness probes)
- Port 5000 matches Kestrel configuration
- --no-restore in publish since restore already ran (faster builds)

**Note:** Dockerfile is placed in src/FileSimulator.ControlApi/ but build context should be src/ to include FileSimulator.Client dependency.
  </action>
  <verify>
Build the container image (from src/ directory):
```bash
cd src && docker build -f FileSimulator.ControlApi/Dockerfile -t file-simulator-control-api:dev .
```
Should complete successfully.

Test container runs:
```bash
docker run -d --name control-api-test -p 5000:5000 file-simulator-control-api:dev
sleep 5
curl -s http://localhost:5000/health
docker logs control-api-test | head -10
docker stop control-api-test && docker rm control-api-test
```
Should show "Healthy" response and Serilog startup logs.
  </verify>
  <done>
Dockerfile created with multi-stage build, non-root user, health check. Container builds successfully and responds to health endpoint.
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. Project builds without errors:
   ```bash
   dotnet build src/FileSimulator.ControlApi/FileSimulator.ControlApi.csproj
   ```

2. Container builds successfully:
   ```bash
   cd src && docker build -f FileSimulator.ControlApi/Dockerfile -t file-simulator-control-api:dev .
   ```

3. Health endpoint responds:
   ```bash
   docker run -d --name test -p 5000:5000 file-simulator-control-api:dev
   curl http://localhost:5000/health
   docker rm -f test
   ```

4. SignalR hub registered (check startup logs):
   ```bash
   docker run --rm file-simulator-control-api:dev 2>&1 | head -20
   ```
   Should show Serilog startup and endpoint mapping messages.
</verification>

<success_criteria>
1. FileSimulator.ControlApi.csproj exists with net9.0 target and KubernetesClient package
2. Program.cs has SignalR hub registration (MapHub<ServerStatusHub>)
3. Program.cs has health check endpoint (/health)
4. appsettings.json configures Kestrel on port 5000
5. Dockerfile builds successfully with multi-stage pattern
6. Container image runs and responds to /health
7. Serilog logging produces structured console output
8. CORS enabled for dashboard development
</success_criteria>

<output>
After completion, create `.planning/phases/06-backend-api-foundation/06-01-SUMMARY.md`
</output>
