---
phase: 10-kafka-integration
plan: 04
type: execute
wave: 3
depends_on: ["10-03"]
files_modified:
  - src/dashboard/src/types/kafka.ts
  - src/dashboard/src/hooks/useKafka.ts
  - src/dashboard/src/hooks/useKafkaStream.ts
  - src/dashboard/src/components/KafkaTab.tsx
  - src/dashboard/src/App.tsx
  - src/dashboard/src/App.css
autonomous: true

must_haves:
  truths:
    - "Dashboard has Kafka tab in navigation"
    - "Kafka tab shows loading state while fetching topics"
    - "Topics list displays topic names and partition counts"
    - "Consumer groups section shows group IDs"
  artifacts:
    - path: "src/dashboard/src/types/kafka.ts"
      provides: "TypeScript types for Kafka data"
      contains: "TopicInfo"
    - path: "src/dashboard/src/hooks/useKafka.ts"
      provides: "Hook for Kafka API calls"
      contains: "useKafka"
    - path: "src/dashboard/src/components/KafkaTab.tsx"
      provides: "Main Kafka tab component"
      contains: "KafkaTab"
  key_links:
    - from: "KafkaTab.tsx"
      to: "useKafka hook"
      via: "hook import"
      pattern: "useKafka"
    - from: "App.tsx"
      to: "KafkaTab"
      via: "tab navigation"
      pattern: "activeTab === 'kafka'"
---

<objective>
Create frontend TypeScript types, hooks, and basic KafkaTab component structure

Purpose: Establish frontend foundation for Kafka functionality with proper typing and data fetching
Output: Types, API hooks, and skeleton KafkaTab integrated into App navigation
</objective>

<execution_context>
@C:\Users\UserC\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\UserC\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/10-kafka-integration/10-CONTEXT.md
@src/dashboard/src/types/server.ts
@src/dashboard/src/hooks/useSignalR.ts
@src/dashboard/src/App.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Kafka TypeScript types</name>
  <files>src/dashboard/src/types/kafka.ts</files>
  <action>
Create TypeScript types matching backend DTOs.

```typescript
// Kafka topic information
export interface TopicInfo {
  name: string;
  partitionCount: number;
  replicationFactor: number;
  messageCount: number;
  lastActivity: string | null;
}

// Topic creation request
export interface CreateTopicRequest {
  name: string;
  partitions: number;
  replicationFactor: number;
}

// Consumer group information (list view)
export interface ConsumerGroupInfo {
  groupId: string;
  state: string;
  memberCount: number;
  totalLag: number;
}

// Consumer group detail (expanded view)
export interface ConsumerGroupDetail {
  groupId: string;
  state: string;
  memberCount: number;
  totalLag: number;
  members: ConsumerGroupMember[];
  partitions: PartitionOffset[];
}

// Consumer group member
export interface ConsumerGroupMember {
  memberId: string;
  clientId: string;
  host: string;
}

// Partition offset information
export interface PartitionOffset {
  topic: string;
  partition: number;
  currentOffset: number;
  highWatermark: number;
  lag: number;
}

// Message to produce
export interface ProduceMessageRequest {
  topic: string;
  key: string | null;
  value: string;
}

// Produced message result
export interface ProduceMessageResult {
  topic: string;
  partition: number;
  offset: number;
  timestamp: string;
}

// Kafka message for display
export interface KafkaMessage {
  topic: string;
  partition: number;
  offset: number;
  key: string | null;
  value: string;
  timestamp: string;
}

// Offset reset request
export interface ResetOffsetsRequest {
  groupId: string;
  topic: string;
  resetTo: 'earliest' | 'latest';
}

// Lag level for color coding
export type LagLevel = 'green' | 'yellow' | 'red';

// Helper function to get lag level
export function getLagLevel(lag: number): LagLevel {
  if (lag <= 10) return 'green';
  if (lag <= 100) return 'yellow';
  return 'red';
}
```
  </action>
  <verify>
`npm run build --prefix src/dashboard` type-checks without errors
  </verify>
  <done>
All Kafka types defined matching backend DTOs, including helper function for lag coloring
  </done>
</task>

<task type="auto">
  <name>Task 2: Create useKafka hook for API calls</name>
  <files>
src/dashboard/src/hooks/useKafka.ts
src/dashboard/src/hooks/useKafkaStream.ts
  </files>
  <action>
**Create useKafka.ts:**

```typescript
import { useState, useEffect, useCallback } from 'react';
import type {
  TopicInfo,
  CreateTopicRequest,
  ConsumerGroupInfo,
  ConsumerGroupDetail,
  KafkaMessage,
  ProduceMessageRequest,
  ProduceMessageResult,
  ResetOffsetsRequest
} from '../types/kafka';

interface UseKafkaOptions {
  apiBaseUrl: string;
  refreshInterval?: number;  // Auto-refresh interval in ms (default: 5000)
}

interface UseKafkaResult {
  // Topics
  topics: TopicInfo[];
  topicsLoading: boolean;
  topicsError: string | null;
  refreshTopics: () => Promise<void>;
  createTopic: (request: CreateTopicRequest) => Promise<void>;
  deleteTopic: (name: string) => Promise<void>;

  // Consumer Groups
  consumerGroups: ConsumerGroupInfo[];
  groupsLoading: boolean;
  groupsError: string | null;
  refreshGroups: () => Promise<void>;
  getGroupDetail: (groupId: string) => Promise<ConsumerGroupDetail>;
  resetOffsets: (request: ResetOffsetsRequest) => Promise<void>;
  deleteGroup: (groupId: string) => Promise<void>;

  // Messages
  getMessages: (topic: string, count?: number) => Promise<KafkaMessage[]>;
  produceMessage: (request: ProduceMessageRequest) => Promise<ProduceMessageResult>;

  // Health
  isHealthy: boolean | null;
}

export function useKafka({ apiBaseUrl, refreshInterval = 5000 }: UseKafkaOptions): UseKafkaResult {
  const [topics, setTopics] = useState<TopicInfo[]>([]);
  const [topicsLoading, setTopicsLoading] = useState(true);
  const [topicsError, setTopicsError] = useState<string | null>(null);

  const [consumerGroups, setConsumerGroups] = useState<ConsumerGroupInfo[]>([]);
  const [groupsLoading, setGroupsLoading] = useState(true);
  const [groupsError, setGroupsError] = useState<string | null>(null);

  const [isHealthy, setIsHealthy] = useState<boolean | null>(null);

  const baseUrl = `${apiBaseUrl}/api/kafka`;

  // Fetch topics
  const refreshTopics = useCallback(async () => {
    try {
      const response = await fetch(`${baseUrl}/topics`);
      if (!response.ok) throw new Error(`HTTP ${response.status}`);
      const data = await response.json();
      setTopics(data);
      setTopicsError(null);
    } catch (err) {
      setTopicsError(err instanceof Error ? err.message : 'Failed to fetch topics');
    } finally {
      setTopicsLoading(false);
    }
  }, [baseUrl]);

  // Fetch consumer groups
  const refreshGroups = useCallback(async () => {
    try {
      const response = await fetch(`${baseUrl}/consumer-groups`);
      if (!response.ok) throw new Error(`HTTP ${response.status}`);
      const data = await response.json();
      setConsumerGroups(data);
      setGroupsError(null);
    } catch (err) {
      setGroupsError(err instanceof Error ? err.message : 'Failed to fetch groups');
    } finally {
      setGroupsLoading(false);
    }
  }, [baseUrl]);

  // Check health
  const checkHealth = useCallback(async () => {
    try {
      const response = await fetch(`${baseUrl}/health`);
      setIsHealthy(response.ok);
    } catch {
      setIsHealthy(false);
    }
  }, [baseUrl]);

  // Initial fetch and auto-refresh
  useEffect(() => {
    refreshTopics();
    refreshGroups();
    checkHealth();

    const interval = setInterval(() => {
      refreshTopics();
      refreshGroups();
      checkHealth();
    }, refreshInterval);

    return () => clearInterval(interval);
  }, [refreshTopics, refreshGroups, checkHealth, refreshInterval]);

  // Create topic
  const createTopic = useCallback(async (request: CreateTopicRequest) => {
    const response = await fetch(`${baseUrl}/topics`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(request)
    });
    if (!response.ok) {
      const error = await response.json();
      throw new Error(error.error || `HTTP ${response.status}`);
    }
    await refreshTopics();
  }, [baseUrl, refreshTopics]);

  // Delete topic
  const deleteTopic = useCallback(async (name: string) => {
    const response = await fetch(`${baseUrl}/topics/${encodeURIComponent(name)}`, {
      method: 'DELETE'
    });
    if (!response.ok) {
      const error = await response.json();
      throw new Error(error.error || `HTTP ${response.status}`);
    }
    await refreshTopics();
  }, [baseUrl, refreshTopics]);

  // Get group detail
  const getGroupDetail = useCallback(async (groupId: string): Promise<ConsumerGroupDetail> => {
    const response = await fetch(`${baseUrl}/consumer-groups/${encodeURIComponent(groupId)}`);
    if (!response.ok) {
      const error = await response.json();
      throw new Error(error.error || `HTTP ${response.status}`);
    }
    return response.json();
  }, [baseUrl]);

  // Reset offsets
  const resetOffsets = useCallback(async (request: ResetOffsetsRequest) => {
    const response = await fetch(
      `${baseUrl}/consumer-groups/${encodeURIComponent(request.groupId)}/reset`,
      {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(request)
      }
    );
    if (!response.ok) {
      const error = await response.json();
      throw new Error(error.error || `HTTP ${response.status}`);
    }
    await refreshGroups();
  }, [baseUrl, refreshGroups]);

  // Delete group
  const deleteGroup = useCallback(async (groupId: string) => {
    const response = await fetch(
      `${baseUrl}/consumer-groups/${encodeURIComponent(groupId)}`,
      { method: 'DELETE' }
    );
    if (!response.ok) {
      const error = await response.json();
      throw new Error(error.error || `HTTP ${response.status}`);
    }
    await refreshGroups();
  }, [baseUrl, refreshGroups]);

  // Get messages
  const getMessages = useCallback(async (topic: string, count = 50): Promise<KafkaMessage[]> => {
    const response = await fetch(
      `${baseUrl}/topics/${encodeURIComponent(topic)}/messages?count=${count}`
    );
    if (!response.ok) {
      const error = await response.json();
      throw new Error(error.error || `HTTP ${response.status}`);
    }
    return response.json();
  }, [baseUrl]);

  // Produce message
  const produceMessage = useCallback(async (request: ProduceMessageRequest): Promise<ProduceMessageResult> => {
    const response = await fetch(
      `${baseUrl}/topics/${encodeURIComponent(request.topic)}/messages`,
      {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(request)
      }
    );
    if (!response.ok) {
      const error = await response.json();
      throw new Error(error.error || `HTTP ${response.status}`);
    }
    return response.json();
  }, [baseUrl]);

  return {
    topics,
    topicsLoading,
    topicsError,
    refreshTopics,
    createTopic,
    deleteTopic,
    consumerGroups,
    groupsLoading,
    groupsError,
    refreshGroups,
    getGroupDetail,
    resetOffsets,
    deleteGroup,
    getMessages,
    produceMessage,
    isHealthy
  };
}
```

**Create useKafkaStream.ts:**

```typescript
import { useState, useEffect, useCallback, useRef } from 'react';
import * as signalR from '@microsoft/signalr';
import type { KafkaMessage } from '../types/kafka';

interface UseKafkaStreamOptions {
  hubUrl: string;
  topic: string;
  maxMessages?: number;  // Rolling buffer size (default: 50)
  enabled?: boolean;
}

interface UseKafkaStreamResult {
  messages: KafkaMessage[];
  isConnected: boolean;
  error: string | null;
  clearMessages: () => void;
}

export function useKafkaStream({
  hubUrl,
  topic,
  maxMessages = 50,
  enabled = true
}: UseKafkaStreamOptions): UseKafkaStreamResult {
  const [messages, setMessages] = useState<KafkaMessage[]>([]);
  const [isConnected, setIsConnected] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const connectionRef = useRef<signalR.HubConnection | null>(null);

  useEffect(() => {
    if (!enabled) return;

    const connection = new signalR.HubConnectionBuilder()
      .withUrl(hubUrl)
      .withAutomaticReconnect([0, 2000, 5000, 10000, 30000])
      .build();

    connectionRef.current = connection;

    connection.on('KafkaMessage', (message: KafkaMessage) => {
      setMessages(prev => {
        const updated = [message, ...prev];
        return updated.slice(0, maxMessages);
      });
    });

    connection.onclose((err) => {
      setIsConnected(false);
      if (err) setError(err.message);
    });

    connection.onreconnecting((err) => {
      setIsConnected(false);
      if (err) setError(`Reconnecting: ${err.message}`);
    });

    connection.onreconnected(() => {
      setIsConnected(true);
      setError(null);
      // Re-subscribe after reconnection
      connection.invoke('SubscribeToTopic', topic).catch(console.error);
    });

    // Start connection
    connection.start()
      .then(() => {
        setIsConnected(true);
        setError(null);
        return connection.invoke('SubscribeToTopic', topic);
      })
      .catch(err => {
        setError(err.message);
      });

    return () => {
      connection.invoke('UnsubscribeFromTopic', topic)
        .catch(() => {})  // Ignore errors on cleanup
        .finally(() => connection.stop());
    };
  }, [hubUrl, topic, maxMessages, enabled]);

  const clearMessages = useCallback(() => {
    setMessages([]);
  }, []);

  return {
    messages,
    isConnected,
    error,
    clearMessages
  };
}
```
  </action>
  <verify>
`npm run build --prefix src/dashboard` type-checks without errors
  </verify>
  <done>
useKafka hook provides all API operations, useKafkaStream provides real-time message streaming
  </done>
</task>

<task type="auto">
  <name>Task 3: Create KafkaTab skeleton and integrate into App</name>
  <files>
src/dashboard/src/components/KafkaTab.tsx
src/dashboard/src/App.tsx
src/dashboard/src/App.css
  </files>
  <action>
**Create KafkaTab.tsx:**

```tsx
import { useKafka } from '../hooks/useKafka';
import { getLagLevel } from '../types/kafka';
import './KafkaTab.css';

interface KafkaTabProps {
  apiBaseUrl: string;
}

function KafkaTab({ apiBaseUrl }: KafkaTabProps) {
  const {
    topics,
    topicsLoading,
    topicsError,
    consumerGroups,
    groupsLoading,
    groupsError,
    isHealthy
  } = useKafka({ apiBaseUrl });

  return (
    <div className="kafka-tab">
      {/* Health Status */}
      <div className="kafka-health">
        <span className={`kafka-health__indicator kafka-health__indicator--${isHealthy ? 'healthy' : isHealthy === false ? 'unhealthy' : 'unknown'}`} />
        <span className="kafka-health__label">
          Kafka: {isHealthy ? 'Connected' : isHealthy === false ? 'Disconnected' : 'Checking...'}
        </span>
      </div>

      <div className="kafka-content">
        {/* Topics Section */}
        <section className="kafka-section">
          <header className="kafka-section__header">
            <h2>Topics</h2>
            <span className="kafka-section__count">{topics.length}</span>
          </header>

          {topicsLoading ? (
            <div className="kafka-loading">Loading topics...</div>
          ) : topicsError ? (
            <div className="kafka-error">{topicsError}</div>
          ) : topics.length === 0 ? (
            <div className="kafka-empty">No topics found</div>
          ) : (
            <div className="kafka-topics">
              {topics.map(topic => (
                <div key={topic.name} className="kafka-topic">
                  <span className="kafka-topic__name">{topic.name}</span>
                  <span className="kafka-topic__partitions">{topic.partitionCount} partitions</span>
                </div>
              ))}
            </div>
          )}
        </section>

        {/* Consumer Groups Section */}
        <section className="kafka-section">
          <header className="kafka-section__header">
            <h2>Consumer Groups</h2>
            <span className="kafka-section__count">{consumerGroups.length}</span>
          </header>

          {groupsLoading ? (
            <div className="kafka-loading">Loading consumer groups...</div>
          ) : groupsError ? (
            <div className="kafka-error">{groupsError}</div>
          ) : consumerGroups.length === 0 ? (
            <div className="kafka-empty">No consumer groups found</div>
          ) : (
            <div className="kafka-groups">
              {consumerGroups.map(group => (
                <div key={group.groupId} className="kafka-group">
                  <span className="kafka-group__id">{group.groupId}</span>
                  <span className="kafka-group__state">{group.state}</span>
                  <span className="kafka-group__members">{group.memberCount} members</span>
                  <span className={`kafka-group__lag kafka-group__lag--${getLagLevel(group.totalLag)}`}>
                    Lag: {group.totalLag}
                  </span>
                </div>
              ))}
            </div>
          )}
        </section>
      </div>
    </div>
  );
}

export default KafkaTab;
```

**Update App.tsx:**

1. Add import:
```typescript
import KafkaTab from './components/KafkaTab';
```

2. Update activeTab type to include 'kafka':
```typescript
const [activeTab, setActiveTab] = useState<'servers' | 'files' | 'history' | 'kafka'>('servers');
```

3. Add Kafka tab button in header-tabs nav (after History button):
```tsx
<button
  className={`header-tab ${activeTab === 'kafka' ? 'header-tab--active' : ''}`}
  onClick={() => setActiveTab('kafka')}
  type="button"
>
  Kafka
</button>
```

4. Add Kafka tab content in main (after history tab condition):
```tsx
{activeTab === 'kafka' && (
  <KafkaTab apiBaseUrl={apiBaseUrl} />
)}
```

**Add to App.css (basic Kafka tab styles):**

```css
/* ============================================
   Kafka Tab
   ============================================ */
.kafka-tab {
  padding: var(--spacing-lg);
}

.kafka-health {
  display: flex;
  align-items: center;
  gap: var(--spacing-sm);
  margin-bottom: var(--spacing-lg);
  padding: var(--spacing-md);
  background: var(--bg-secondary);
  border-radius: var(--border-radius);
}

.kafka-health__indicator {
  width: 12px;
  height: 12px;
  border-radius: 50%;
}

.kafka-health__indicator--healthy {
  background: var(--color-success);
}

.kafka-health__indicator--unhealthy {
  background: var(--color-error);
}

.kafka-health__indicator--unknown {
  background: var(--color-warning);
}

.kafka-content {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
  gap: var(--spacing-lg);
}

.kafka-section {
  background: var(--bg-secondary);
  border-radius: var(--border-radius);
  padding: var(--spacing-md);
}

.kafka-section__header {
  display: flex;
  align-items: center;
  gap: var(--spacing-sm);
  margin-bottom: var(--spacing-md);
  padding-bottom: var(--spacing-sm);
  border-bottom: 1px solid var(--border-color);
}

.kafka-section__header h2 {
  margin: 0;
  font-size: 1.1rem;
}

.kafka-section__count {
  background: var(--bg-tertiary);
  padding: 2px 8px;
  border-radius: 12px;
  font-size: 0.85rem;
}

.kafka-loading,
.kafka-error,
.kafka-empty {
  padding: var(--spacing-md);
  text-align: center;
  color: var(--text-secondary);
}

.kafka-error {
  color: var(--color-error);
}

.kafka-topics,
.kafka-groups {
  display: flex;
  flex-direction: column;
  gap: var(--spacing-sm);
}

.kafka-topic,
.kafka-group {
  display: flex;
  align-items: center;
  gap: var(--spacing-md);
  padding: var(--spacing-sm) var(--spacing-md);
  background: var(--bg-tertiary);
  border-radius: var(--border-radius-sm);
}

.kafka-topic__name,
.kafka-group__id {
  flex: 1;
  font-weight: 500;
}

.kafka-topic__partitions,
.kafka-group__state,
.kafka-group__members {
  font-size: 0.85rem;
  color: var(--text-secondary);
}

.kafka-group__lag {
  padding: 2px 8px;
  border-radius: 4px;
  font-size: 0.85rem;
}

.kafka-group__lag--green {
  background: rgba(34, 197, 94, 0.2);
  color: var(--color-success);
}

.kafka-group__lag--yellow {
  background: rgba(234, 179, 8, 0.2);
  color: var(--color-warning);
}

.kafka-group__lag--red {
  background: rgba(239, 68, 68, 0.2);
  color: var(--color-error);
}
```
  </action>
  <verify>
`npm run build --prefix src/dashboard` builds without errors and Kafka tab appears in navigation
  </verify>
  <done>
KafkaTab shows topics and consumer groups, integrated into App navigation as fourth tab
  </done>
</task>

</tasks>

<verification>
1. `npm run build --prefix src/dashboard` - builds without errors
2. Types file exports all required interfaces
3. useKafka hook provides all API operations
4. useKafkaStream hook connects to SignalR hub
5. KafkaTab displays topics and consumer groups
6. App.tsx includes Kafka tab in navigation
</verification>

<success_criteria>
- All TypeScript types match backend DTOs
- useKafka hook handles all API operations with error states
- useKafkaStream hook manages SignalR connection for live messages
- KafkaTab shows loading/error/empty states appropriately
- Lag color coding works (green/yellow/red thresholds)
- Tab navigation includes Kafka tab
</success_criteria>

<output>
After completion, create `.planning/phases/10-kafka-integration/10-04-SUMMARY.md`
</output>
