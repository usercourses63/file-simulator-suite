---
phase: 10-kafka-integration
plan: 06
type: execute
wave: 3
depends_on: ["10-05"]
files_modified:
  - src/dashboard/src/components/MessageViewer.tsx
  - src/dashboard/src/components/ConsumerGroupDetail.tsx
  - src/dashboard/src/components/KafkaTab.tsx
  - src/dashboard/src/components/KafkaTab.css
autonomous: true

must_haves:
  truths:
    - "User can view messages from selected topic"
    - "Message viewer shows live stream and manual refresh"
    - "Consumer group detail shows partition-level offsets"
    - "User can reset offsets for inactive groups"
    - "User can delete consumer groups"
    - "Lag is color-coded at partition level"
  artifacts:
    - path: "src/dashboard/src/components/MessageViewer.tsx"
      provides: "Message display with live stream"
      contains: "useKafkaStream"
    - path: "src/dashboard/src/components/ConsumerGroupDetail.tsx"
      provides: "Expandable consumer group detail"
      contains: "PartitionOffset"
  key_links:
    - from: "MessageViewer.tsx"
      to: "useKafkaStream hook"
      via: "SignalR subscription"
      pattern: "useKafkaStream"
    - from: "ConsumerGroupDetail.tsx"
      to: "useKafka hook"
      via: "getGroupDetail"
      pattern: "getGroupDetail"
---

<objective>
Implement message viewer with live streaming and consumer group monitoring with controls

Purpose: Complete the Kafka dashboard with message consumption view and full consumer group management
Output: MessageViewer with live/refresh modes, ConsumerGroupDetail with offset reset and delete
</objective>

<execution_context>
@C:\Users\UserC\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\UserC\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/10-kafka-integration/10-CONTEXT.md
@src/dashboard/src/components/KafkaTab.tsx
@src/dashboard/src/hooks/useKafkaStream.ts
@src/dashboard/src/types/kafka.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create MessageViewer component with live stream and refresh</name>
  <files>src/dashboard/src/components/MessageViewer.tsx</files>
  <action>
Create MessageViewer that shows messages with both live streaming and manual refresh options.

```tsx
import { useState, useEffect } from 'react';
import { useKafkaStream } from '../hooks/useKafkaStream';
import type { KafkaMessage } from '../types/kafka';

interface MessageViewerProps {
  topic: string;
  hubUrl: string;
  getMessages: (topic: string, count?: number) => Promise<KafkaMessage[]>;
}

function MessageViewer({ topic, hubUrl, getMessages }: MessageViewerProps) {
  const [mode, setMode] = useState<'live' | 'manual'>('live');
  const [manualMessages, setManualMessages] = useState<KafkaMessage[]>([]);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  // Live stream hook (only active in live mode)
  const {
    messages: liveMessages,
    isConnected,
    error: streamError,
    clearMessages
  } = useKafkaStream({
    hubUrl,
    topic,
    maxMessages: 50,
    enabled: mode === 'live'
  });

  // Fetch messages manually
  const handleRefresh = async () => {
    setLoading(true);
    setError(null);
    try {
      const msgs = await getMessages(topic, 50);
      setManualMessages(msgs);
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Failed to fetch messages');
    } finally {
      setLoading(false);
    }
  };

  // Initial fetch in manual mode
  useEffect(() => {
    if (mode === 'manual') {
      handleRefresh();
    }
  }, [mode, topic]);

  // Clear when switching to live
  useEffect(() => {
    if (mode === 'live') {
      clearMessages();
    }
  }, [mode]);

  const messages = mode === 'live' ? liveMessages : manualMessages;
  const displayError = mode === 'live' ? streamError : error;

  return (
    <div className="message-viewer">
      <header className="message-viewer__header">
        <h4>Messages: {topic}</h4>
        <div className="message-viewer__controls">
          <div className="message-viewer__mode-toggle">
            <button
              className={`message-viewer__mode-btn ${mode === 'live' ? 'message-viewer__mode-btn--active' : ''}`}
              onClick={() => setMode('live')}
              type="button"
            >
              Live
            </button>
            <button
              className={`message-viewer__mode-btn ${mode === 'manual' ? 'message-viewer__mode-btn--active' : ''}`}
              onClick={() => setMode('manual')}
              type="button"
            >
              Manual
            </button>
          </div>
          {mode === 'manual' && (
            <button
              className="message-viewer__refresh-btn"
              onClick={handleRefresh}
              disabled={loading}
              type="button"
            >
              {loading ? 'Loading...' : 'Refresh'}
            </button>
          )}
          {mode === 'live' && (
            <span className={`message-viewer__status message-viewer__status--${isConnected ? 'connected' : 'disconnected'}`}>
              {isConnected ? 'Connected' : 'Disconnected'}
            </span>
          )}
        </div>
      </header>

      {displayError && (
        <div className="message-viewer__error">{displayError}</div>
      )}

      <div className="message-viewer__list">
        {messages.length === 0 ? (
          <div className="message-viewer__empty">
            {mode === 'live'
              ? 'Waiting for messages...'
              : 'No messages found. Try refreshing.'}
          </div>
        ) : (
          messages.map((msg, idx) => (
            <div key={`${msg.partition}-${msg.offset}-${idx}`} className="message-viewer__item">
              <div className="message-viewer__item-header">
                <span className="message-viewer__item-offset">
                  P{msg.partition}:O{msg.offset}
                </span>
                {msg.key && (
                  <span className="message-viewer__item-key">Key: {msg.key}</span>
                )}
                <span className="message-viewer__item-time">
                  {new Date(msg.timestamp).toLocaleTimeString()}
                </span>
              </div>
              <pre className="message-viewer__item-value">{msg.value}</pre>
            </div>
          ))
        )}
      </div>
    </div>
  );
}

export default MessageViewer;
```
  </action>
  <verify>
`npm run build --prefix src/dashboard` type-checks without errors
  </verify>
  <done>
MessageViewer shows messages in live or manual mode with refresh capability
  </done>
</task>

<task type="auto">
  <name>Task 2: Create ConsumerGroupDetail component with controls</name>
  <files>src/dashboard/src/components/ConsumerGroupDetail.tsx</files>
  <action>
Create expandable consumer group detail with partition offsets and control actions.

```tsx
import { useState, useEffect } from 'react';
import type {
  ConsumerGroupInfo,
  ConsumerGroupDetail as GroupDetail,
  ResetOffsetsRequest
} from '../types/kafka';
import { getLagLevel } from '../types/kafka';

interface ConsumerGroupDetailProps {
  group: ConsumerGroupInfo;
  getDetail: (groupId: string) => Promise<GroupDetail>;
  onResetOffsets: (request: ResetOffsetsRequest) => Promise<void>;
  onDeleteGroup: (groupId: string) => Promise<void>;
}

function ConsumerGroupDetail({
  group,
  getDetail,
  onResetOffsets,
  onDeleteGroup
}: ConsumerGroupDetailProps) {
  const [expanded, setExpanded] = useState(false);
  const [detail, setDetail] = useState<GroupDetail | null>(null);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  // Reset offsets state
  const [showResetForm, setShowResetForm] = useState(false);
  const [resetTopic, setResetTopic] = useState('');
  const [resetTo, setResetTo] = useState<'earliest' | 'latest'>('earliest');
  const [resetting, setResetting] = useState(false);

  // Delete state
  const [confirmDelete, setConfirmDelete] = useState(false);
  const [deleting, setDeleting] = useState(false);

  // Fetch detail when expanded
  useEffect(() => {
    if (expanded && !detail) {
      loadDetail();
    }
  }, [expanded]);

  const loadDetail = async () => {
    setLoading(true);
    setError(null);
    try {
      const d = await getDetail(group.groupId);
      setDetail(d);
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Failed to load details');
    } finally {
      setLoading(false);
    }
  };

  const handleReset = async () => {
    if (!resetTopic) {
      setError('Please select a topic');
      return;
    }
    setResetting(true);
    setError(null);
    try {
      await onResetOffsets({
        groupId: group.groupId,
        topic: resetTopic,
        resetTo
      });
      setShowResetForm(false);
      await loadDetail();  // Refresh
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Failed to reset offsets');
    } finally {
      setResetting(false);
    }
  };

  const handleDelete = async () => {
    setDeleting(true);
    try {
      await onDeleteGroup(group.groupId);
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Failed to delete group');
      setDeleting(false);
      setConfirmDelete(false);
    }
  };

  // Get unique topics from partitions
  const topics = detail
    ? [...new Set(detail.partitions.map(p => p.topic))]
    : [];

  return (
    <div className="consumer-group-detail">
      <div
        className="consumer-group-detail__header"
        onClick={() => setExpanded(!expanded)}
      >
        <span className="consumer-group-detail__expand">
          {expanded ? '▼' : '▶'}
        </span>
        <span className="consumer-group-detail__id">{group.groupId}</span>
        <span className="consumer-group-detail__state">{group.state}</span>
        <span className="consumer-group-detail__members">
          {group.memberCount} member{group.memberCount !== 1 ? 's' : ''}
        </span>
        <span className={`consumer-group-detail__lag consumer-group-detail__lag--${getLagLevel(group.totalLag)}`}>
          Lag: {group.totalLag}
        </span>
      </div>

      {expanded && (
        <div className="consumer-group-detail__body">
          {loading ? (
            <div className="consumer-group-detail__loading">Loading...</div>
          ) : error ? (
            <div className="consumer-group-detail__error">{error}</div>
          ) : detail ? (
            <>
              {/* Members */}
              {detail.members.length > 0 && (
                <div className="consumer-group-detail__section">
                  <h5>Members ({detail.members.length})</h5>
                  <ul className="consumer-group-detail__members-list">
                    {detail.members.map(m => (
                      <li key={m.memberId}>
                        <span className="consumer-group-detail__member-client">{m.clientId}</span>
                        <span className="consumer-group-detail__member-host">{m.host}</span>
                      </li>
                    ))}
                  </ul>
                </div>
              )}

              {/* Partitions */}
              {detail.partitions.length > 0 && (
                <div className="consumer-group-detail__section">
                  <h5>Partition Offsets</h5>
                  <table className="consumer-group-detail__partitions">
                    <thead>
                      <tr>
                        <th>Topic</th>
                        <th>Partition</th>
                        <th>Current</th>
                        <th>High</th>
                        <th>Lag</th>
                      </tr>
                    </thead>
                    <tbody>
                      {detail.partitions.map(p => (
                        <tr key={`${p.topic}-${p.partition}`}>
                          <td>{p.topic}</td>
                          <td>{p.partition}</td>
                          <td>{p.currentOffset}</td>
                          <td>{p.highWatermark}</td>
                          <td className={`consumer-group-detail__partition-lag--${getLagLevel(p.lag)}`}>
                            {p.lag}
                          </td>
                        </tr>
                      ))}
                    </tbody>
                  </table>
                </div>
              )}

              {/* Actions */}
              <div className="consumer-group-detail__actions">
                {/* Reset Offsets */}
                {group.state === 'Empty' ? (
                  showResetForm ? (
                    <div className="consumer-group-detail__reset-form">
                      <select
                        value={resetTopic}
                        onChange={e => setResetTopic(e.target.value)}
                        disabled={resetting}
                      >
                        <option value="">Select topic</option>
                        {topics.map(t => (
                          <option key={t} value={t}>{t}</option>
                        ))}
                      </select>
                      <select
                        value={resetTo}
                        onChange={e => setResetTo(e.target.value as 'earliest' | 'latest')}
                        disabled={resetting}
                      >
                        <option value="earliest">Earliest</option>
                        <option value="latest">Latest</option>
                      </select>
                      <button onClick={handleReset} disabled={resetting}>
                        {resetting ? 'Resetting...' : 'Reset'}
                      </button>
                      <button onClick={() => setShowResetForm(false)} disabled={resetting}>
                        Cancel
                      </button>
                    </div>
                  ) : (
                    <button
                      className="consumer-group-detail__action-btn"
                      onClick={() => setShowResetForm(true)}
                    >
                      Reset Offsets
                    </button>
                  )
                ) : (
                  <span className="consumer-group-detail__action-hint">
                    Group must be inactive to reset offsets
                  </span>
                )}

                {/* Delete */}
                {confirmDelete ? (
                  <div className="consumer-group-detail__confirm-delete">
                    <span>Delete group?</span>
                    <button
                      className="consumer-group-detail__delete-confirm"
                      onClick={handleDelete}
                      disabled={deleting}
                    >
                      {deleting ? 'Deleting...' : 'Yes'}
                    </button>
                    <button
                      onClick={() => setConfirmDelete(false)}
                      disabled={deleting}
                    >
                      No
                    </button>
                  </div>
                ) : (
                  <button
                    className="consumer-group-detail__action-btn consumer-group-detail__action-btn--danger"
                    onClick={() => setConfirmDelete(true)}
                  >
                    Delete Group
                  </button>
                )}
              </div>
            </>
          ) : null}
        </div>
      )}
    </div>
  );
}

export default ConsumerGroupDetail;
```
  </action>
  <verify>
`npm run build --prefix src/dashboard` type-checks without errors
  </verify>
  <done>
ConsumerGroupDetail shows expandable partition details with reset and delete controls
  </done>
</task>

<task type="auto">
  <name>Task 3: Integrate MessageViewer and ConsumerGroupDetail into KafkaTab</name>
  <files>
src/dashboard/src/components/KafkaTab.tsx
src/dashboard/src/components/KafkaTab.css
  </files>
  <action>
**Update KafkaTab.tsx to use new components:**

```tsx
import { useState } from 'react';
import { useKafka } from '../hooks/useKafka';
import TopicList from './TopicList';
import CreateTopicForm from './CreateTopicForm';
import MessageProducer from './MessageProducer';
import MessageViewer from './MessageViewer';
import ConsumerGroupDetail from './ConsumerGroupDetail';
import './KafkaTab.css';

interface KafkaTabProps {
  apiBaseUrl: string;
}

function KafkaTab({ apiBaseUrl }: KafkaTabProps) {
  const kafkaHubUrl = `${apiBaseUrl}/hubs/kafka`;

  const {
    topics,
    topicsLoading,
    topicsError,
    createTopic,
    deleteTopic,
    consumerGroups,
    groupsLoading,
    groupsError,
    getGroupDetail,
    resetOffsets,
    deleteGroup,
    getMessages,
    produceMessage,
    isHealthy
  } = useKafka({ apiBaseUrl });

  const [selectedTopic, setSelectedTopic] = useState<string | null>(null);
  const [showCreateForm, setShowCreateForm] = useState(false);
  const [viewMode, setViewMode] = useState<'produce' | 'consume'>('produce');

  return (
    <div className="kafka-tab">
      {/* Health Status */}
      <div className="kafka-health">
        <span className={`kafka-health__indicator kafka-health__indicator--${isHealthy ? 'healthy' : isHealthy === false ? 'unhealthy' : 'unknown'}`} />
        <span className="kafka-health__label">
          Kafka: {isHealthy ? 'Connected' : isHealthy === false ? 'Disconnected' : 'Checking...'}
        </span>
      </div>

      <div className="kafka-layout">
        {/* Left: Topics */}
        <div className="kafka-panel kafka-panel--topics">
          {topicsLoading ? (
            <div className="kafka-loading">Loading topics...</div>
          ) : topicsError ? (
            <div className="kafka-error">{topicsError}</div>
          ) : (
            <TopicList
              topics={topics}
              selectedTopic={selectedTopic}
              onSelectTopic={setSelectedTopic}
              onDeleteTopic={deleteTopic}
              onCreateClick={() => setShowCreateForm(true)}
            />
          )}
        </div>

        {/* Center: Producer/Consumer */}
        <div className="kafka-panel kafka-panel--messages">
          {selectedTopic ? (
            <>
              <div className="kafka-view-toggle">
                <button
                  className={`kafka-view-toggle__btn ${viewMode === 'produce' ? 'kafka-view-toggle__btn--active' : ''}`}
                  onClick={() => setViewMode('produce')}
                  type="button"
                >
                  Produce
                </button>
                <button
                  className={`kafka-view-toggle__btn ${viewMode === 'consume' ? 'kafka-view-toggle__btn--active' : ''}`}
                  onClick={() => setViewMode('consume')}
                  type="button"
                >
                  Consume
                </button>
              </div>

              {viewMode === 'produce' ? (
                <MessageProducer
                  topic={selectedTopic}
                  onProduce={produceMessage}
                />
              ) : (
                <MessageViewer
                  topic={selectedTopic}
                  hubUrl={kafkaHubUrl}
                  getMessages={getMessages}
                />
              )}
            </>
          ) : (
            <div className="kafka-placeholder">
              Select a topic to produce or consume messages
            </div>
          )}
        </div>

        {/* Right: Consumer Groups */}
        <div className="kafka-panel kafka-panel--groups">
          <h3>Consumer Groups</h3>
          {groupsLoading ? (
            <div className="kafka-loading">Loading groups...</div>
          ) : groupsError ? (
            <div className="kafka-error">{groupsError}</div>
          ) : consumerGroups.length === 0 ? (
            <div className="kafka-empty">No consumer groups</div>
          ) : (
            <div className="kafka-groups-list">
              {consumerGroups.map(group => (
                <ConsumerGroupDetail
                  key={group.groupId}
                  group={group}
                  getDetail={getGroupDetail}
                  onResetOffsets={resetOffsets}
                  onDeleteGroup={deleteGroup}
                />
              ))}
            </div>
          )}
        </div>
      </div>

      {/* Create Topic Modal */}
      {showCreateForm && (
        <CreateTopicForm
          onSubmit={createTopic}
          onCancel={() => setShowCreateForm(false)}
        />
      )}
    </div>
  );
}

export default KafkaTab;
```

**Add to KafkaTab.css:**

```css
/* View Toggle */
.kafka-view-toggle {
  display: flex;
  gap: 2px;
  margin-bottom: var(--spacing-md);
  background: var(--bg-tertiary);
  border-radius: var(--border-radius-sm);
  padding: 2px;
}

.kafka-view-toggle__btn {
  flex: 1;
  padding: var(--spacing-sm);
  border: none;
  background: transparent;
  cursor: pointer;
  border-radius: var(--border-radius-sm);
  font-weight: 500;
  transition: background 0.2s;
}

.kafka-view-toggle__btn--active {
  background: var(--color-primary);
  color: white;
}

/* Message Viewer */
.message-viewer {
  display: flex;
  flex-direction: column;
  height: 100%;
}

.message-viewer__header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: var(--spacing-md);
  flex-wrap: wrap;
  gap: var(--spacing-sm);
}

.message-viewer__header h4 {
  margin: 0;
  font-size: 1rem;
}

.message-viewer__controls {
  display: flex;
  align-items: center;
  gap: var(--spacing-sm);
}

.message-viewer__mode-toggle {
  display: flex;
  gap: 2px;
  background: var(--bg-tertiary);
  border-radius: var(--border-radius-sm);
  padding: 2px;
}

.message-viewer__mode-btn {
  padding: 4px 12px;
  border: none;
  background: transparent;
  cursor: pointer;
  border-radius: var(--border-radius-sm);
  font-size: 0.85rem;
}

.message-viewer__mode-btn--active {
  background: var(--color-primary);
  color: white;
}

.message-viewer__refresh-btn {
  padding: 4px 12px;
  border: none;
  background: var(--bg-tertiary);
  cursor: pointer;
  border-radius: var(--border-radius-sm);
  font-size: 0.85rem;
}

.message-viewer__refresh-btn:hover {
  background: var(--color-primary);
  color: white;
}

.message-viewer__status {
  font-size: 0.8rem;
  padding: 4px 8px;
  border-radius: var(--border-radius-sm);
}

.message-viewer__status--connected {
  background: rgba(34, 197, 94, 0.2);
  color: var(--color-success);
}

.message-viewer__status--disconnected {
  background: rgba(239, 68, 68, 0.2);
  color: var(--color-error);
}

.message-viewer__error {
  padding: var(--spacing-sm);
  margin-bottom: var(--spacing-sm);
  background: rgba(239, 68, 68, 0.1);
  border-radius: var(--border-radius-sm);
  color: var(--color-error);
  font-size: 0.85rem;
}

.message-viewer__list {
  flex: 1;
  overflow-y: auto;
  min-height: 200px;
}

.message-viewer__empty {
  padding: var(--spacing-lg);
  text-align: center;
  color: var(--text-secondary);
}

.message-viewer__item {
  padding: var(--spacing-sm);
  margin-bottom: var(--spacing-xs);
  background: var(--bg-tertiary);
  border-radius: var(--border-radius-sm);
}

.message-viewer__item-header {
  display: flex;
  gap: var(--spacing-sm);
  margin-bottom: var(--spacing-xs);
  font-size: 0.8rem;
  color: var(--text-secondary);
}

.message-viewer__item-offset {
  font-family: monospace;
}

.message-viewer__item-key {
  color: var(--color-primary);
}

.message-viewer__item-time {
  margin-left: auto;
}

.message-viewer__item-value {
  margin: 0;
  padding: var(--spacing-xs);
  background: var(--bg-secondary);
  border-radius: 4px;
  font-size: 0.85rem;
  white-space: pre-wrap;
  word-break: break-all;
  max-height: 100px;
  overflow-y: auto;
}

/* Consumer Group Detail */
.consumer-group-detail {
  margin-bottom: var(--spacing-sm);
  background: var(--bg-tertiary);
  border-radius: var(--border-radius-sm);
  overflow: hidden;
}

.consumer-group-detail__header {
  display: flex;
  align-items: center;
  gap: var(--spacing-sm);
  padding: var(--spacing-sm);
  cursor: pointer;
  flex-wrap: wrap;
}

.consumer-group-detail__header:hover {
  background: rgba(255, 255, 255, 0.05);
}

.consumer-group-detail__expand {
  font-size: 0.7rem;
  color: var(--text-secondary);
}

.consumer-group-detail__id {
  flex: 1;
  font-weight: 500;
  word-break: break-all;
  min-width: 100px;
}

.consumer-group-detail__state,
.consumer-group-detail__members {
  font-size: 0.8rem;
  color: var(--text-secondary);
}

.consumer-group-detail__lag {
  padding: 2px 6px;
  border-radius: 4px;
  font-size: 0.8rem;
}

.consumer-group-detail__lag--green { background: rgba(34, 197, 94, 0.2); color: var(--color-success); }
.consumer-group-detail__lag--yellow { background: rgba(234, 179, 8, 0.2); color: var(--color-warning); }
.consumer-group-detail__lag--red { background: rgba(239, 68, 68, 0.2); color: var(--color-error); }

.consumer-group-detail__body {
  padding: var(--spacing-sm);
  border-top: 1px solid var(--border-color);
}

.consumer-group-detail__loading,
.consumer-group-detail__error {
  padding: var(--spacing-sm);
  text-align: center;
}

.consumer-group-detail__error {
  color: var(--color-error);
}

.consumer-group-detail__section {
  margin-bottom: var(--spacing-md);
}

.consumer-group-detail__section h5 {
  margin: 0 0 var(--spacing-xs) 0;
  font-size: 0.85rem;
  color: var(--text-secondary);
}

.consumer-group-detail__members-list {
  list-style: none;
  padding: 0;
  margin: 0;
}

.consumer-group-detail__members-list li {
  display: flex;
  gap: var(--spacing-sm);
  padding: 4px 0;
  font-size: 0.85rem;
}

.consumer-group-detail__member-client {
  font-weight: 500;
}

.consumer-group-detail__member-host {
  color: var(--text-secondary);
}

.consumer-group-detail__partitions {
  width: 100%;
  border-collapse: collapse;
  font-size: 0.85rem;
}

.consumer-group-detail__partitions th,
.consumer-group-detail__partitions td {
  padding: 4px 8px;
  text-align: left;
  border-bottom: 1px solid var(--border-color);
}

.consumer-group-detail__partitions th {
  font-weight: 500;
  color: var(--text-secondary);
}

.consumer-group-detail__partition-lag--green { color: var(--color-success); }
.consumer-group-detail__partition-lag--yellow { color: var(--color-warning); }
.consumer-group-detail__partition-lag--red { color: var(--color-error); }

.consumer-group-detail__actions {
  display: flex;
  gap: var(--spacing-sm);
  flex-wrap: wrap;
  margin-top: var(--spacing-sm);
  padding-top: var(--spacing-sm);
  border-top: 1px solid var(--border-color);
}

.consumer-group-detail__action-btn {
  padding: 4px 12px;
  border: none;
  border-radius: var(--border-radius-sm);
  cursor: pointer;
  font-size: 0.85rem;
  background: var(--bg-secondary);
}

.consumer-group-detail__action-btn:hover {
  background: var(--color-primary);
  color: white;
}

.consumer-group-detail__action-btn--danger {
  color: var(--color-error);
}

.consumer-group-detail__action-btn--danger:hover {
  background: var(--color-error);
  color: white;
}

.consumer-group-detail__action-hint {
  font-size: 0.8rem;
  color: var(--text-secondary);
  font-style: italic;
}

.consumer-group-detail__reset-form,
.consumer-group-detail__confirm-delete {
  display: flex;
  gap: var(--spacing-xs);
  align-items: center;
}

.consumer-group-detail__reset-form select,
.consumer-group-detail__reset-form button,
.consumer-group-detail__confirm-delete button {
  padding: 4px 8px;
  border: 1px solid var(--border-color);
  border-radius: var(--border-radius-sm);
  font-size: 0.85rem;
  background: var(--bg-secondary);
}

.consumer-group-detail__delete-confirm {
  background: var(--color-error) !important;
  color: white !important;
  border-color: var(--color-error) !important;
}

.kafka-groups-list {
  display: flex;
  flex-direction: column;
}
```
  </action>
  <verify>
`npm run build --prefix src/dashboard` builds without errors
  </verify>
  <done>
KafkaTab integrates MessageViewer with live/manual toggle and ConsumerGroupDetail with full controls
  </done>
</task>

</tasks>

<verification>
1. `npm run build --prefix src/dashboard` - builds without errors
2. Message viewer shows live/manual toggle
3. Live mode connects to SignalR and shows messages
4. Manual mode fetches and displays messages
5. Consumer group detail expands to show partitions
6. Reset offsets form appears for inactive groups
7. Delete confirmation works
8. Lag coloring applies at partition level
</verification>

<success_criteria>
- MessageViewer switches between live streaming and manual refresh
- Live mode shows connection status
- Message list shows partition, offset, key, value, timestamp
- Consumer group detail shows members and partition offsets
- Reset offsets only available for Empty state groups
- Delete requires confirmation
- All lag values color-coded correctly
</success_criteria>

<output>
After completion, create `.planning/phases/10-kafka-integration/10-06-SUMMARY.md`
</output>
