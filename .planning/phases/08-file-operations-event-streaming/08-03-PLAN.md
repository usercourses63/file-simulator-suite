---
phase: 08-file-operations-event-streaming
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - src/dashboard/package.json
  - src/dashboard/src/types/fileTypes.ts
  - src/dashboard/src/hooks/useFileEvents.ts
  - src/dashboard/src/hooks/useFileOperations.ts
autonomous: true

must_haves:
  truths:
    - "react-dropzone and react-arborist packages are installed"
    - "TypeScript types defined for file operations"
    - "useFileEvents hook connects to /hubs/fileevents"
    - "useFileOperations hook provides fetch/upload/download/delete functions"
  artifacts:
    - path: "src/dashboard/package.json"
      provides: "Updated dependencies"
      contains: "react-dropzone"
    - path: "src/dashboard/src/types/fileTypes.ts"
      provides: "File operation types"
      contains: "interface FileEvent"
      min_lines: 30
    - path: "src/dashboard/src/hooks/useFileEvents.ts"
      provides: "SignalR hook for file events"
      contains: "export function useFileEvents"
    - path: "src/dashboard/src/hooks/useFileOperations.ts"
      provides: "File CRUD operations hook"
      contains: "export function useFileOperations"
  key_links:
    - from: "src/dashboard/src/hooks/useFileEvents.ts"
      to: "/hubs/fileevents"
      via: "SignalR HubConnectionBuilder"
      pattern: "withUrl.*fileevents"
    - from: "src/dashboard/src/hooks/useFileOperations.ts"
      to: "/api/files"
      via: "fetch calls"
      pattern: "fetch.*api/files"
---

<objective>
Set up frontend foundation: install npm packages, create TypeScript types, and implement hooks for file events and operations.

Purpose: Provide the data layer and reusable hooks that file browser components will consume.

Output:
- npm packages installed (react-dropzone, react-arborist)
- TypeScript types for file events and file tree
- useFileEvents hook for SignalR file event streaming
- useFileOperations hook for REST API file operations
</objective>

<execution_context>
@C:\Users\UserC\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\UserC\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/08-file-operations-event-streaming/08-RESEARCH.md

# Existing frontend patterns
@src/dashboard/src/hooks/useSignalR.ts
@src/dashboard/src/types/server.ts
@src/dashboard/package.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install npm packages</name>
  <files>
    src/dashboard/package.json
  </files>
  <action>
Install required packages:

```bash
cd src/dashboard
npm install react-dropzone react-arborist
```

Verify package.json includes:
- react-dropzone (for drag-drop file upload)
- react-arborist (for file tree browser)

No @types packages needed - both ship with TypeScript definitions.
  </action>
  <verify>
```powershell
cd src/dashboard
npm list react-dropzone react-arborist
# Should show both packages installed
```
  </verify>
  <done>react-dropzone and react-arborist installed in dashboard dependencies.</done>
</task>

<task type="auto">
  <name>Task 2: Create file operation TypeScript types</name>
  <files>
    src/dashboard/src/types/fileTypes.ts
  </files>
  <action>
Create fileTypes.ts with comprehensive types:

```typescript
/**
 * Types for file operations and event streaming.
 * Matches backend DTOs from FileSimulator.ControlApi.
 */

/**
 * File event types from FileSystemWatcher.
 */
export type FileEventType = 'Created' | 'Modified' | 'Deleted' | 'Renamed';

/**
 * Protocol types that can access files.
 */
export type FileProtocol = 'FTP' | 'SFTP' | 'HTTP' | 'S3' | 'SMB' | 'NFS';

/**
 * Real-time file event from Windows directory watcher.
 * Received via SignalR /hubs/fileevents.
 */
export interface FileEvent {
  /** Full path to the file */
  path: string;
  /** Path relative to base directory */
  relativePath: string;
  /** Just the filename */
  fileName: string;
  /** Type of file system event */
  eventType: FileEventType;
  /** For rename events, the previous path */
  oldPath?: string;
  /** When the event occurred (ISO 8601) */
  timestamp: string;
  /** Protocols that can see this file */
  protocols: FileProtocol[];
  /** Whether this is a directory event */
  isDirectory: boolean;
}

/**
 * File or directory node in the file tree.
 * Received from GET /api/files/tree.
 */
export interface FileNode {
  /** Path relative to base directory (unique ID) */
  id: string;
  /** File or directory name */
  name: string;
  /** True if this is a directory */
  isDirectory: boolean;
  /** File size in bytes (undefined for directories) */
  size?: number;
  /** Last modified timestamp (ISO 8601) */
  modified: string;
  /** Protocols that can access this path */
  protocols: FileProtocol[];
  /** Child nodes (for directories) */
  children?: FileNode[];
}

/**
 * Upload progress tracking.
 */
export interface UploadProgress {
  fileName: string;
  progress: number; // 0-100
  status: 'pending' | 'uploading' | 'complete' | 'error';
  error?: string;
}

/**
 * File operation result.
 */
export interface FileOperationResult {
  success: boolean;
  message?: string;
  file?: FileNode;
}
```
  </action>
  <verify>
TypeScript compiles:
```powershell
cd src/dashboard
npx tsc --noEmit
```
  </verify>
  <done>fileTypes.ts defines FileEvent, FileNode, UploadProgress, FileOperationResult.</done>
</task>

<task type="auto">
  <name>Task 3: Create useFileEvents hook for SignalR</name>
  <files>
    src/dashboard/src/hooks/useFileEvents.ts
  </files>
  <action>
Create useFileEvents.ts following useSignalR.ts pattern but specialized for file events:

```typescript
import { useEffect, useState, useRef, useCallback } from 'react';
import * as signalR from '@microsoft/signalr';
import type { FileEvent } from '../types/fileTypes';

/**
 * Result returned by useFileEvents hook.
 */
export interface UseFileEventsResult {
  /** Recent file events (newest first, max 50) */
  events: FileEvent[];
  /** Whether connected to file events hub */
  isConnected: boolean;
  /** Error message if connection failed */
  error: string | null;
  /** Clear all events from the feed */
  clearEvents: () => void;
}

/**
 * Hook for receiving real-time file events via SignalR.
 * Maintains a rolling buffer of the last 50 events.
 *
 * @param hubUrl - URL of the file events hub (e.g., "http://192.168.49.2:30500/hubs/fileevents")
 * @returns Connection state and events array
 */
export function useFileEvents(hubUrl: string): UseFileEventsResult {
  const [events, setEvents] = useState<FileEvent[]>([]);
  const [isConnected, setIsConnected] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const connectionRef = useRef<signalR.HubConnection | null>(null);
  const isMountedRef = useRef(true);
  const maxEvents = 50;

  const clearEvents = useCallback(() => {
    setEvents([]);
  }, []);

  useEffect(() => {
    isMountedRef.current = true;

    const connection = new signalR.HubConnectionBuilder()
      .withUrl(hubUrl)
      .withAutomaticReconnect([0, 2000, 5000, 10000, 30000])
      .configureLogging(signalR.LogLevel.Information)
      .build();

    connectionRef.current = connection;

    // Handle file events
    connection.on('FileEvent', (event: FileEvent) => {
      if (!isMountedRef.current) return;

      setEvents(prev => [event, ...prev].slice(0, maxEvents));
    });

    connection.onreconnecting(() => {
      if (!isMountedRef.current) return;
      setIsConnected(false);
      console.log('FileEvents hub reconnecting...');
    });

    connection.onreconnected(() => {
      if (!isMountedRef.current) return;
      setIsConnected(true);
      setError(null);
      console.log('FileEvents hub reconnected');
    });

    connection.onclose((err) => {
      if (!isMountedRef.current) return;
      setIsConnected(false);
      if (err) {
        setError(err.message);
      }
    });

    connection.start()
      .then(() => {
        if (!isMountedRef.current) return;
        setIsConnected(true);
        setError(null);
        console.log('Connected to FileEvents hub');
      })
      .catch((err) => {
        if (!isMountedRef.current) return;
        setError(err.message);
        console.error('FileEvents connection failed:', err);
      });

    return () => {
      isMountedRef.current = false;
      connection.off('FileEvent');
      connection.stop().catch(console.warn);
    };
  }, [hubUrl]);

  return { events, isConnected, error, clearEvents };
}

export default useFileEvents;
```
  </action>
  <verify>
TypeScript compiles:
```powershell
cd src/dashboard
npx tsc --noEmit
```
  </verify>
  <done>useFileEvents hook connects to /hubs/fileevents and maintains 50-event rolling buffer.</done>
</task>

<task type="auto">
  <name>Task 4: Create useFileOperations hook for REST API</name>
  <files>
    src/dashboard/src/hooks/useFileOperations.ts
  </files>
  <action>
Create useFileOperations.ts for file CRUD operations:

```typescript
import { useState, useCallback } from 'react';
import type { FileNode, FileOperationResult } from '../types/fileTypes';

/**
 * Result returned by useFileOperations hook.
 */
export interface UseFileOperationsResult {
  /** Loading state for any operation */
  isLoading: boolean;
  /** Last error message */
  error: string | null;
  /** Fetch directory contents */
  fetchTree: (path?: string) => Promise<FileNode[]>;
  /** Upload a file */
  uploadFile: (file: File, targetPath?: string) => Promise<FileOperationResult>;
  /** Download a file (triggers browser download) */
  downloadFile: (path: string) => Promise<void>;
  /** Delete a file or directory */
  deleteFile: (path: string, recursive?: boolean) => Promise<FileOperationResult>;
}

/**
 * Hook for file operations via REST API.
 *
 * @param apiBaseUrl - Base URL for the API (e.g., "http://192.168.49.2:30500")
 * @returns File operation functions and state
 */
export function useFileOperations(apiBaseUrl: string): UseFileOperationsResult {
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const fetchTree = useCallback(async (path?: string): Promise<FileNode[]> => {
    setIsLoading(true);
    setError(null);

    try {
      const url = path
        ? `${apiBaseUrl}/api/files/tree?path=${encodeURIComponent(path)}`
        : `${apiBaseUrl}/api/files/tree`;

      const response = await fetch(url);

      if (!response.ok) {
        throw new Error(`Failed to fetch: ${response.statusText}`);
      }

      return await response.json();
    } catch (err) {
      const message = err instanceof Error ? err.message : 'Unknown error';
      setError(message);
      return [];
    } finally {
      setIsLoading(false);
    }
  }, [apiBaseUrl]);

  const uploadFile = useCallback(async (
    file: File,
    targetPath?: string
  ): Promise<FileOperationResult> => {
    setIsLoading(true);
    setError(null);

    try {
      const formData = new FormData();
      formData.append('file', file);

      const url = targetPath
        ? `${apiBaseUrl}/api/files/upload?path=${encodeURIComponent(targetPath)}`
        : `${apiBaseUrl}/api/files/upload`;

      const response = await fetch(url, {
        method: 'POST',
        body: formData,
      });

      if (!response.ok) {
        const text = await response.text();
        throw new Error(text || response.statusText);
      }

      const result = await response.json();
      return { success: true, file: result };
    } catch (err) {
      const message = err instanceof Error ? err.message : 'Upload failed';
      setError(message);
      return { success: false, message };
    } finally {
      setIsLoading(false);
    }
  }, [apiBaseUrl]);

  const downloadFile = useCallback(async (path: string): Promise<void> => {
    setIsLoading(true);
    setError(null);

    try {
      const url = `${apiBaseUrl}/api/files/download?path=${encodeURIComponent(path)}`;
      const response = await fetch(url);

      if (!response.ok) {
        throw new Error(`Download failed: ${response.statusText}`);
      }

      // Trigger browser download
      const blob = await response.blob();
      const downloadUrl = window.URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = downloadUrl;
      a.download = path.split('/').pop() || path.split('\\').pop() || 'download';
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      window.URL.revokeObjectURL(downloadUrl);
    } catch (err) {
      const message = err instanceof Error ? err.message : 'Download failed';
      setError(message);
      throw err;
    } finally {
      setIsLoading(false);
    }
  }, [apiBaseUrl]);

  const deleteFile = useCallback(async (
    path: string,
    recursive = false
  ): Promise<FileOperationResult> => {
    setIsLoading(true);
    setError(null);

    try {
      const params = new URLSearchParams({ path });
      if (recursive) params.append('recursive', 'true');

      const response = await fetch(`${apiBaseUrl}/api/files?${params}`, {
        method: 'DELETE',
      });

      if (!response.ok) {
        const text = await response.text();
        throw new Error(text || response.statusText);
      }

      return { success: true, message: 'Deleted successfully' };
    } catch (err) {
      const message = err instanceof Error ? err.message : 'Delete failed';
      setError(message);
      return { success: false, message };
    } finally {
      setIsLoading(false);
    }
  }, [apiBaseUrl]);

  return {
    isLoading,
    error,
    fetchTree,
    uploadFile,
    downloadFile,
    deleteFile,
  };
}

export default useFileOperations;
```
  </action>
  <verify>
TypeScript compiles:
```powershell
cd src/dashboard
npx tsc --noEmit
```
  </verify>
  <done>useFileOperations hook provides fetchTree, uploadFile, downloadFile, deleteFile functions.</done>
</task>

</tasks>

<verification>
1. npm packages installed: `npm list react-dropzone react-arborist`
2. TypeScript compiles: `npx tsc --noEmit`
3. All types exported from fileTypes.ts
4. Both hooks exported and follow existing patterns
</verification>

<success_criteria>
- react-dropzone and react-arborist in package.json
- FileEvent, FileNode types match backend DTOs
- useFileEvents connects to SignalR and maintains event buffer
- useFileOperations provides all CRUD operations via fetch
</success_criteria>

<output>
After completion, create `.planning/phases/08-file-operations-event-streaming/08-03-SUMMARY.md`
</output>
