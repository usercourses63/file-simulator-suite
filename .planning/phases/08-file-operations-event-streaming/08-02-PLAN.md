---
phase: 08-file-operations-event-streaming
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/FileSimulator.ControlApi/Models/FileNodeDto.cs
  - src/FileSimulator.ControlApi/Controllers/FilesController.cs
  - src/FileSimulator.ControlApi/Program.cs
autonomous: true

must_haves:
  truths:
    - "User can browse directory tree via GET /api/files/tree"
    - "User can upload files via POST /api/files/upload"
    - "User can download files via GET /api/files/download"
    - "User can delete files via DELETE /api/files"
    - "All paths are sandboxed to C:\\simulator-data"
  artifacts:
    - path: "src/FileSimulator.ControlApi/Models/FileNodeDto.cs"
      provides: "File tree node data transfer object"
      contains: "class FileNodeDto"
    - path: "src/FileSimulator.ControlApi/Controllers/FilesController.cs"
      provides: "File CRUD operations"
      contains: "class FilesController"
      min_lines: 100
  key_links:
    - from: "src/FileSimulator.ControlApi/Controllers/FilesController.cs"
      to: "C:\\simulator-data"
      via: "Path.Combine with config base path"
      pattern: "Path\\.Combine.*basePath"
    - from: "src/FileSimulator.ControlApi/Program.cs"
      to: "FilesController"
      via: "AddControllers registration"
      pattern: "AddControllers"
---

<objective>
Implement REST API endpoints for file operations: browse, upload, download, and delete.

Purpose: Enable dashboard UI to interact with files in the Windows simulator-data directory through standard HTTP endpoints.

Output:
- FileNodeDto model for directory tree nodes
- FilesController with CRUD endpoints
- Path validation to sandbox all operations to C:\simulator-data
</objective>

<execution_context>
@C:\Users\UserC\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\UserC\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/08-file-operations-event-streaming/08-RESEARCH.md

# Existing backend patterns
@src/FileSimulator.ControlApi/Program.cs
@src/FileSimulator.ControlApi/Models/ServerStatus.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create FileNodeDto model</name>
  <files>
    src/FileSimulator.ControlApi/Models/FileNodeDto.cs
  </files>
  <action>
Create FileNodeDto.cs in Models folder:

```csharp
namespace FileSimulator.ControlApi.Models;

/// <summary>
/// Represents a file or directory in the file tree.
/// </summary>
public record FileNodeDto
{
    /// <summary>Path relative to base directory (used as ID in frontend tree)</summary>
    public required string Id { get; init; }

    /// <summary>File or directory name</summary>
    public required string Name { get; init; }

    /// <summary>True if this is a directory</summary>
    public required bool IsDirectory { get; init; }

    /// <summary>File size in bytes (null for directories)</summary>
    public long? Size { get; init; }

    /// <summary>Last modified timestamp (ISO 8601)</summary>
    public required string Modified { get; init; }

    /// <summary>Protocols that can access this path</summary>
    public required List<string> Protocols { get; init; }

    /// <summary>Child nodes (populated if directory and expanded)</summary>
    public List<FileNodeDto>? Children { get; init; }
}
```

This model supports:
- Minimal file info per CONTEXT.md (name, size, modified)
- Protocol badges per requirement
- Tree structure for react-arborist
  </action>
  <verify>
File compiles:
```powershell
dotnet build src/FileSimulator.ControlApi/FileSimulator.ControlApi.csproj
```
  </verify>
  <done>FileNodeDto record has all properties needed for file tree display.</done>
</task>

<task type="auto">
  <name>Task 2: Create FilesController with CRUD endpoints</name>
  <files>
    src/FileSimulator.ControlApi/Controllers/FilesController.cs
  </files>
  <action>
Create Controllers folder if not exists.
Create FilesController.cs:

```csharp
namespace FileSimulator.ControlApi.Controllers;

using Microsoft.AspNetCore.Mvc;
using FileSimulator.ControlApi.Models;

[ApiController]
[Route("api/files")]
public class FilesController : ControllerBase
{
    private readonly string _basePath;
    private readonly ILogger<FilesController> _logger;

    // Hidden directories to exclude
    private static readonly HashSet<string> HiddenDirs = new(StringComparer.OrdinalIgnoreCase)
    {
        ".minio.sys", ".deleted"
    };

    public FilesController(IConfiguration config, ILogger<FilesController> logger)
    {
        _basePath = config["FileWatcher:Path"] ?? @"C:\simulator-data";
        _logger = logger;
    }
```

Implement these endpoints:

**GET /api/files/tree?path=** - Directory listing
- Default path = root (empty string)
- Validate path stays within _basePath
- Return List<FileNodeDto> for immediate children
- Exclude hidden directories (.minio.sys, .deleted)
- Include protocol visibility per directory mapping
- Sort: directories first, then files, alphabetically

**POST /api/files/upload** - File upload
- Accept IFormFile
- Optional query param: path (target directory, default root)
- Validate target stays within _basePath
- Use original filename (sanitized via Path.GetFileName)
- Return created FileNodeDto
- Size limit: 100 MB (RequestSizeLimit attribute)

**GET /api/files/download?path=** - File download
- Validate path stays within _basePath
- Validate file exists and is not directory
- Return FileStreamResult with Content-Disposition attachment
- Content-Type: application/octet-stream

**DELETE /api/files?path=** - Delete file or directory
- Validate path stays within _basePath
- If directory, require recursive=true query param for safety
- Delete file or directory
- Return 204 No Content on success

**Private helper methods:**

```csharp
private bool ValidatePath(string relativePath, out string fullPath)
{
    fullPath = Path.GetFullPath(Path.Combine(_basePath, relativePath));
    return fullPath.StartsWith(_basePath, StringComparison.OrdinalIgnoreCase);
}

private List<string> GetVisibleProtocols(string fullPath)
{
    // Same logic as FileWatcherService
    var relativePath = Path.GetRelativePath(_basePath, fullPath);
    var topDir = relativePath.Split(Path.DirectorySeparatorChar)[0];

    return topDir switch
    {
        var d when d.StartsWith("nas-", StringComparison.OrdinalIgnoreCase) => new() { "NAS" },
        "ftpuser" => new() { "FTP" },
        "nfs" => new() { "NFS" },
        "input" or "output" or "processed" or "archive" =>
            new() { "FTP", "SFTP", "HTTP", "S3", "SMB", "NFS" },
        _ => new()
    };
}
```

CRITICAL: Path validation MUST use GetFullPath + StartsWith to prevent path traversal attacks (../../etc).
  </action>
  <verify>
File compiles:
```powershell
dotnet build src/FileSimulator.ControlApi/FileSimulator.ControlApi.csproj
```
  </verify>
  <done>FilesController implements browse, upload, download, delete with path sandboxing.</done>
</task>

<task type="auto">
  <name>Task 3: Register controllers in Program.cs</name>
  <files>
    src/FileSimulator.ControlApi/Program.cs
  </files>
  <action>
Update Program.cs to enable controllers:

1. Add controller services (after AddHealthChecks):
```csharp
// Add controllers for file operations
builder.Services.AddControllers();
```

2. Map controllers (after MapHub calls):
```csharp
// Map REST API controllers
app.MapControllers();
```

3. Optionally configure file upload size limit in Kestrel:
```csharp
builder.WebHost.UseKestrel(options =>
{
    options.AddServerHeader = false;
    options.Limits.MaxRequestBodySize = 104857600; // 100 MB
});
```

Note: This plan modifies Program.cs. If Plan 01 also modifies it, they can be applied in parallel since they modify different sections. Plan 01 adds FileWatcherService and FileEventsHub. Plan 02 adds AddControllers and MapControllers.
  </action>
  <verify>
Build and test endpoints:
```powershell
dotnet build src/FileSimulator.ControlApi/FileSimulator.ControlApi.csproj

# Run locally and test
cd src/FileSimulator.ControlApi
dotnet run &

# Test tree endpoint
curl http://localhost:5000/api/files/tree
# Should return JSON array of FileNodeDto

# Test upload
echo "test content" > test-upload.txt
curl -X POST -F "file=@test-upload.txt" "http://localhost:5000/api/files/upload"
# Should return 200 with FileNodeDto

# Test download
curl -O "http://localhost:5000/api/files/download?path=test-upload.txt"

# Test delete
curl -X DELETE "http://localhost:5000/api/files?path=test-upload.txt"
# Should return 204
```
  </verify>
  <done>Controllers registered. All file endpoints accessible at /api/files/*.</done>
</task>

</tasks>

<verification>
1. Solution builds: `dotnet build src/FileSimulator.ControlApi/FileSimulator.ControlApi.csproj`
2. GET /api/files/tree returns directory listing
3. POST /api/files/upload accepts files
4. GET /api/files/download returns file content
5. DELETE /api/files removes files
6. Path traversal attempts (../) rejected with 400
</verification>

<success_criteria>
- File tree endpoint returns FileNodeDto[] with protocols
- Upload saves file to target directory
- Download returns file with correct content-type
- Delete removes file/directory with confirmation for recursive
- All paths validated to stay within C:\simulator-data
</success_criteria>

<output>
After completion, create `.planning/phases/08-file-operations-event-streaming/08-02-SUMMARY.md`
</output>
