---
phase: 08-file-operations-event-streaming
plan: 04
type: execute
wave: 2
depends_on: ["08-02", "08-03"]
files_modified:
  - src/dashboard/src/components/FileBrowser.tsx
  - src/dashboard/src/components/FileTree.tsx
  - src/dashboard/src/components/FileUploader.tsx
  - src/dashboard/src/components/ProtocolBadges.tsx
autonomous: true

must_haves:
  truths:
    - "User can browse file tree with expand/collapse directories"
    - "User can see file name, size, and modified date"
    - "User can upload files via drag-and-drop"
    - "Files show protocol visibility badges"
  artifacts:
    - path: "src/dashboard/src/components/FileBrowser.tsx"
      provides: "Main file browser container"
      contains: "export function FileBrowser"
      min_lines: 50
    - path: "src/dashboard/src/components/FileTree.tsx"
      provides: "react-arborist tree wrapper"
      contains: "export function FileTree"
      min_lines: 60
    - path: "src/dashboard/src/components/FileUploader.tsx"
      provides: "react-dropzone uploader"
      contains: "export function FileUploader"
      min_lines: 50
    - path: "src/dashboard/src/components/ProtocolBadges.tsx"
      provides: "Protocol visibility badges"
      contains: "export function ProtocolBadges"
  key_links:
    - from: "src/dashboard/src/components/FileBrowser.tsx"
      to: "useFileOperations"
      via: "hook import and call"
      pattern: "useFileOperations"
    - from: "src/dashboard/src/components/FileTree.tsx"
      to: "react-arborist"
      via: "Tree component import"
      pattern: "from 'react-arborist'"
    - from: "src/dashboard/src/components/FileUploader.tsx"
      to: "react-dropzone"
      via: "useDropzone hook"
      pattern: "useDropzone"
---

<objective>
Implement file browser UI components: tree view with react-arborist, file uploader with react-dropzone, and protocol badges.

Purpose: Enable users to visually browse the C:\simulator-data directory, upload files via drag-and-drop, and see which protocols can access each file.

Output:
- FileBrowser container component
- FileTree component wrapping react-arborist
- FileUploader component wrapping react-dropzone
- ProtocolBadges component for protocol visibility
</objective>

<execution_context>
@C:\Users\UserC\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\UserC\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/08-file-operations-event-streaming/08-RESEARCH.md
@.planning/phases/08-file-operations-event-streaming/08-03-SUMMARY.md

# Existing frontend patterns
@src/dashboard/src/App.tsx
@src/dashboard/src/components/ServerCard.tsx
@src/dashboard/src/components/ServerDetailsPanel.tsx
@src/dashboard/src/types/fileTypes.ts
@src/dashboard/src/hooks/useFileOperations.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create ProtocolBadges component</name>
  <files>
    src/dashboard/src/components/ProtocolBadges.tsx
  </files>
  <action>
Create ProtocolBadges.tsx for displaying protocol visibility:

```typescript
import type { FileProtocol } from '../types/fileTypes';

interface ProtocolBadgesProps {
  protocols: FileProtocol[];
  size?: 'small' | 'normal';
}

/**
 * Displays protocol visibility badges for a file/directory.
 * Shows which protocols can access the item.
 */
export function ProtocolBadges({ protocols, size = 'normal' }: ProtocolBadgesProps) {
  if (protocols.length === 0) {
    return null;
  }

  const sizeClass = size === 'small' ? 'protocol-badges--small' : '';

  return (
    <div className={`protocol-badges ${sizeClass}`}>
      {protocols.map(protocol => (
        <span
          key={protocol}
          className={`protocol-badge protocol-badge--${protocol.toLowerCase()}`}
          title={`Accessible via ${protocol}`}
        >
          {protocol}
        </span>
      ))}
    </div>
  );
}

export default ProtocolBadges;
```

The CSS will be added in Plan 05 along with other styles.
  </action>
  <verify>
TypeScript compiles:
```powershell
cd src/dashboard
npx tsc --noEmit
```
  </verify>
  <done>ProtocolBadges renders colored badges for each protocol.</done>
</task>

<task type="auto">
  <name>Task 2: Create FileTree component with react-arborist</name>
  <files>
    src/dashboard/src/components/FileTree.tsx
  </files>
  <action>
Create FileTree.tsx wrapping react-arborist:

```typescript
import { useEffect, useState, useCallback } from 'react';
import { Tree, NodeRendererProps } from 'react-arborist';
import type { FileNode } from '../types/fileTypes';
import ProtocolBadges from './ProtocolBadges';

interface FileTreeProps {
  nodes: FileNode[];
  onSelect?: (node: FileNode | null) => void;
  onDelete?: (node: FileNode) => void;
  onDownload?: (node: FileNode) => void;
  onLoadChildren?: (path: string) => Promise<FileNode[]>;
  height?: number;
}

// Format bytes to human-readable
function formatBytes(bytes: number): string {
  if (bytes === 0) return '0 B';
  const k = 1024;
  const sizes = ['B', 'KB', 'MB', 'GB'];
  const i = Math.floor(Math.log(bytes) / Math.log(k));
  return `${(bytes / Math.pow(k, i)).toFixed(1)} ${sizes[i]}`;
}

// Format date to locale string
function formatDate(isoDate: string): string {
  try {
    return new Date(isoDate).toLocaleString();
  } catch {
    return isoDate;
  }
}

/**
 * File tree browser using react-arborist.
 * Supports lazy loading of children on expand.
 */
export function FileTree({
  nodes,
  onSelect,
  onDelete,
  onDownload,
  onLoadChildren,
  height = 400,
}: FileTreeProps) {
  // Convert FileNode[] to react-arborist format
  // react-arborist expects 'children' to be an array or undefined
  const [treeData, setTreeData] = useState<FileNode[]>(nodes);

  useEffect(() => {
    setTreeData(nodes);
  }, [nodes]);

  const handleSelect = useCallback((selected: any[]) => {
    if (onSelect) {
      onSelect(selected.length > 0 ? selected[0].data : null);
    }
  }, [onSelect]);

  // Custom node renderer
  const Node = ({ node, style, dragHandle }: NodeRendererProps<FileNode>) => {
    const data = node.data;

    const handleDeleteClick = (e: React.MouseEvent) => {
      e.stopPropagation();
      if (onDelete) {
        onDelete(data);
      }
    };

    const handleDownloadClick = (e: React.MouseEvent) => {
      e.stopPropagation();
      if (onDownload && !data.isDirectory) {
        onDownload(data);
      }
    };

    return (
      <div
        className="file-tree-node"
        style={style}
        ref={dragHandle}
        onClick={() => node.isInternal && node.toggle()}
      >
        <span className="file-tree-node__icon">
          {data.isDirectory ? (node.isOpen ? 'üìÇ' : 'üìÅ') : 'üìÑ'}
        </span>

        <span className="file-tree-node__name" title={data.id}>
          {data.name}
        </span>

        {!data.isDirectory && data.size !== undefined && (
          <span className="file-tree-node__size">
            {formatBytes(data.size)}
          </span>
        )}

        <span className="file-tree-node__modified" title={formatDate(data.modified)}>
          {formatDate(data.modified).split(',')[0]}
        </span>

        <ProtocolBadges protocols={data.protocols} size="small" />

        <div className="file-tree-node__actions">
          {!data.isDirectory && (
            <button
              className="file-tree-node__action"
              onClick={handleDownloadClick}
              title="Download"
            >
              ‚¨á
            </button>
          )}
          <button
            className="file-tree-node__action file-tree-node__action--delete"
            onClick={handleDeleteClick}
            title="Delete"
          >
            üóë
          </button>
        </div>
      </div>
    );
  };

  return (
    <div className="file-tree">
      <Tree
        data={treeData}
        openByDefault={false}
        width="100%"
        height={height}
        indent={24}
        rowHeight={36}
        onSelect={handleSelect}
        childrenAccessor="children"
        idAccessor="id"
      >
        {Node}
      </Tree>
    </div>
  );
}

export default FileTree;
```
  </action>
  <verify>
TypeScript compiles:
```powershell
cd src/dashboard
npx tsc --noEmit
```
  </verify>
  <done>FileTree renders tree with icons, size, date, protocols, and action buttons.</done>
</task>

<task type="auto">
  <name>Task 3: Create FileUploader component with react-dropzone</name>
  <files>
    src/dashboard/src/components/FileUploader.tsx
  </files>
  <action>
Create FileUploader.tsx wrapping react-dropzone:

```typescript
import { useCallback, useState } from 'react';
import { useDropzone } from 'react-dropzone';
import type { UploadProgress } from '../types/fileTypes';

interface FileUploaderProps {
  onUpload: (file: File) => Promise<{ success: boolean; message?: string }>;
  targetPath?: string;
  disabled?: boolean;
}

/**
 * Drag-and-drop file uploader using react-dropzone.
 * Supports multiple files with progress tracking.
 */
export function FileUploader({ onUpload, targetPath, disabled }: FileUploaderProps) {
  const [uploads, setUploads] = useState<UploadProgress[]>([]);

  const processFile = useCallback(async (file: File) => {
    // Add to uploads list
    setUploads(prev => [...prev, {
      fileName: file.name,
      progress: 0,
      status: 'uploading',
    }]);

    try {
      const result = await onUpload(file);

      setUploads(prev => prev.map(u =>
        u.fileName === file.name
          ? {
              ...u,
              progress: 100,
              status: result.success ? 'complete' : 'error',
              error: result.message,
            }
          : u
      ));

      // Remove completed uploads after 3 seconds
      if (result.success) {
        setTimeout(() => {
          setUploads(prev => prev.filter(u => u.fileName !== file.name));
        }, 3000);
      }
    } catch (err) {
      const message = err instanceof Error ? err.message : 'Upload failed';
      setUploads(prev => prev.map(u =>
        u.fileName === file.name
          ? { ...u, status: 'error', error: message }
          : u
      ));
    }
  }, [onUpload]);

  const onDrop = useCallback((acceptedFiles: File[]) => {
    acceptedFiles.forEach(processFile);
  }, [processFile]);

  const { getRootProps, getInputProps, isDragActive } = useDropzone({
    onDrop,
    disabled,
    multiple: true,
    maxSize: 104857600, // 100 MB
  });

  const clearCompleted = useCallback(() => {
    setUploads(prev => prev.filter(u => u.status === 'uploading'));
  }, []);

  return (
    <div className="file-uploader">
      <div
        {...getRootProps()}
        className={`file-uploader__dropzone ${isDragActive ? 'file-uploader__dropzone--active' : ''} ${disabled ? 'file-uploader__dropzone--disabled' : ''}`}
      >
        <input {...getInputProps()} />
        {isDragActive ? (
          <p className="file-uploader__text">Drop files here...</p>
        ) : (
          <p className="file-uploader__text">
            Drag &amp; drop files here, or click to browse
            {targetPath && (
              <span className="file-uploader__target">
                Upload to: {targetPath || '/'}
              </span>
            )}
          </p>
        )}
      </div>

      {uploads.length > 0 && (
        <div className="file-uploader__list">
          <div className="file-uploader__list-header">
            <span>Uploads</span>
            <button
              className="file-uploader__clear"
              onClick={clearCompleted}
              type="button"
            >
              Clear completed
            </button>
          </div>
          {uploads.map(upload => (
            <div
              key={upload.fileName}
              className={`file-uploader__item file-uploader__item--${upload.status}`}
            >
              <span className="file-uploader__item-name">{upload.fileName}</span>
              <span className="file-uploader__item-status">
                {upload.status === 'uploading' && 'Uploading...'}
                {upload.status === 'complete' && 'Complete'}
                {upload.status === 'error' && (upload.error || 'Failed')}
              </span>
            </div>
          ))}
        </div>
      )}
    </div>
  );
}

export default FileUploader;
```
  </action>
  <verify>
TypeScript compiles:
```powershell
cd src/dashboard
npx tsc --noEmit
```
  </verify>
  <done>FileUploader handles drag-drop with upload progress and status display.</done>
</task>

<task type="auto">
  <name>Task 4: Create FileBrowser container component</name>
  <files>
    src/dashboard/src/components/FileBrowser.tsx
  </files>
  <action>
Create FileBrowser.tsx as the main container:

```typescript
import { useState, useEffect, useCallback } from 'react';
import type { FileNode } from '../types/fileTypes';
import { useFileOperations } from '../hooks/useFileOperations';
import FileTree from './FileTree';
import FileUploader from './FileUploader';

interface FileBrowserProps {
  apiBaseUrl: string;
}

/**
 * Main file browser container.
 * Combines file tree, upload, and operations.
 */
export function FileBrowser({ apiBaseUrl }: FileBrowserProps) {
  const { fetchTree, uploadFile, downloadFile, deleteFile, isLoading, error } = useFileOperations(apiBaseUrl);
  const [nodes, setNodes] = useState<FileNode[]>([]);
  const [selectedNode, setSelectedNode] = useState<FileNode | null>(null);
  const [currentPath, setCurrentPath] = useState<string>('');

  // Load initial tree
  useEffect(() => {
    loadTree();
  }, []);

  const loadTree = useCallback(async (path?: string) => {
    const data = await fetchTree(path);
    setNodes(data);
  }, [fetchTree]);

  const handleUpload = useCallback(async (file: File) => {
    const result = await uploadFile(file, currentPath || undefined);
    if (result.success) {
      // Refresh tree after upload
      await loadTree(currentPath || undefined);
    }
    return result;
  }, [uploadFile, currentPath, loadTree]);

  const handleDownload = useCallback(async (node: FileNode) => {
    if (!node.isDirectory) {
      await downloadFile(node.id);
    }
  }, [downloadFile]);

  const handleDelete = useCallback(async (node: FileNode) => {
    const message = node.isDirectory
      ? `Delete folder "${node.name}" and all contents?`
      : `Delete file "${node.name}"?`;

    if (!window.confirm(message)) {
      return;
    }

    const result = await deleteFile(node.id, node.isDirectory);
    if (result.success) {
      // Clear selection if deleted node was selected
      if (selectedNode?.id === node.id) {
        setSelectedNode(null);
      }
      // Refresh tree
      await loadTree(currentPath || undefined);
    } else {
      alert(result.message || 'Delete failed');
    }
  }, [deleteFile, selectedNode, currentPath, loadTree]);

  const handleSelect = useCallback((node: FileNode | null) => {
    setSelectedNode(node);
    // If selecting a directory, could update currentPath for upload target
    if (node?.isDirectory) {
      setCurrentPath(node.id);
    }
  }, []);

  const handleRefresh = useCallback(() => {
    loadTree(currentPath || undefined);
  }, [loadTree, currentPath]);

  const handleNavigateUp = useCallback(() => {
    if (currentPath) {
      const parts = currentPath.split(/[/\\]/);
      parts.pop();
      const newPath = parts.join('/');
      setCurrentPath(newPath);
      loadTree(newPath || undefined);
    }
  }, [currentPath, loadTree]);

  return (
    <div className="file-browser">
      <div className="file-browser__header">
        <h2 className="file-browser__title">File Browser</h2>
        <div className="file-browser__breadcrumb">
          <button
            className="file-browser__nav-btn"
            onClick={handleNavigateUp}
            disabled={!currentPath}
            title="Go up"
          >
            ..
          </button>
          <span className="file-browser__path">
            /{currentPath || ''}
          </span>
        </div>
        <button
          className="file-browser__refresh"
          onClick={handleRefresh}
          disabled={isLoading}
          title="Refresh"
        >
          Refresh
        </button>
      </div>

      {error && (
        <div className="file-browser__error">
          {error}
        </div>
      )}

      <FileUploader
        onUpload={handleUpload}
        targetPath={currentPath}
        disabled={isLoading}
      />

      <div className="file-browser__tree-container">
        {isLoading && nodes.length === 0 ? (
          <div className="file-browser__loading">Loading...</div>
        ) : nodes.length === 0 ? (
          <div className="file-browser__empty">
            No files found. Drop files above to upload.
          </div>
        ) : (
          <FileTree
            nodes={nodes}
            onSelect={handleSelect}
            onDelete={handleDelete}
            onDownload={handleDownload}
            height={400}
          />
        )}
      </div>

      {selectedNode && (
        <div className="file-browser__details">
          <h3>{selectedNode.name}</h3>
          <p>Path: {selectedNode.id}</p>
          <p>Type: {selectedNode.isDirectory ? 'Directory' : 'File'}</p>
          {selectedNode.size !== undefined && (
            <p>Size: {selectedNode.size} bytes</p>
          )}
          <p>Modified: {selectedNode.modified}</p>
          <p>Protocols: {selectedNode.protocols.join(', ') || 'None'}</p>
        </div>
      )}
    </div>
  );
}

export default FileBrowser;
```
  </action>
  <verify>
TypeScript compiles and no lint errors:
```powershell
cd src/dashboard
npx tsc --noEmit
npm run lint
```
  </verify>
  <done>FileBrowser integrates FileTree, FileUploader with navigation, selection, and operations.</done>
</task>

</tasks>

<verification>
1. All files compile: `npx tsc --noEmit`
2. No lint errors: `npm run lint`
3. Components follow existing patterns (functional, hooks, TypeScript)
4. Tree displays file info and protocol badges
5. Uploader handles drag-drop with progress
6. Delete shows confirmation dialog
</verification>

<success_criteria>
- FileBrowser renders with header, uploader, tree, and details
- FileTree uses react-arborist with custom node rendering
- FileUploader uses react-dropzone with progress tracking
- ProtocolBadges displays colored protocol indicators
- Delete shows confirmation before proceeding
</success_criteria>

<output>
After completion, create `.planning/phases/08-file-operations-event-streaming/08-04-SUMMARY.md`
</output>
